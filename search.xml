<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++问题笔记</title>
    <url>/2022/04/24/cpp-note/</url>
    <content><![CDATA[<h3 id="启用括号包围"><a href="#启用括号包围" class="headerlink" title="启用括号包围"></a>启用括号包围</h3><p>在visual studio中，工具—&gt;选项—&gt;高级，可以启用括号包围，</p>
<p><img src="C:\Users\91590\AppData\Roaming\Typora\typora-user-images\1651199369386.png" alt="1651199369386"></p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建博客相关问题</title>
    <url>/2022/04/13/hexo-note/</url>
    <content><![CDATA[<h1 id="【随时补充】搭建个人博客时遇到的一些问题"><a href="#【随时补充】搭建个人博客时遇到的一些问题" class="headerlink" title="【随时补充】搭建个人博客时遇到的一些问题"></a>【随时补充】搭建个人博客时遇到的一些问题</h1><h3 id="如何解决无法访问Github"><a href="#如何解决无法访问Github" class="headerlink" title="如何解决无法访问Github"></a>如何解决无法访问Github</h3><p>在 C:\Windows\System32\drivers\etc\hosts 文件中末尾添加两行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">140.82.113.4 github.com</span><br><span class="line">140.82.113.4 www.github.com</span><br></pre></td></tr></table></figure>
<p>其中ip地址可在 <a href="https://github.com.ipaddress.com/www.github.com">https://github.com.ipaddress.com/www.github.com</a> 中查询</p>
<p>若完成上述操作后仍无法访问，可以再添加两行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">69.171.224.40 github.global.ssl.fastly.net</span><br><span class="line">185.199.111.153 assets-cdn.github.com</span><br></pre></td></tr></table></figure>
<p>其中ip地址可以在 <a href="http://tool.chinaz.com/dns">http://tool.chinaz.com/dns</a> 中输入网址查询，选取TTL值较低的ip地址即可</p>
<p>在修改hosts文件时，通常先将其复制到其他路径得到一个副本，将副本修改保存后替换原文件。（建议修改前备份一个hosts文件）</p>
<p>参考：<a href="https://www.cnblogs.com/yanch01/p/GitHub-access.html">https://www.cnblogs.com/yanch01/p/GitHub-access.html</a></p>
<hr>
<h3 id="修改主题配置"><a href="#修改主题配置" class="headerlink" title="修改主题配置"></a>修改主题配置</h3><p>在hexo根目录下创建一个_config.[主题名].yml，例如：_config.next.yml，可以覆盖主题目录下_config.yml文件的作用。这样可以在不修改主题_config.yml文件的情况下，很方便的修改主题配置。</p>
<h3 id="styles-styl文件"><a href="#styles-styl文件" class="headerlink" title="styles.styl文件"></a>styles.styl文件</h3><p>在next 8.x版本中，用户需要自行创建styles.styl文件，放在[hexo根目录]\source\_data\下，注意不是next主题目录下的source文件夹。如果你的source文件夹里没有_data文件夹，创建一个即可。</p>
<p>然后在_config.next.yml中，找到以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Define custom file paths.</span><br><span class="line"># Create your custom files in site directory `source/_data` and uncomment needed files below.</span><br><span class="line">custom_file_path:</span><br><span class="line">  #head: source/_data/head.njk</span><br><span class="line">  #header: source/_data/header.njk</span><br><span class="line">  #sidebar: source/_data/sidebar.njk</span><br><span class="line">  #postMeta: source/_data/post-meta.njk</span><br><span class="line">  #postBodyEnd: source/_data/post-body-end.njk</span><br><span class="line">  #footer: source/_data/footer.njk</span><br><span class="line">  #bodyEnd: source/_data/body-end.njk</span><br><span class="line">  #variable: source/_data/variables.styl</span><br><span class="line">  #mixin: source/_data/mixins.styl</span><br><span class="line">  #style: source/_data/styles.styl</span><br></pre></td></tr></table></figure>

<p>将其中的style项取消注释，即可通过修改styles.styl的方式来进行个性化设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">style: source/_data/styles.styl			//取消注释，即删去#号</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://github.com/iissnan/hexo-theme-next/issues/680">https://github.com/iissnan/hexo-theme-next/issues/680</a></p>
<hr>
<h3 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h3><p>想要在远端部署时实现正文首行缩进2字符，可以在 styles.styl文件中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//仅正文首行缩进2字符</span><br><span class="line">.post-body p &#123; text-indent: 2em; &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="制作Table"><a href="#制作Table" class="headerlink" title="制作Table"></a>制作Table</h3><p>参考：<a href="https://theme-next.js.org/docs/tag-plugins/tabs.html">https://theme-next.js.org/docs/tag-plugins/tabs.html</a></p>
<h3 id="修改tab缩进距离"><a href="#修改tab缩进距离" class="headerlink" title="修改tab缩进距离"></a>修改tab缩进距离</h3><p>在[hexo根目录]\source\_data\styles.styl文件中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//设置tab-size</span><br><span class="line">pre &#123;</span><br><span class="line">    tab-size: 4;			//数字即是tab的缩进距离</span><br><span class="line">&#125;</span><br><span class="line">.hljs &#123;</span><br><span class="line">    tab-size: 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过尝试后发现，pre对本地部署一定有效，对远端部署我也不知道哪个是有效的，所以就都加上了。</p>
<p>参考：<a href="https://github.com/blinkfox/hexo-theme-matery/issues/637">https://github.com/blinkfox/hexo-theme-matery/issues/637</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>学习FPGA（二）</title>
    <url>/2022/04/14/FPGA/FPGA-2/</url>
    <content><![CDATA[<h1 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h1><p>状态的表示常用编码方法有二进制码、格雷码（Gray code）、独热码（one-hot code）。</p>
<h2 id="二进制码"><a href="#二进制码" class="headerlink" title="二进制码"></a>二进制码</h2><p>即用二进制计数</p>
<p>优点：属于压缩状态编码，状态机所需的状态向量位数较少；</p>
<p>缺点：1、译码复杂；2、相邻状态变换时，会有多位发生改变，电噪声大、转换速度较慢、易出错；（实际电路中多位改变很难做到完全同时发生）；</p>
<h2 id="格雷码（Gray-code）"><a href="#格雷码（Gray-code）" class="headerlink" title="格雷码（Gray code）"></a>格雷码（Gray code）</h2><p>在一组数的编码中，任意两个相邻的代码只有一位二进制数不同，且最大数与最小数之间也仅有一位数不同<br>构造方法：<br>1位格雷码有两个码字<br>(n+1)位格雷码中的前2n个码字等于n位格雷码的码字，按顺序书写，加前缀0<br>(n+1)位格雷码中的后2n个码字等于n位格雷码的码字，按逆序书写，加前缀1<br>n+1位格雷码的集合 &#x3D; n位格雷码集合(顺序)加前缀0 + n位格雷码集合(逆序)加前缀1<br>如：二进制码：000-001-010-011-100-101-110-111 相应的格雷码：000-001-011-010-110-111-101<br>    优点：1、属于压缩状态编码，状态机所需的状态向量位数较少；2、相邻状态变换时，仅有一位发生改变，电噪声小、转换速度较快；<br>    缺点：1、译码复杂；2、是一种变权码，每一位码没有固定的大小，难以直接比较大小和算术运算；</p>
<h2 id="独热码（one-hot-code）"><a href="#独热码（one-hot-code）" class="headerlink" title="独热码（one-hot code）"></a>独热码（one-hot code）</h2><p>有多少个状态就有多少个比特，其中有且只有一个比特为1，其余为0<br>用独热码表示三个状态可以写为：001，010，100</p>
<p>优点：译码简单；</p>
<p>缺点：速度较慢，占用触发器资源较多，面积较大；</p>
<h2 id="编写一个检测”Hello”序列的状态机"><a href="#编写一个检测”Hello”序列的状态机" class="headerlink" title="编写一个检测”Hello”序列的状态机"></a>编写一个检测”Hello”序列的状态机</h2><p>设置状态时，常用localparam或者parameter。其中parameter可用作在顶层模块中例化底层模块时传递参数的接口；而localparam的作用域仅仅限于当前module，不能作为参数传递的接口。</p>
<p>状态机分为一段时状态机、两段式状态机、三段式状态机，</p>
<p>作者第一次写出的代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> state_machine (Clk, Rst_n, data, led); <span class="comment">//Hello状态机</span></span><br><span class="line">	<span class="keyword">input</span> Clk;	<span class="comment">//基准时钟信号50M</span></span><br><span class="line">	<span class="keyword">input</span> Rst_n;	<span class="comment">//输入异步复位信号</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] data;	<span class="comment">//输入数据</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> led; <span class="comment">//当前状态输入</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//set state</span></span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] state, next;</span><br><span class="line">	<span class="keyword">localparam</span></span><br><span class="line">		CHECK_H = <span class="number">&#x27;d0</span>, </span><br><span class="line">		CHECK_e = <span class="number">&#x27;d1</span>, </span><br><span class="line">		CHECK_la = <span class="number">&#x27;d2</span>, </span><br><span class="line">		CHECK_lb = <span class="number">&#x27;d3</span>, </span><br><span class="line">		CHECK_o = <span class="number">&#x27;d4</span>;</span><br><span class="line">	<span class="comment">//state transition (combinational logic)</span></span><br><span class="line">	<span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">case</span>(state)</span><br><span class="line">			CHECK_H:	<span class="keyword">begin</span></span><br><span class="line">				<span class="keyword">if</span>(data == <span class="string">&quot;H&quot;</span>) </span><br><span class="line">					next = CHECK_e;</span><br><span class="line">				<span class="keyword">else</span> </span><br><span class="line">					next = CHECK_H;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			CHECK_e:	<span class="keyword">begin</span></span><br><span class="line">				<span class="keyword">if</span>(data == <span class="string">&quot;e&quot;</span>) </span><br><span class="line">					next = CHECK_la;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(data == <span class="string">&quot;H&quot;</span>)</span><br><span class="line">					next = CHECK_e;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					next = CHECK_H;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			CHECK_la:	<span class="keyword">begin</span></span><br><span class="line">				<span class="keyword">if</span>(data == <span class="string">&quot;l&quot;</span>) </span><br><span class="line">					next = CHECK_lb;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(data == <span class="string">&quot;H&quot;</span>)</span><br><span class="line">					next = CHECK_e;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					next = CHECK_H;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			CHECK_lb:	<span class="keyword">begin</span></span><br><span class="line">				<span class="keyword">if</span>(data == <span class="string">&quot;l&quot;</span>) </span><br><span class="line">					next = CHECK_o;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(data == <span class="string">&quot;H&quot;</span>)</span><br><span class="line">					next = CHECK_e;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					next = CHECK_H;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			CHECK_o:	<span class="keyword">begin</span></span><br><span class="line">				<span class="keyword">if</span>(data == <span class="string">&quot;o&quot;</span>) </span><br><span class="line">					next = CHECK_H;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(data == <span class="string">&quot;H&quot;</span>)</span><br><span class="line">					next = CHECK_e;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					next = CHECK_H;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">default</span>: next = CHECK_H;<span class="comment">//默认状态下reset</span></span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">//state flip-flops (sequential logic)</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> Clk <span class="keyword">or</span> <span class="keyword">negedge</span> Rst_n) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~Rst_n) state &lt;= CHECK_H;</span><br><span class="line">		<span class="keyword">else</span> state &lt;= next;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">//output</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> Clk <span class="keyword">or</span> <span class="keyword">negedge</span> Rst_n) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~Rst_n) led &lt;= <span class="number">1&#x27;b1</span>;	<span class="comment">//通常led低电平有效，高电平无效</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">case</span>(state)</span><br><span class="line">			CHECK_o: led &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">			<span class="keyword">default</span>: led &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>FPGA</tag>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>学习FPGA（一）</title>
    <url>/2022/04/13/FPGA/FPGA-1/</url>
    <content><![CDATA[<p>刚好今天尝试使用hexo框架搭建了个人博客，索性记录一下自己学习FPGA的过程，方便日后查看和复习。</p>
<h2 id="BCD计数器设计与验证"><a href="#BCD计数器设计与验证" class="headerlink" title="BCD计数器设计与验证"></a>BCD计数器设计与验证</h2><p>目的是通过将三个BCD计数器级联来实现1000的计数<br>单个BCD计数器的Verilog代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> bcd_counter(Clk, Cin, Rst_n, Cout, Q);</span><br><span class="line">	<span class="keyword">input</span> Clk;<span class="comment">//时间基准信号</span></span><br><span class="line">	<span class="keyword">input</span> Cin;<span class="comment">//计数器进位输入</span></span><br><span class="line">	<span class="keyword">input</span> Rst_n;<span class="comment">//计数器复位输入</span></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> Cout;<span class="comment">//计数器进位输出</span></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] Q;<span class="comment">//计数器计数输出</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//产生输出进位信号</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> Clk <span class="keyword">or</span> <span class="keyword">negedge</span> Rst_n) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(Rst_n==<span class="number">1&#x27;b0</span>) Cout = <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(Q==<span class="number">4&#x27;d9</span> &amp;&amp; Cin==<span class="number">1&#x27;b1</span>) Cout = <span class="number">1&#x27;b1</span>;	<span class="comment">//此处的进位设置并不合理，级联后会发生错误</span></span><br><span class="line">		<span class="keyword">else</span> Cout = <span class="number">1&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//执行计数过程</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> Clk <span class="keyword">or</span> <span class="keyword">negedge</span> Rst_n) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(Rst_n==<span class="number">1&#x27;b0</span>) Q &lt;= <span class="number">4&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(Cin==<span class="number">1&#x27;b1</span>) <span class="keyword">begin</span></span><br><span class="line">			<span class="keyword">if</span>(Q==<span class="number">4&#x27;d9</span>)Q &lt;= <span class="number">4&#x27;b0</span>;</span><br><span class="line">			<span class="keyword">else</span> Q &lt;= Q + <span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> Q &lt;= Q;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>使用modelsim分析时，先从sim中把子模块的输入输出信号全部添加到波形窗口中然后在波形窗口中选中所有信号（Ctrl+a），再按下快捷键Ctrl+g，完成按模块分组</p>
<p>将”&#x2F;&#x2F;产生输出进位信号”部分修改为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(Rst_n==<span class="number">1&#x27;b0</span>) Cout = <span class="number">1&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(Q==<span class="number">4&#x27;d9</span> &amp;&amp; Cin==<span class="number">1&#x27;b1</span>) Cout = <span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="keyword">else</span> Cout = <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>此即行为级建模实现的组合逻辑，但仿真的结果出现了奇怪的毛刺，这是rtl级仿真不该出现的</p>
<p>于是再将其改为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> Cout = (Q==<span class="number">4&#x27;d9</span> &amp;&amp; Cin==<span class="number">1&#x27;b1</span>);</span><br></pre></td></tr></table></figure>
<p>此即数据流建模实现的组合逻辑。需要注意的是，此时应当将Cout的类型变更为wire型，否则会发生编译错误。</p>
<p>他们占用的逻辑资源也出现了不同</p>
]]></content>
      <tags>
        <tag>FPGA</tag>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>学习FPGA（三）</title>
    <url>/2022/04/15/FPGA/FPGA-3/</url>
    <content><![CDATA[<h1 id="按键消抖"><a href="#按键消抖" class="headerlink" title="按键消抖"></a>按键消抖</h1><h2 id="主模块"><a href="#主模块" class="headerlink" title="主模块"></a>主模块</h2><p>三段式状态机代码如下</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目的：设计一个按键消抖，滤波时间为20ms</span></span><br><span class="line"><span class="comment">//晶振为50M，即一个时间周期为20ns</span></span><br><span class="line"><span class="comment">//需要滤波1_000_000个时间周期</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> filter_time 20&#x27;d1_000_000</span></span><br><span class="line"><span class="keyword">module</span> key_filter(Clk, Rst_n, Key_in, Key_flag, Key_state);</span><br><span class="line">	<span class="keyword">input</span> Clk;	<span class="comment">//时钟输入</span></span><br><span class="line">	<span class="keyword">input</span> Rst_n;	<span class="comment">//复位输入</span></span><br><span class="line">	<span class="keyword">input</span> Key_in;	<span class="comment">//按键输入，按下时为0，断开时为1</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> Key_flag;	<span class="comment">//按键输入变化后出现稳定状态时，显示为1（保持一个时钟周期），其余时候为0</span></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> Key_state;	<span class="comment">//按键状态，按下时显示为0， 断开时为1</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//set state(one-hot code)</span></span><br><span class="line">	<span class="keyword">localparam</span> </span><br><span class="line">		IDLE		= <span class="number">4&#x27;b0001</span>, </span><br><span class="line">		FILTER0	= <span class="number">4&#x27;b0010</span>, </span><br><span class="line">		DOWN		= <span class="number">4&#x27;b0100</span>,</span><br><span class="line">		FILTER1	= <span class="number">4&#x27;b1000</span>;</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] state, next;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//edge check</span></span><br><span class="line">	<span class="keyword">reg</span> Key_tmp0, Key_tmp1;</span><br><span class="line">	<span class="keyword">wire</span> Key_posedge, Key_negedge;</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> Clk <span class="keyword">or</span> <span class="keyword">negedge</span> Rst_n) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~Rst_n) <span class="keyword">begin</span></span><br><span class="line">			Key_tmp0 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">			Key_tmp1 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">			Key_tmp0 &lt;= Key_in;		<span class="comment">//当Key_tmp0 = 1 且 Key_tmp1 = 0时即为一个上升沿</span></span><br><span class="line">			Key_tmp1 &lt;= Key_tmp0;	<span class="comment">//当Key_tmp0 = 0 且 Key_tmp1 = 1时即为一个下降沿</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">assign</span> Key_posedge = ~Key_tmp1 &amp; Key_tmp0;</span><br><span class="line">	<span class="keyword">assign</span> Key_negedge = Key_tmp1 &amp; ~Key_tmp0;</span><br><span class="line">	<span class="comment">//filter counter</span></span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">19</span>:<span class="number">0</span>] cnt;</span><br><span class="line">	<span class="keyword">reg</span> cnt_full;	<span class="comment">//计数器计满信号</span></span><br><span class="line">	<span class="keyword">reg</span> en_cnt;		<span class="comment">//计数器使能信号</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> Clk <span class="keyword">or</span> <span class="keyword">negedge</span> Rst_n) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~Rst_n) <span class="keyword">begin</span></span><br><span class="line">			cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">			cnt_full &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(en_cnt) <span class="keyword">begin</span></span><br><span class="line">			<span class="keyword">if</span>(cnt == (`filter_time - <span class="number">1</span>)) <span class="keyword">begin</span></span><br><span class="line">				cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">				cnt_full &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">				cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">				cnt_full &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">			cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">			cnt_full &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//state transition(combinational)</span></span><br><span class="line">	<span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">case</span>(state)</span><br><span class="line">			IDLE: <span class="keyword">begin</span></span><br><span class="line">				<span class="keyword">if</span>(Key_negedge)</span><br><span class="line">					next = FILTER0;</span><br><span class="line">				<span class="keyword">else</span> </span><br><span class="line">					next = IDLE;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			FILTER0: <span class="keyword">begin</span></span><br><span class="line">				<span class="keyword">if</span>(cnt_full)</span><br><span class="line">					next = DOWN;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(Key_posedge)</span><br><span class="line">					next = IDLE;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					next = FILTER0;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			DOWN: <span class="keyword">begin</span></span><br><span class="line">				<span class="keyword">if</span>(Key_posedge)</span><br><span class="line">					next = FILTER1;</span><br><span class="line">				<span class="keyword">else</span> </span><br><span class="line">					next = DOWN;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			FILTER1: <span class="keyword">begin</span> </span><br><span class="line">				<span class="keyword">if</span>(cnt_full) </span><br><span class="line">					next = IDLE;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(Key_negedge)</span><br><span class="line">					next = DOWN;</span><br><span class="line">				<span class="keyword">else</span> </span><br><span class="line">					next = FILTER1;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">default</span>: next = IDLE;</span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//state flip-flops(sequential)</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> Clk <span class="keyword">or</span> <span class="keyword">negedge</span> Rst_n) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~Rst_n) state &lt;= IDLE;</span><br><span class="line">		<span class="keyword">else</span> state &lt;= next;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//output</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> Clk <span class="keyword">or</span> <span class="keyword">negedge</span> Rst_n) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~Rst_n)</span><br><span class="line">			Key_state &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">case</span>(next)</span><br><span class="line">			IDLE: <span class="keyword">begin</span> </span><br><span class="line">				en_cnt &lt;= <span class="number">1&#x27;b0</span>;		<span class="comment">//IDLE状态下计数器不计数</span></span><br><span class="line">				Key_state &lt;= <span class="number">1&#x27;b1</span>;	<span class="comment">//此时Key未被按下</span></span><br><span class="line">				Key_flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			FILTER0: <span class="keyword">begin</span></span><br><span class="line">				en_cnt &lt;= <span class="number">1&#x27;b1</span>;		<span class="comment">//FILTER0状态下计数器开始计数	</span></span><br><span class="line">				Key_state &lt;= <span class="number">1&#x27;b1</span>;	<span class="comment">//此时Key仍处于未被按下状态</span></span><br><span class="line">				Key_flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			DOWN: <span class="keyword">begin</span></span><br><span class="line">				en_cnt &lt;= <span class="number">1&#x27;b0</span>;		<span class="comment">//DOWN状态下计数器不计数	</span></span><br><span class="line">				Key_state &lt;= <span class="number">1&#x27;b0</span>;	<span class="comment">//此时Key已被按下</span></span><br><span class="line">				Key_flag &lt;= cnt_full;<span class="comment">//探测到Key被按下</span></span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			FILTER1: <span class="keyword">begin</span></span><br><span class="line">				en_cnt &lt;= <span class="number">1&#x27;b1</span>;		<span class="comment">//FILTER0状态下计数器开始计数	</span></span><br><span class="line">				Key_state &lt;= <span class="number">1&#x27;b0</span>;	<span class="comment">//此时Key仍处于被按下状态</span></span><br><span class="line">				Key_flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">				en_cnt &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">				Key_state &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">				Key_flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//assign Key_flag = Key_negedge;	//组合逻辑输出方式来输出Key_flag</span></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>
<h2 id="Testbench"><a href="#Testbench" class="headerlink" title="Testbench"></a>Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1 ns/ 1 ns</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> clk_period 20</span></span><br><span class="line"><span class="keyword">module</span> key_filter_vlg_tst();</span><br><span class="line">	<span class="comment">// test vector input registers</span></span><br><span class="line">	<span class="keyword">reg</span> Clk;</span><br><span class="line">	<span class="keyword">reg</span> Key_in;</span><br><span class="line">	<span class="keyword">reg</span> Rst_n;</span><br><span class="line">	<span class="comment">// wires</span></span><br><span class="line">	<span class="keyword">wire</span> Key_flag;</span><br><span class="line">	<span class="keyword">wire</span> Key_state;</span><br><span class="line">									</span><br><span class="line">	key_filter i1 (</span><br><span class="line">	<span class="comment">// port map - connection between master ports and signals/registers</span></span><br><span class="line">		<span class="variable">.Clk</span>(Clk),</span><br><span class="line">		<span class="variable">.Key_flag</span>(Key_flag),</span><br><span class="line">		<span class="variable">.Key_in</span>(Key_in),</span><br><span class="line">		<span class="variable">.Key_state</span>(Key_state),</span><br><span class="line">		<span class="variable">.Rst_n</span>(Rst_n)</span><br><span class="line">	);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		Clk = <span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="keyword">forever</span> <span class="variable">#(`clk_period/2)</span> Clk = ~Clk;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		Rst_n = <span class="number">1&#x27;b0</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="variable">#(`clk_period*10)</span> Rst_n = <span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="variable">#(`clk_period*10 + 1)</span>;</span><br><span class="line">		<span class="comment">//按下一次</span></span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">10000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">5_400_000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2600</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1300</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">200</span>;</span><br><span class="line">		</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">20_000_100</span>;</span><br><span class="line">		#<span class="number">10000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1400</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2600</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1300</span>;</span><br><span class="line">		</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">20_000_100</span>;</span><br><span class="line">		#<span class="number">10_000_000</span>;</span><br><span class="line">		<span class="comment">//second time</span></span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1400</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2600</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1300</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">200</span>;</span><br><span class="line">		</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">20_000_100</span>;</span><br><span class="line">		#<span class="number">10000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1400</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2600</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1300</span>;</span><br><span class="line">		</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">20_000_100</span>;</span><br><span class="line">		#<span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//third time</span></span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1400</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2600</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1300</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">200</span>;</span><br><span class="line">		</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">20_000_100</span>;</span><br><span class="line">		#<span class="number">10000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1400</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2600</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1300</span>;</span><br><span class="line">		</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">20_000_100</span>;</span><br><span class="line">		#<span class="number">10000</span>;</span><br><span class="line">		<span class="built_in">$stop</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>
<h1 id="仿真模型"><a href="#仿真模型" class="headerlink" title="仿真模型"></a>仿真模型</h1><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>{$random}默认是32位的随机数，根据自己的需要来取余计算，例如：需要0 ~ 65535的随机数，则可：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span>	[<span class="number">15</span>:<span class="number">0</span>] myrand;</span><br><span class="line"><span class="keyword">initial</span> myrand = &#123;<span class="built_in">$random</span>&#125;%<span class="number">65536</span>;</span><br></pre></td></tr></table></figure>
<p>其中，myrand就是所需的随机数。</p>
<h2 id="task"><a href="#task" class="headerlink" title="task"></a>task</h2><p>定义一个task如下所示</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] myrand;</span><br><span class="line"><span class="keyword">task</span> press_key;</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">repeat</span>(<span class="number">50</span>) <span class="keyword">begin</span></span><br><span class="line">			myrand = &#123;<span class="built_in">$random</span>&#125;%<span class="number">65536</span>;</span><br><span class="line">			#myrand key_in = ~key_in;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		key_in = <span class="number">0</span>;</span><br><span class="line">		#<span class="number">50_000_000</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">repeat</span>(<span class="number">50</span>) <span class="keyword">begin</span></span><br><span class="line">			myrand = &#123;<span class="built_in">$random</span>&#125;%<span class="number">65536</span>;</span><br><span class="line">			#myrand key_in = ~key_in;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		key_in = <span class="number">0</span>;</span><br><span class="line">		#<span class="number">50_000_000</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure>
<p>然后就可以直接在testbench中使用</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">press_key;</span><br></pre></td></tr></table></figure>
<h2 id="仿真模型-1"><a href="#仿真模型-1" class="headerlink" title="仿真模型"></a>仿真模型</h2><p>新建一个key_module文件</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1 ns/1 ps</span></span><br><span class="line"><span class="keyword">module</span> key_module(key);</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> key;</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] myrand;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		key = <span class="number">1&#x27;b1</span>;</span><br><span class="line">		press_key;</span><br><span class="line">		#<span class="number">10000</span>;</span><br><span class="line">		press_key;</span><br><span class="line">		#<span class="number">10000</span>;</span><br><span class="line">		press_key;</span><br><span class="line">		<span class="built_in">$stop</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">task</span> press_key;</span><br><span class="line">		<span class="keyword">begin</span></span><br><span class="line">			<span class="keyword">repeat</span>(<span class="number">50</span>) <span class="keyword">begin</span></span><br><span class="line">				myrand = &#123;<span class="built_in">$random</span>&#125;%<span class="number">65536</span>;</span><br><span class="line">				#myrand key = ~key;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			key = <span class="number">0</span>;</span><br><span class="line">			#<span class="number">50_000_000</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">repeat</span>(<span class="number">50</span>) <span class="keyword">begin</span></span><br><span class="line">				myrand = &#123;<span class="built_in">$random</span>&#125;%<span class="number">65536</span>;</span><br><span class="line">				#myrand key = ~key;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			key = <span class="number">1</span>;</span><br><span class="line">			#<span class="number">50_000_000</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>
<p>使用时需将该文件添加到test bench中，test bench主文件为</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1 ns/ 1 ns</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> clk_period 20</span></span><br><span class="line"><span class="keyword">module</span> key_filter_vlg_tst();</span><br><span class="line">	<span class="comment">// test vector input registers</span></span><br><span class="line">	<span class="keyword">reg</span> Clk;</span><br><span class="line">	<span class="keyword">wire</span> Key_in;</span><br><span class="line">	<span class="keyword">reg</span> Rst_n;</span><br><span class="line">	<span class="comment">// wires</span></span><br><span class="line">	<span class="keyword">wire</span> Key_flag;</span><br><span class="line">	<span class="keyword">wire</span> Key_state;</span><br><span class="line">									</span><br><span class="line">	key_filter i1 (</span><br><span class="line">	<span class="comment">// port map - connection between master ports and signals/registers</span></span><br><span class="line">		<span class="variable">.Clk</span>(Clk),</span><br><span class="line">		<span class="variable">.Key_flag</span>(Key_flag),</span><br><span class="line">		<span class="variable">.Key_in</span>(Key_in),</span><br><span class="line">		<span class="variable">.Key_state</span>(Key_state),</span><br><span class="line">		<span class="variable">.Rst_n</span>(Rst_n)</span><br><span class="line">	);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		Clk = <span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="keyword">forever</span> <span class="variable">#(`clk_period/2)</span> Clk = ~Clk;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		Rst_n = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="variable">#(`clk_period*10)</span> Rst_n = <span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="variable">#(`clk_period*10 + 1)</span> ;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	key_module u1(<span class="variable">.key</span>(Key_in));</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>FPGA</tag>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/04/13/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>C++笔记（一）——变量和复合类型</title>
    <url>/2022/04/18/cpp/cpp-note-1/</url>
    <content><![CDATA[<h2 id="不同初始化方式的区别"><a href="#不同初始化方式的区别" class="headerlink" title="不同初始化方式的区别"></a>不同初始化方式的区别</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">double</span> ld = <span class="number">3.1415926536</span>;</span><br><span class="line">	<span class="type">int</span> a&#123; ld &#125;, b = &#123; ld &#125;;  <span class="comment">//错误：会提示error C2397: 从“long double”转换到“int”需要收缩转换</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">c</span><span class="params">(ld)</span>, d </span>= ld;<span class="comment">//能够完成编译，且确实丢失了部分值，c和d输出均为3</span></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; c &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于局部变量来说，初始化很重要；在编写某个类的时候，尽量申明当该类的某个对象未被显式初始化时，生成一个合适的默认值。</p>
<h2 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h2><p>C++支持分离式编译(separate compilation)</p>
<p>声明(declaration)：使得某个名字为程序所知，即这个变量已经在别处定义了，我现在拿来用。（声明一个其他地方定义过的全局变量）</p>
<p>定义(definition)：创建与名字关联的实体。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;	<span class="comment">//声明i而非定义i，但如果显式初始化后则会抵消了extern的作用</span></span><br><span class="line"><span class="type">int</span> j;	<span class="comment">//定义j</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">double</span> pi = <span class="number">3.1416</span>;	<span class="comment">//定义pi，且初始化为3.1416</span></span><br></pre></td></tr></table></figure>
<p>在函数内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。</p>
<p>ps: C++是一种静态类型（statically typed）语言，其含义是在编译阶段执行类型检查（type checking）。如果编译器发现数据类型不支持要执行的运算，则会报错且不会生成任何可执行的程序。程序越复杂，静态类型检查越有助于发现问题。这要求我们在使用某个变量之前必须声明其类型。</p>
<h2 id="标识符-identifier"><a href="#标识符-identifier" class="headerlink" title="标识符(identifier)"></a>标识符(identifier)</h2><p>变量命名规范：</p>
<ol>
<li>标识符要体现实际含义；</li>
<li>变量名一般用小写字母，如index；</li>
<li>用户自定义的类名一般以大写字母开头，如Sales_item；</li>
<li>如果标识符由多个单词组成，则单词间要有明显区分，如student_loan或studentLoan；</li>
</ol>
<p>建议：当第一次使用变量时再定义它，即随用随定义</p>
<ol>
<li>有助于找到变量的定义；</li>
<li>可以赋予一个合理的初始值；</li>
<li>防止在程序一开始初始化一堆未用到的变量，从而拖慢运行速度；</li>
</ol>
<h2 id="作用域-scope"><a href="#作用域-scope" class="headerlink" title="作用域(scope)"></a>作用域(scope)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> i = <span class="number">420</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; i++)	<span class="comment">//for()中的i作用域仅在()之中</span></span><br><span class="line">		sum += i;</span><br><span class="line">	cout &lt;&lt; i &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; sum &lt;&lt; endl;	<span class="comment">//得到的输出为420	45</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> i = <span class="number">420</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">100</span>;	<span class="comment">//覆盖了全局变量i</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; i++)	<span class="comment">//for()中的i作用域仅在()之中</span></span><br><span class="line">		sum += i;</span><br><span class="line">	cout &lt;&lt; ::i &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; sum &lt;&lt; endl;	<span class="comment">//得到的输出为420 100 45</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="引用-reference"><a href="#引用-reference" class="headerlink" title="引用(reference)"></a>引用(reference)</h2><p>引用并非对象，而是为一个已经存在的对象所起的别名，不需要独立的内存空间；</p>
<p>引用初始化后，无法再令该引用重新绑定到另一个对象，因此引用必须初始化；</p>
<p>因为引用并非一个对象，所以不能定义引用的引用；</p>
<p>引用的类型必须与引用绑定的对象严格匹配。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line">	<span class="type">int</span> &amp;refVal0 = ival;	<span class="comment">//正确</span></span><br><span class="line">	<span class="type">int</span> &amp;refVal1 = refVal;	<span class="comment">//正确：实际上是以与引用绑定的对象再定义了另一个引用</span></span><br><span class="line">	<span class="type">int</span> &amp;refVal2;	<span class="comment">//错误：没有初始化引用</span></span><br><span class="line">	<span class="type">int</span> &amp;refVal3 = &amp;refVal1;	<span class="comment">//错误：不能定义引用的引用</span></span><br><span class="line">	<span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line">	<span class="type">int</span> &amp;refVal4 = dval;	<span class="comment">//错误：类型不匹配</span></span><br><span class="line">	refVal = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针-pointer"><a href="#指针-pointer" class="headerlink" title="指针(pointer)"></a>指针(pointer)</h2><p>指针本身就是一个对象，需要独立的内存空间;</p>
<p>指针初始化后，可以通过赋值来改变指针的值或指针指向的对象；</p>
<p>因为指针是一个对象，所以可以定义指针的指针；</p>
<p>指针的类型必须与指针的对象严格匹配。</p>
<p>指针的值（即地址）属于下列4中状态之一：</p>
<ol>
<li>指向一个对象</li>
<li>指向紧邻对象所占空间的下一个位置</li>
<li>空指针，没有指向任何对象</li>
<li>无效指针，上述情况之外的其他值</li>
</ol>
<p>建议：</p>
<ol>
<li>初始化所有指针；</li>
<li>尽量定义了对象之后再定义指向它的指针；</li>
<li>如果实在不清楚指针应该指向何处，就先初始化为nullptr或者0；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ival1 = <span class="number">0</span>, ival2 = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *pi = &amp;ival1;</span><br><span class="line">pi = &amp;ival2;	<span class="comment">//pi的值被改变，现在pi指向了ival，或者说pi的值变成了存放ival的地址</span></span><br><span class="line">*pi = <span class="number">0</span>;	<span class="comment">//ival的值被改变，指针pi并没有改变</span></span><br></pre></td></tr></table></figure>
<p><strong>赋值改变的永远是&#x3D;左侧的对象！！！</strong></p>
<p>void* 指针是一种特殊的指针类型，可以存放任意对象的地址。它可以用于和其他指针比较、作为函数的输入输出、赋值给另一个void* 指针。但是，不能对它所指向的对象进行操作，因为我们并不知道这个对象到底是什么类型。</p>
<p>概括来讲，void* 的视角来看，内存空间仅仅只是内存空间，没办法访问内存空间中所存的对象。</p>
<p><em>练习2.18</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ival1 = <span class="number">1</span>, ival2 = <span class="number">1</span>, ival3 = <span class="number">4</span>;</span><br><span class="line">	<span class="type">int</span>* p1 = &amp;ival1, * p2 = &amp;ival2;</span><br><span class="line">	<span class="comment">//改变指针的值</span></span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; ival1 &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; ival3 &lt;&lt; endl;</span><br><span class="line">	p1 = &amp;ival3;</span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; ival1 &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; ival3 &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//改变指针指向对象的值</span></span><br><span class="line">	cout &lt;&lt; p2 &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; *p2 &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; ival2 &lt;&lt; endl;</span><br><span class="line">	*p2 = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; p2 &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; *p2 &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; ival2 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>练习2.23</em></p>
<p>设给定指针为p</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(p) ival = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> ival = <span class="number">2</span>;	<span class="comment">//这个if...else...可以判断出p是否有一个合法的值（即合法地址）</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>学习FPGA（四）</title>
    <url>/2022/04/17/FPGA/FPGA-4/</url>
    <content><![CDATA[<h1 id="实现FPGA驱动数码管动态显示"><a href="#实现FPGA驱动数码管动态显示" class="headerlink" title="实现FPGA驱动数码管动态显示"></a>实现FPGA驱动数码管动态显示</h1><p>知识点：</p>
<ol>
<li>数码管动态扫描实现。</li>
<li>In system sources and probes editor (ISSP)调试工具的使用。</li>
</ol>
<h2 id="工程代码"><a href="#工程代码" class="headerlink" title="工程代码"></a>工程代码</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现FPGA驱动数码管动态显示</span></span><br><span class="line"><span class="keyword">module</span> digital_display(Clk, Rst_n, En, disp_data, sel, seg);</span><br><span class="line">	<span class="keyword">input</span> Clk;					<span class="comment">//50M，一个周期为20ns</span></span><br><span class="line">	<span class="keyword">input</span> Rst_n;</span><br><span class="line">	<span class="keyword">input</span> En;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] disp_data;	<span class="comment">//输入要求显示的内容</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] sel;			<span class="comment">//数码管位选（当前要显示的数码管）</span></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">6</span>:<span class="number">0</span>] seg;			<span class="comment">//数码管段选（当前要显示的内容）</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//divider module</span></span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">14</span>:<span class="number">0</span>] divider_cnt;	<span class="comment">//产生1ms的时钟，每0.5ms时钟信号需要翻转一次，0.5ms/20ns=25_000=16&#x27;b0110_0001_1010_1000，故需要15位计数器</span></span><br><span class="line">	<span class="keyword">reg</span> Clk_1K;</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> Clk <span class="keyword">or</span> <span class="keyword">negedge</span> Rst_n) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~Rst_n) </span><br><span class="line">			divider_cnt &lt;= <span class="number">15&#x27;d0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(~En) </span><br><span class="line">			divider_cnt &lt;= <span class="number">15&#x27;d0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(divider_cnt== <span class="number">15&#x27;d24_999</span>) </span><br><span class="line">			divider_cnt &lt;= <span class="number">15&#x27;d0</span>;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			divider_cnt &lt;= divider_cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> Clk <span class="keyword">or</span> <span class="keyword">negedge</span> Rst_n) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~Rst_n) </span><br><span class="line">			Clk_1K &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(~En) </span><br><span class="line">			Clk_1K &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(divider_cnt== <span class="number">15&#x27;d24_999</span>) </span><br><span class="line">			Clk_1K &lt;= ~Clk_1K;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			Clk_1K &lt;= Clk_1K;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">//shift8 module</span></span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] sel_r;</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> Clk_1K <span class="keyword">or</span> <span class="keyword">negedge</span> Rst_n) <span class="keyword">begin</span>	<span class="comment">//注意，分频器的输出信号作为D触发器的时钟信号，在大型设计中是不被允许的，此处设计为数码管驱动模块，影响不大，允许存在这样的毛刺</span></span><br><span class="line">		<span class="keyword">if</span>(~Rst_n)</span><br><span class="line">			sel_r &lt;= <span class="number">8&#x27;b0000_0001</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(sel_r == <span class="number">8&#x27;b1000_0000</span>)</span><br><span class="line">			sel_r &lt;= <span class="number">8&#x27;b0000_0001</span>;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			sel_r &lt;= &#123;sel_r[<span class="number">6</span>:<span class="number">0</span>],<span class="number">1&#x27;b0</span>&#125;;	<span class="comment">//此句也可改为	sel_r &lt;= sel_r &lt;&lt; 1;</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//MUX8 (combitional)</span></span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] data_tmp;</span><br><span class="line">	<span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">case</span>(sel_r)</span><br><span class="line">			<span class="number">8&#x27;b0000_0001</span>: data_tmp = disp_data[<span class="number">3</span>:<span class="number">0</span>];</span><br><span class="line">			<span class="number">8&#x27;b0000_0010</span>: data_tmp = disp_data[<span class="number">7</span>:<span class="number">4</span>];</span><br><span class="line">			<span class="number">8&#x27;b0000_0100</span>: data_tmp = disp_data[<span class="number">11</span>:<span class="number">8</span>];</span><br><span class="line">			<span class="number">8&#x27;b0000_1000</span>: data_tmp = disp_data[<span class="number">15</span>:<span class="number">12</span>];</span><br><span class="line">			</span><br><span class="line">			<span class="number">8&#x27;b0001_0000</span>: data_tmp = disp_data[<span class="number">19</span>:<span class="number">16</span>];</span><br><span class="line">			<span class="number">8&#x27;b0010_0000</span>: data_tmp = disp_data[<span class="number">23</span>:<span class="number">20</span>];</span><br><span class="line">			<span class="number">8&#x27;b0100_0000</span>: data_tmp = disp_data[<span class="number">27</span>:<span class="number">24</span>];</span><br><span class="line">			<span class="number">8&#x27;b1000_0000</span>: data_tmp = disp_data[<span class="number">31</span>:<span class="number">28</span>];</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">default</span>: data_tmp = <span class="number">4&#x27;b0000</span>;</span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//MUX2 (combitional)</span></span><br><span class="line">	<span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~En)</span><br><span class="line">			sel = <span class="number">8&#x27;b0000_0000</span>;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			sel = sel_r;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//LUT (combitional)</span></span><br><span class="line">	<span class="comment">//注意：数码管灯段在输入为0时亮起，输入为1时熄灭；</span></span><br><span class="line">	<span class="comment">//h段为最高位，a段为最低位；</span></span><br><span class="line">	<span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">case</span>(data_tmp)</span><br><span class="line">			<span class="number">4&#x27;b0000</span>: seg = <span class="number">7&#x27;b100_0000</span>;	<span class="comment">//0</span></span><br><span class="line">			<span class="number">4&#x27;b0001</span>: seg = <span class="number">7&#x27;b111_1001</span>;	<span class="comment">//1</span></span><br><span class="line">			<span class="number">4&#x27;b0010</span>: seg = <span class="number">7&#x27;b010_0100</span>;	<span class="comment">//2</span></span><br><span class="line">			<span class="number">4&#x27;b0011</span>: seg = <span class="number">7&#x27;b011_0000</span>;	<span class="comment">//3</span></span><br><span class="line">			</span><br><span class="line">			<span class="number">4&#x27;b0100</span>: seg = <span class="number">7&#x27;b001_1001</span>;	<span class="comment">//4</span></span><br><span class="line">			<span class="number">4&#x27;b0101</span>: seg = <span class="number">7&#x27;b001_0010</span>;	<span class="comment">//5</span></span><br><span class="line">			<span class="number">4&#x27;b0110</span>: seg = <span class="number">7&#x27;b000_0010</span>;	<span class="comment">//6</span></span><br><span class="line">			<span class="number">4&#x27;b0111</span>: seg = <span class="number">7&#x27;b111_1000</span>;	<span class="comment">//7</span></span><br><span class="line">			</span><br><span class="line">			<span class="number">4&#x27;b1000</span>: seg = <span class="number">7&#x27;b000_0000</span>;	<span class="comment">//8</span></span><br><span class="line">			<span class="number">4&#x27;b1001</span>: seg = <span class="number">7&#x27;b001_0000</span>;	<span class="comment">//9</span></span><br><span class="line">			<span class="number">4&#x27;b1010</span>: seg = <span class="number">7&#x27;b000_1000</span>;	<span class="comment">//a</span></span><br><span class="line">			<span class="number">4&#x27;b1011</span>: seg = <span class="number">7&#x27;b000_0011</span>;	<span class="comment">//b</span></span><br><span class="line">			</span><br><span class="line">			<span class="number">4&#x27;b1100</span>: seg = <span class="number">7&#x27;b100_0110</span>;	<span class="comment">//c</span></span><br><span class="line">			<span class="number">4&#x27;b1101</span>: seg = <span class="number">7&#x27;b010_0001</span>;	<span class="comment">//d</span></span><br><span class="line">			<span class="number">4&#x27;b1110</span>: seg = <span class="number">7&#x27;b000_0110</span>;	<span class="comment">//e</span></span><br><span class="line">			<span class="number">4&#x27;b1111</span>: seg = <span class="number">7&#x27;b000_1110</span>;	<span class="comment">//f</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">default</span>: seg = <span class="number">7&#x27;b111_1111</span>;	<span class="comment">//全灭</span></span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>
<h2 id="TestBench"><a href="#TestBench" class="headerlink" title="TestBench"></a>TestBench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1 ns/ 1 ps</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> clk_period 20</span></span><br><span class="line"><span class="keyword">module</span> digital_display_vlg_tst();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">reg</span> Clk;</span><br><span class="line">	<span class="keyword">reg</span> En;</span><br><span class="line">	<span class="keyword">reg</span> Rst_n;</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] disp_data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">wire</span> [<span class="number">6</span>:<span class="number">0</span>]  seg;</span><br><span class="line">	<span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>]  sel;</span><br><span class="line"></span><br><span class="line">	digital_display u1 (</span><br><span class="line">		<span class="variable">.Clk</span>(Clk),</span><br><span class="line">		<span class="variable">.En</span>(En),</span><br><span class="line">		<span class="variable">.Rst_n</span>(Rst_n),</span><br><span class="line">		<span class="variable">.disp_data</span>(disp_data),</span><br><span class="line">		<span class="variable">.seg</span>(seg),</span><br><span class="line">		<span class="variable">.sel</span>(sel)</span><br><span class="line">	);</span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		Clk = <span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="keyword">forever</span> <span class="variable">#(`clk_period/2)</span> Clk = ~Clk;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		Rst_n = <span class="number">1&#x27;b0</span>;</span><br><span class="line">		En = <span class="number">1&#x27;b1</span>;</span><br><span class="line">		disp_data = <span class="number">32&#x27;h12345678</span>;</span><br><span class="line">		<span class="variable">#(`clk_period*20)</span>;</span><br><span class="line">		Rst_n = <span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="variable">#(`clk_period*20)</span>;</span><br><span class="line">		#<span class="number">20_000_000</span>;</span><br><span class="line">		disp_data = <span class="number">32&#x27;h87654321</span>;</span><br><span class="line">		#<span class="number">20_000_000</span>;</span><br><span class="line">		disp_data = <span class="number">32&#x27;h89abcdef</span>;</span><br><span class="line">		#<span class="number">20_000_000</span>;</span><br><span class="line">		<span class="built_in">$stop</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>得到的仿真波形：</p>
<p><img src="C:\Users\91590\AppData\Roaming\Typora\typora-user-images\1650940716028.png" alt="1650940716028"></p>
<h2 id="ISSP"><a href="#ISSP" class="headerlink" title="ISSP"></a>ISSP</h2><p>使用IP核</p>
<p><img src="C:\Users\91590\AppData\Roaming\Typora\typora-user-images\1650940825468.png" alt="1650940825468"></p>
<ol>
<li>可以作为探针；</li>
<li>可以作为驱动源（数据源）；</li>
</ol>
<p>本次实验需要用到的探针宽度为0，数据源宽度为32</p>
<p><img src="C:\Users\91590\AppData\Roaming\Typora\typora-user-images\1650940889217.png" alt="1650940889217"></p>
<p>完成后，将文件烧录到开发板上，在Tools中找到In-System Sources and Probes Editor</p>
<p><img src="C:\Users\91590\AppData\Roaming\Typora\typora-user-images\1650940973799.png" alt="1650940973799"></p>
<p><img src="C:\Users\91590\AppData\Roaming\Typora\typora-user-images\1650940980678.png" alt="1650940980678"></p>
<p>设置改成十六进制，之后直接在data里面设置需要的数据，就可以将数据输入到开发板上</p>
]]></content>
      <tags>
        <tag>FPGA</tag>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>C++笔记（二）——const限定符</title>
    <url>/2022/04/20/cpp/cpp-note-2/</url>
    <content><![CDATA[<h1 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h1><h2 id="const对象"><a href="#const对象" class="headerlink" title="const对象"></a>const对象</h2><p>const对象一旦创建后其值就不可改变，因此必须初始化；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="built_in">get_size</span>();	<span class="comment">//正确：运行时初始化，get_size()为有返回值的函数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> j = <span class="number">42</span>;			<span class="comment">//正确：编译时初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> k;				<span class="comment">//错误：k是一个未经初始化的常量</span></span><br></pre></td></tr></table></figure>
<p>默认状态下，const对象仅在文件内有效，因为编译器将在编译过程中会把用到该变量的地方都替换成对应的值，每个用了const对象的文件都必须含有对它的定义而非声明；<br>如：<br>在test1中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">1</span>;	<span class="comment">//定义全局常量i，初始化为1</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">2</span>;			<span class="comment">//定义全局变量j，初始化为2</span></span><br></pre></td></tr></table></figure>
<p>test2中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="type">int</span> i;</span><br><span class="line">	cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>test3中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="type">int</span> j;</span><br><span class="line">	cout &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中test2会报错error LNK2001: 无法解析的外部符号 “int i”；而test3中能够得到输出2。<br>对于一种const变量，它的初始值不是一个常量表达式，如果想只在一个文件中定义这类const对象，而且在其他多个文件中声明并使用它，方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file_1.cpp中</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize = <span class="built_in">fcn</span>();</span><br><span class="line"><span class="comment">//file_1.h中</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize;	<span class="comment">//与file_1.cpp中定义的bufSize是同一个</span></span><br></pre></td></tr></table></figure>
<h2 id="对常量的引用-reference-to-const"><a href="#对常量的引用-reference-to-const" class="headerlink" title="对常量的引用(reference to const)"></a>对常量的引用(reference to const)</h2><p>“对常量的引用”可以简称为“常量引用”，因为引用不是一个对象，所以实际上不存在常量引用</p>
<p>对常量进行引用时，引用也必须为常量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">1034</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = ci;	<span class="comment">//正确：引用及其对应的对象都是常量</span></span><br><span class="line"></span><br><span class="line">r1 = <span class="number">42</span>;			<span class="comment">//错误：r1是对常量的引用，不可改变其值</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = ci;		<span class="comment">//错误：试图让一个非常量引用指向一个常量对象</span></span><br></pre></td></tr></table></figure>
<h3 id="常量引用的两个例外（待补充）"><a href="#常量引用的两个例外（待补充）" class="headerlink" title="常量引用的两个例外（待补充）"></a>常量引用的两个例外（待补充）</h3><ul>
<li><h4 id="初始化常量引用时允许用任意表达式作为初值，只要其结果能够转换成常量引用的类型即可"><a href="#初始化常量引用时允许用任意表达式作为初值，只要其结果能够转换成常量引用的类型即可" class="headerlink" title="初始化常量引用时允许用任意表达式作为初值，只要其结果能够转换成常量引用的类型即可"></a>初始化常量引用时允许用任意表达式作为初值，只要其结果能够转换成常量引用的类型即可</h4></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = i;		<span class="comment">//允许将const int&amp;绑定到一个普通int对象上</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = <span class="number">42</span>;		<span class="comment">//正确</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 = r1 * <span class="number">2</span>;	<span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;r4 = r4 * <span class="number">2</span>;		<span class="comment">//错误：r4是一个普通的非常量引用</span></span><br></pre></td></tr></table></figure>
<p>原因：在使用常量引用时，系编译器生成了一个与该常量引用同类型的临时量(temporary)对象，再将常量引用绑定在这个临时量对象上。</p>
<p>常量引用绑定的对象可以是非const对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i =<span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r1 = i;			<span class="comment">//引用ri绑定对象i</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = i;		<span class="comment">//r2也绑定对象i，当时不允许通过r2修改i的值</span></span><br><span class="line">r1 = <span class="number">0</span>;					<span class="comment">//r1并非常量，i的值修改为0</span></span><br><span class="line">r2 = <span class="number">0</span>;					<span class="comment">//错误：r2是一个常量引用，不可通过r2修改i的值</span></span><br></pre></td></tr></table></figure>
<h2 id="指向常量的指针-pointer-to-const"><a href="#指向常量的指针-pointer-to-const" class="headerlink" title="指向常量的指针(pointer to const)"></a>指向常量的指针(pointer to const)</h2><p>指向常量的指针不能用于改变其所指对象的值；要想存放常量对象的地址，只能使用指向常量的指针。</p>
<h3 id="指向常量的指针的两个例外（待补充）"><a href="#指向常量的指针的两个例外（待补充）" class="headerlink" title="指向常量的指针的两个例外（待补充）"></a>指向常量的指针的两个例外（待补充）</h3><ul>
<li><h4 id="允许一个指向常量的指针指向一个非常量对象，指向常量的指针没有规定其所指对象必须是一个常量"><a href="#允许一个指向常量的指针指向一个非常量对象，指向常量的指针没有规定其所指对象必须是一个常量" class="headerlink" title="允许一个指向常量的指针指向一个非常量对象，指向常量的指针没有规定其所指对象必须是一个常量"></a>允许一个指向常量的指针指向一个非常量对象，指向常量的指针没有规定其所指对象必须是一个常量</h4></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;		</span><br><span class="line"><span class="type">double</span> *ptr = &amp;pi;			<span class="comment">//错误：ptr是一个普通指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *cptr = &amp;pi;	<span class="comment">//正确：cptr可以指向一个双精度常量</span></span><br><span class="line">*cptr = <span class="number">42</span>;					<span class="comment">//错误：不能给*cptr赋值</span></span><br></pre></td></tr></table></figure>
<p>原因同“对常量的引用”</p>
<p><u><em>ps：所谓指向常量的指针或常量引用，不过是指针或引用“自以为是”罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象的值。</em></u></p>
<h2 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h2><p>引用不是对象，而指针是对象，因此允许把指针本身定义为常量，即常量指针(const pointer)。常量指针必须初始化，而且一旦初始化后，它的值（存放在指针中的地址）就不能再改变了。把*放在const关键字之前，这样书写说明不变的是指针而非指针指向的那个值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span>* <span class="type">const</span> curErr = &amp;errNumb;	<span class="comment">//curErr是一个常量指针</span></span><br><span class="line">	<span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">double</span>* <span class="type">const</span> pip1 = &amp;pi;	<span class="comment">//pip是一个指向常量的常量指针</span></span><br><span class="line">    <span class="type">double</span>* <span class="type">const</span> pip2 = &amp;pi;		<span class="comment">//错误：pip2并不是一个指向常量的指针，不能“const double*”类型的值不能用于初始化“double* const”类型的实体</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指针本身是常量，不代表不能通过指针修改其所指对象的值，能否这样做取决于所指对象的类型，<u>即可以通过常量指针修改非常量对象的值</u>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> k = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p = &amp;i;</span><br><span class="line">*p = j;		<span class="comment">//正确：改变p的值（地址）存放的对象的值，即把i赋值为j，但并没有改变p的值（地址）</span></span><br><span class="line">			<span class="comment">//此操作后i = 0， j = 0， k = 2；</span></span><br><span class="line">p = &amp;k;		<span class="comment">//错误：此操作为把p赋值为k的地址，而p是一个常量指针，其值不可改变</span></span><br></pre></td></tr></table></figure>

<p><em><strong>建议：想要弄清这些声明的含义，最有效的方法是从右向左阅读</strong></em></p>
<p><em>练习2.27</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>  &amp;<span class="type">const</span> r2 = <span class="number">0</span>;	<span class="comment">//错误：引用不是对象，没有常量引用，只有对常量的引用</span></span><br></pre></td></tr></table></figure>

<p>虽然有的编译器会自动忽略掉&amp;后的const，但切记不要这样做。</p>
<p><img src="C:\Users\91590\AppData\Roaming\Typora\typora-user-images\1650683511366.png" alt="1650683511366"></p>
<h2 id="顶层const和底层const"><a href="#顶层const和底层const" class="headerlink" title="顶层const和底层const"></a>顶层const和底层const</h2><p>顶层const(top-level const)：表示指针本身是一个常量</p>
<p>底层const(low-level const)：表示指针所指对象是一个常量</p>
<p>更一般的，顶层const表示任意的对象是常量，底层const表示指针和引用等所指对象和所引用对象是常量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p1 = &amp;i;			<span class="comment">//不能改变p1的值，这是一个顶层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">42</span>;			<span class="comment">//不能改变ci的值，这是一个顶层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p2 = &amp;ci;		<span class="comment">//允许改变p2的值，但不能改变p2所指对象的值，这是一个底层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p3 = p2;	<span class="comment">//靠近p3的const是顶层，远离p3的const是底层</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; r1 = ci;			<span class="comment">//用于声明引用的const都是底层</span></span><br><span class="line"></span><br><span class="line">i = ci;						<span class="comment">//正确：拷贝ci的值，ci是一个顶层const，对此操作无影响</span></span><br><span class="line">p2 = p3;					<span class="comment">//正确：p2和p3所指对象类型相同，即两者都是底层常量，p2不是顶层const，其值可以改变，p3顶层const部分不影响</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p = p3;				<span class="comment">//错误：p3包含底层const对象，即p3所指对象为常量，而p所指对象不是，故不能将p3的值赋予p</span></span><br><span class="line"><span class="type">int</span>* p = &amp; *p3;				<span class="comment">//该操作完全同上，&amp;和*互为逆操作</span></span><br><span class="line">p2 = &amp;i;					<span class="comment">//正确：int*能转换成const int*，即底层非常量可以转换为底层常量</span></span><br><span class="line"><span class="type">int</span>&amp; r2 = ci;				<span class="comment">//错误：非常量int&amp;不能绑定到int常量上</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; r3 = i;			<span class="comment">//正确：常量int&amp;可以绑定到int非常量上</span></span><br></pre></td></tr></table></figure>

<p>提示：顶层const的对象初始化后不能被赋值，底层const的对象不能改变其所指或所引用对象的值，非底层const的对象不能拷贝底层const的对象。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++笔记（三）——处理类型</title>
    <url>/2022/04/23/cpp/cpp-note-3/</url>
    <content><![CDATA[<h1 id="常量表达式和constexpr"><a href="#常量表达式和constexpr" class="headerlink" title="常量表达式和constexpr"></a>常量表达式和constexpr</h1><h2 id="常量表达式-const-expression"><a href="#常量表达式-const-expression" class="headerlink" title="常量表达式(const expression)"></a>常量表达式(const expression)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> max_files = <span class="number">20</span>;			<span class="comment">//max_files是常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> limit = max_filse + <span class="number">1</span>;	<span class="comment">//limit是常量表达式</span></span><br><span class="line"><span class="type">int</span> staff_size = <span class="number">27</span>;				<span class="comment">//staff_size不是常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> sz = <span class="built_in">get_size</span>();			<span class="comment">//sz不是常量表达式，其具体值在程序运行时才能获得，而不是编译时获得</span></span><br></pre></td></tr></table></figure>

<p>在复杂系统中，无法分辨一个初始值到底是不是常量表达式。这种情况下，对象的定义和使用根本就是两回事儿。</p>
<h2 id="constexpr变量"><a href="#constexpr变量" class="headerlink" title="constexpr变量"></a>constexpr变量</h2><p>C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mf = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> limit = mf + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> sz = <span class="built_in">size</span>();		<span class="comment">//只有当size是一个constexpr函数时，这才是一条正确语句</span></span><br></pre></td></tr></table></figure>

<p>同时C++11新标准也允许定义一种constexpr函数，这种函数必须简单到在编译时就可以计算其结果，这样就能用constexpr函数去初始化constexpr变量。</p>
<p>在声明constexpr时，用到的类型只能是字面值类型</p>
<h2 id="字面值类型-literal-type"><a href="#字面值类型-literal-type" class="headerlink" title="字面值类型(literal type)"></a>字面值类型(literal type)</h2><p>目前接触过的数据类型中，算术类型、引用和指针都属于字面值类型，但被定义成constexpr的指针初值必须输nullptr或者0，或者存储于某个固定地址中的对象。</p>
<p>函数体内定义的变量一般并非存放在固定地址中，所有函数体之外的对象其地址固定不变。函数体内允许定义一类有效范围超出函数本身的变量，该变量夜游固定地址。</p>
<h2 id="constexpr指针"><a href="#constexpr指针" class="headerlink" title="constexpr指针"></a>constexpr指针</h2><p>constexpr声明中定义了一个指针，限定符constexpr只对指针有效：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* p = <span class="literal">nullptr</span>;			<span class="comment">//p是一个指向整型常量的指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span>* q = <span class="literal">nullptr</span>;		<span class="comment">//q是一个指向整数的常量指针</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h1><h2 id="类型别名-type-alias"><a href="#类型别名-type-alias" class="headerlink" title="类型别名(type alias)"></a>类型别名(type alias)</h2><p>传统定义方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages;			<span class="comment">//wages是double的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wages base, * p;		<span class="comment">//base是double的同义词，p是double*的同义词</span></span><br></pre></td></tr></table></figure>

<p>C++11新标准定义方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> SI = Sales_item;			<span class="comment">//SI是Sales_item的同义词</span></span><br></pre></td></tr></table></figure>

<p>类型别名引入的易错点，从右向左读可以轻松理解以下语句</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> * pstring;			<span class="comment">//pstring是char*的同义词，此时pstring的基本数据类型是指针</span></span><br><span class="line"><span class="type">const</span> pstring cstr = <span class="number">0</span>;			<span class="comment">//const限定了pstring，即基本数据类型是const pstring，指向char的常量指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * cstr = <span class="number">0</span>;			<span class="comment">//const限定了char，即基本数据类型是const char，指向char常量的指针</span></span><br><span class="line"><span class="type">const</span> pstring * ps;				<span class="comment">//ps是一个指针，其所指对象是一个指向char的常量指针</span></span><br></pre></td></tr></table></figure>

<h2 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h2><p>编程时常常需要把表达式的值赋给变量，这就要求声明变量时清楚地知道表达式的类型。C++11新标准引入了auto类型说明符，它可以分析表达式所属的类型</p>
<p>auto定义的变量必须有初始值，用以推断该变量的类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> item = val1 + val2;		<span class="comment">//item初始化为val1和val2相加的结果，由该结果可以推断出item的类型</span></span><br></pre></td></tr></table></figure>

<p>auto可以在一条语句中定义多个变量，由于一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>, * p = &amp;i;			<span class="comment">//正确：i是整数、p是整型指针</span></span><br><span class="line"><span class="keyword">auto</span> sz = <span class="number">0</span>, pi = <span class="number">3.14</span>;			<span class="comment">//错误：sz和pi的类型不一致</span></span><br></pre></td></tr></table></figure>

<p>auto一般会忽略顶层const，但保留底层const：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;					<span class="comment">//b是一个普通整数</span></span><br><span class="line"><span class="keyword">auto</span> c = cr;					<span class="comment">//c是一个普通整数（cr只是ci的别名，实际参与初始化的是被引用对象ci）</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i;					<span class="comment">//d是一个普通整型指针</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci;					<span class="comment">//e是一个指向整数常量的指针（对常量对象取地址是一种底层const）</span></span><br></pre></td></tr></table></figure>

<p>如果希望通过auto定义一个顶层const对象，则需要：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> f = ci;</span><br><span class="line"><span class="keyword">auto</span>&amp; r1 = <span class="number">42</span>;					<span class="comment">//错误：不能为非常量引用绑定字面值</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; r2 = <span class="number">42</span>;			<span class="comment">//正确：可以为常量引用绑定字面值</span></span><br></pre></td></tr></table></figure>

<p>当设置一个类型为auto的引用时，顶层常量属性仍然保留，即得到的引用具有底层常量属性：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">1</span>;				<span class="comment">//i具有顶层常量属性</span></span><br><span class="line"><span class="keyword">auto</span>&amp; r = i;					<span class="comment">//r是一个对整数常量的引用，此时r是一个对常量的引用</span></span><br><span class="line">r = <span class="number">100</span>;						<span class="comment">//错误：不可修改对常量的引用所引用的对象</span></span><br></pre></td></tr></table></figure>

<p><em><strong>切记，auto只是推断声明符的类型，而&amp;和*只是声明符的修饰符</strong></em></p>
<p>在声明语句中，*声明一个指针变量，&amp;声明一个对象引用；在定义语句中，*取指针所指向的数据，&amp;取对象的地址。</p>
<h2 id="decltype类型说明符"><a href="#decltype类型说明符" class="headerlink" title="decltype类型说明符"></a>decltype类型说明符</h2><p>C++11新标准引入了decltype，用于从表达式的类型推断出要定义的变量的类型，但是并不用该表达式的值初始化变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) sum = x;			<span class="comment">//sum的类型就是f()的返回类型</span></span><br></pre></td></tr></table></figure>

<p>decltype处理顶层const和引用的方式与auto不同：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">0</span>, &amp; cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>;				<span class="comment">//x的类型是const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x;				<span class="comment">//y的类型是const int&amp;，y绑定到常量x</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z;					<span class="comment">//错误：z是一个引用，必须初始化</span></span><br></pre></td></tr></table></figure>

<p><u>上述例子中，在decltype()中ci和cj不是一个同义词，而在其他任何地方，cj都是ci的同义词</u></p>
<p>几个需要注意的点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>, * p = &amp;i, &amp; r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b;				<span class="comment">//正确：尽管r是一个引用，但加法的结果是int而非一个引用，因此b是一个未初始化的int</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c;					<span class="comment">//错误：表达式内容是解引用操作，则decltype得到引用类型，故c是int&amp;，必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) d;				<span class="comment">//错误：d是int&amp;，必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(i) e;					<span class="comment">//正确：e是一个未初始化的int</span></span><br><span class="line"><span class="keyword">decltype</span>((i + <span class="number">0</span>)) f;			<span class="comment">//正确：f是一个未初始化的int</span></span><br></pre></td></tr></table></figure>

<p>上述例子中，当变量i被加上了一层括号时，编译器会把它当成一个表达式，而变量是一种<u><strong>可以作为赋值语句左值的特殊表达式</strong></u>，所以decltype((i))的结果类型是一个引用类型int&amp;</p>
<p><em>练习2.36</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) c = a;</span><br><span class="line"><span class="keyword">decltype</span>((b)) d = a;			<span class="comment">//d是一个引用，被引用的对象是a</span></span><br><span class="line">++c;</span><br><span class="line">++d;							<span class="comment">//d是a的同义词，实际进行操作时将d替换为a</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，c是int型，d是int&amp;型，最后a、b、c、d四个值都是4</p>
<p><em>练习2.37</em></p>
<p>如果i是int，则表达式i&#x3D;x的类型是int&amp;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) c = a;				<span class="comment">//c是一个整数，初始化为a</span></span><br><span class="line"><span class="keyword">decltype</span>(a = b) d = a;			<span class="comment">//d是一个引用，被引用的对象是a</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++笔记（四）——自定义数据结构</title>
    <url>/2022/04/23/cpp/cpp-note-4/</url>
    <content><![CDATA[<h1 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h1><p>数据结构是把一组相关的数据元素组织起来然后使用它们的策略和方法，如Sales_item类，把书本的ISBN编号、售出量和销售收入等数据组织在了一起，并且提供如isbn函数、&gt;&gt;、&lt;&lt;、+、+&#x3D;等运算在内的一系列操作，Sales_item类就是一个数据结构。</p>
<p>C++允许用户以类的形式自定义数据类型。</p>
<h2 id="定义Sales-data类型"><a href="#定义Sales-data类型" class="headerlink" title="定义Sales_data类型"></a>定义Sales_data类型</h2><p>在第七章之前，都使用struct（结构体）来自定义数据类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;									<span class="comment">//注意：类体右侧的表示结束的花括号后必须写一个分号，因为类体后面可以紧跟变量名以示对该类型对象的定义</span></span><br></pre></td></tr></table></figure>

<p>{}中的三条语句定义了struct的数据成员(data member)，C++11新标准规定，可以为数据成员提供一个类内初始值(in-class initializer)，没有初始值的成员将被默认初始化。</p>
<p><strong>千万牢记，定义数据类型的{}之后一定要有分号，而定义函数的{}之后则不需要分号。</strong></p>
<p>定义该类型的对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span>&#123;<span class="comment">/*...*/</span>&#125; accum, trans, *salesptr;</span><br><span class="line"><span class="comment">//以下两条语句等同于上一条语句，但更易读一些</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span>&#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line">Sales_data accum, trans, *salesptr;</span><br></pre></td></tr></table></figure>

<p><em>补充：cout标准输出(standard output)，cerr标准错误(standard error)，clog用来输出程序运行时的一般性信息。</em></p>
<h2 id="编写自己的头文件"><a href="#编写自己的头文件" class="headerlink" title="编写自己的头文件"></a>编写自己的头文件</h2><p>类一般都不定义在函数体内。为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在的头文件的名字应与类的名字一样。</p>
<p>头文件通常包含哪些只能被定义一次的实体(entity)，如类、const和constexpr变量（定义时添加extern关键字）等。</p>
<p>确保头文件多次包含仍能安全工作的常用技术是<strong>预处理器</strong>(preprocessor)，它由C++语言从C语言里继承而来。#include就是一项预处理功能，当预处理器看到#include标记时就会用指定的头文件内容代替#include。</p>
<p>C++还会用到一项预处理功能是头<strong>文件保护符</strong>(header guard)，依赖于预处理变量。预处理变量有两种状态：已定义和未定义。#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真。</p>
<p>如此可以有效防止重复包含：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SALES_DATA_H				<span class="comment">//变量未定义时检查结果为真，执行后续操作直到#endif为止</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SALES_DATA_H				<span class="comment">//把SALES_DATA_H设定为预处理变量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><u><strong>头文件保护符必须唯一，通常是基于头文件中类的名字来构建保护符的名字。为了避免与程序中的其他实体发生名字冲突，一般吧预处理变量的名字全部大写。</strong></u></p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++笔记（五）——标准库类型string</title>
    <url>/2022/04/27/cpp/cpp-note-5/</url>
    <content><![CDATA[<h1 id="字符串、向量和数组"><a href="#字符串、向量和数组" class="headerlink" title="字符串、向量和数组"></a>字符串、向量和数组</h1><p>命名空间的using声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> namespaece std;				<span class="comment">//using声明，获取std中的所有名字</span></span><br><span class="line"><span class="keyword">using</span> std::cin;						<span class="comment">//using声明，当我们使用名字cin时，从std中获取它</span></span><br></pre></td></tr></table></figure>

<h2 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>					<span class="comment">//一定要包含string头文件</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br></pre></td></tr></table></figure>

<h3 id="定义和初始化string对象"><a href="#定义和初始化string对象" class="headerlink" title="定义和初始化string对象"></a>定义和初始化string对象</h3><p>几个初始化方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s1;							<span class="comment">//默认初始化，s1是一个空串</span></span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(s1)</span></span>;						<span class="comment">//直接初始化(direct initialization)，s2是s1的副本</span></span><br><span class="line">string s2 = s1;						<span class="comment">//拷贝初始化(copy initialization)，s2是s1的副本</span></span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(<span class="string">&quot;value&quot;</span>)</span></span>;					<span class="comment">//直接初始化，s3是字面值&quot;value&quot;的副本，除了字面值最后的那个空字符外</span></span><br><span class="line">string s3 = <span class="string">&quot;value&quot;</span>;				<span class="comment">//拷贝初始化，s3是字面值&quot;value&quot;的副本</span></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(n, <span class="string">&#x27;c&#x27;</span>)</span></span>;					<span class="comment">//直接初始化，s4是由连续n个字符c组成的串</span></span><br><span class="line">string s5 = <span class="built_in">string</span>(<span class="number">10</span>,<span class="string">&#x27;c&#x27;</span>)			<span class="comment">//拷贝初始化，创建了一个临时对象用于拷贝，s5内容是cccccccccc</span></span><br></pre></td></tr></table></figure>

<h3 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作"></a>string对象上的操作</h3><p>读入数量未知的string对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string word;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; word)				<span class="comment">//反复读取，直到输入文件结束标记</span></span><br><span class="line">        cout &lt;&lt; word &lt;&lt; endl;		<span class="comment">//逐个输出单词，每个单词之间有一个换行符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取整行：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(cin, line))		<span class="comment">//如果输入换行符，会直接结束读取，并返回结果（结果为空string）</span></span><br><span class="line">        cout &lt;&lt; line &lt;&lt; endl;		<span class="comment">//触发getline的换行符被丢弃掉了，所以手动加上换行符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>empty根据string是否为空返回一个布尔值，可以用来筛除空string：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string line;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(cin,line))</span><br><span class="line">		<span class="keyword">if</span>(!line.<span class="built_in">empty</span>())			<span class="comment">//只有当line是非空string时，才会执行输出</span></span><br><span class="line">			cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>size返回一个size_type类型的值，表示string对象的大小，它是一个无符号的值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> len = line.<span class="built_in">size</span>();				<span class="comment">//len的类型是string::size_type</span></span><br></pre></td></tr></table></figure>

<p><em><strong>切记，表达式中混用带符号数和无符号数时，带符号数会自动转换成无符号数，负值会转换成（负值+无符号数的模）</strong></em> <em>（int是有符号数）</em></p>
<p>字面值和string对象相加：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//必须确保+两侧的对象至少有一个是string</span></span><br><span class="line">string s1 = <span class="string">&quot;hello&quot;</span>, s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">string s3 = s1 + <span class="string">&quot;, &quot;</span> + s2 + <span class="string">&#x27;\n&#x27;</span>;	<span class="comment">//正确</span></span><br><span class="line">string s4 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;, &quot;</span> + s2;	<span class="comment">//错误：不能把字面值直接相加</span></span><br><span class="line">string s4 = (<span class="string">&quot;hello&quot;</span> + <span class="string">&quot;, &quot;</span>) + s2;	<span class="comment">//按照加法运算符的工作机理，上一条语句与这条语句等价</span></span><br><span class="line">string s5 = s1 + <span class="string">&quot;, &quot;</span> + <span class="string">&quot;world&quot;</span>;	<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<p><em>由于历史原因，也为了与C兼容，C++中字符串字面值并不是string对象，它们是不同的类型</em></p>
<hr>
<p><em>练习3.5</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string total, s_in;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; s_in) &#123;</span><br><span class="line">		total = total + <span class="string">&quot; &quot;</span> + s_in;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="处理string对象中的字符"><a href="#处理string对象中的字符" class="headerlink" title="处理string对象中的字符"></a>处理string对象中的字符</h3><p>C++11新标准：范围for语句(range for)：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : <span class="string">&quot;some string&quot;</span>)		<span class="comment">//每次迭代，都把&quot;&quot;中的下一个字符拷贝给c</span></span><br><span class="line">	cout &lt;&lt; c &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>统计string中的标点符号数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello World!!!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(s.<span class="built_in">size</span>()) punct_cnt = <span class="number">0</span>;	<span class="comment">//定义punct_cnt为size_type类型</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : s)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ispunct</span>(c))					<span class="comment">//ispunct()函数在&lt;cctype&gt;中，&lt;string&gt;已经包含了&lt;cctype&gt;</span></span><br><span class="line">        ++punct_cnt;</span><br><span class="line">cout &lt;&lt; punct_cnt &lt;&lt; <span class="string">&quot; punctuation characters in &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>改变string中字符的值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello World!!!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : s)					<span class="comment">//c是对s中某个字符的引用</span></span><br><span class="line">    c = <span class="built_in">toupper</span>(c);					<span class="comment">//通过c来将s中的字符改为大写，toupper()是&lt;ctype.h&gt;中函数，&lt;cctype&gt;中已经包含了&lt;ctype.h&gt;</span></span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>利用下标运算符处理string的部分字符：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;some string&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!s1.<span class="built_in">empty</span>())&#123;					<span class="comment">//下标取值范围是[0, s1.size()-1]，超出此范围会读出未知结果</span></span><br><span class="line">    s1[<span class="number">0</span>] = <span class="built_in">toupper</span>(s1[<span class="number">0</span>]);			<span class="comment">//将s1的第一个字符赋值为大写</span></span><br><span class="line">    cout &lt;&lt; s1[<span class="number">0</span>] &lt;&lt; endl;			<span class="comment">//输出s1的第一个字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种处理部分字符的方式是使用迭代器，暂不介绍。</p>
<p>使用下标执行迭代：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello World&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(s.<span class="built_in">size</span>()) index = <span class="number">0</span>; index != s.<span class="built_in">size</span>() &amp;&amp; !<span class="built_in">isspace</span>(s[index]); ++index)</span><br><span class="line">    s[index] = <span class="built_in">toupper</span>(s[index]);</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;					<span class="comment">//输出结果为HELLO World</span></span><br></pre></td></tr></table></figure>

<p>注意，C++中<code>&amp;&amp;</code> 运算符只有在左侧运算对象为真时，才会检查右侧的运算对象，上述写法中保证了下标取值合理时才访问<code>s[index]</code>。</p>
<p>使用下标执行随机访问：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> string hexdigits = <span class="string">&quot;0123456789ABCDEF&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Enter a series of numbers between 0 and 15&quot;</span> &lt;&lt; endl;</span><br><span class="line">string result;						<span class="comment">//初始化为空string</span></span><br><span class="line">string::size_type n;				<span class="comment">//定义n为size_type类型，但注意此处并没有初始化</span></span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; n)</span><br><span class="line">    <span class="keyword">if</span> (n &lt; hexdigits.<span class="built_in">size</span>())</span><br><span class="line">        result += hexdigits[n];		<span class="comment">//根据输入来拼接result</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Your hex number is: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p><em>练习3.6</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>					<span class="comment">//&lt;string&gt;里面已经包含了&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string str;</span><br><span class="line">	cin &gt;&gt; str;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : str)</span><br><span class="line">		c = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; str;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>练习3.9</em></p>
<p>不合法，s为空字符串，第一个元素是未知的，虽然vs2022中会输出一个空字符，但是不同机器上得到的结果可能会不同。</p>
<p><em>练习3.10</em></p>
<p>但是好像并不能识别中文的标点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string str, result;</span><br><span class="line">	cin &gt;&gt; str;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> c : str)</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">ispunct</span>(c))</span><br><span class="line">			result += c;</span><br><span class="line">	cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>练习3.11</em></p>
<p><code>c</code>是<code>const char&amp;</code>类型的值，<code>for</code>语句块中不给c赋值的话就合法，否则不合法。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++笔记（六）——标准库类型vector</title>
    <url>/2022/04/29/cpp/cpp-note-6/</url>
    <content><![CDATA[<h2 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h2><p>vector表示对象的集合，其中所有的对象类型都相同。集合中每个对象都有一个与之对应的索引，索引用于访问对象。因为vector“容纳着”其他对象，所以它也被称为**容器(container)**。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>					<span class="comment">//一定要包含vector头文件</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br></pre></td></tr></table></figure>

<p>C++语音既有类模板(class template)，也有函数模板，其中<code>vector</code>是一个类模板。模板本身不是类或函数，可以将模板看做编译器生成类或函数编写的一份说明。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vector是模板而非类型，由vector生成的类型必须包含vector中元素的类型</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;					<span class="comment">//ivec保存int类型对象</span></span><br><span class="line">vector&lt;Sales_item&gt; Sales_vec;		<span class="comment">//保存Sales_item类型对象</span></span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; file;		<span class="comment">//该向量的元素是vector对象，该语句为C++11的定义形式</span></span><br><span class="line">vector&lt;vector&lt;string&gt; &gt; file;		<span class="comment">//老式定义形式，多一个空格，即vector&lt;vector&lt;string&gt;(空格)&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="定义和初始化vector对象"><a href="#定义和初始化vector对象" class="headerlink" title="定义和初始化vector对象"></a>定义和初始化vector对象</h3>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网Verilog刷题笔记2</title>
    <url>/2022/04/29/nowcoder/nowcoder2-verilog17/</url>
    <content><![CDATA[<h3 id="VL17-任意小数分频"><a href="#VL17-任意小数分频" class="headerlink" title="VL17 任意小数分频"></a>VL17 任意小数分频</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> div_M_N(</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span> clk_in,</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span> rst,</span><br><span class="line">	<span class="keyword">output</span>	<span class="keyword">reg</span> clk_out</span><br><span class="line">);</span><br><span class="line"><span class="keyword">parameter</span> M_N = <span class="number">8&#x27;d87</span>; </span><br><span class="line"><span class="keyword">parameter</span> c89 = <span class="number">8&#x27;d24</span>; <span class="comment">// 8/9时钟切换点</span></span><br><span class="line"><span class="keyword">parameter</span> div_e = <span class="number">5&#x27;d8</span>; <span class="comment">//偶数周期</span></span><br><span class="line"><span class="keyword">parameter</span> div_o = <span class="number">5&#x27;d9</span>; <span class="comment">//奇数周期</span></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="comment">//考虑10个clk_out时钟周期是1个clk_in时钟周期的87倍</span></span><br><span class="line">	<span class="comment">//counter</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">6</span>:<span class="number">0</span>] cnt;		<span class="comment">//总计数器</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~rst)</span><br><span class="line">			cnt &lt;= <span class="number">6&#x27;d0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(cnt == (M_N - <span class="number">1&#x27;b1</span>))</span><br><span class="line">			cnt &lt;= <span class="number">6&#x27;d0</span>;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">reg</span> state;			<span class="comment">//state为0时8分频，为1时9分频</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~rst)</span><br><span class="line">			state &lt;= <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>((cnt == (c89 - <span class="number">1&#x27;b1</span>)) | (cnt == (M_N - <span class="number">1&#x27;b1</span>)))</span><br><span class="line">			state &lt;= ~state;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_d;	<span class="comment">//分频计数器</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~rst)</span><br><span class="line">			cnt_d &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(state == <span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">			<span class="keyword">if</span>(cnt_d == div_e - <span class="number">1&#x27;b1</span>)</span><br><span class="line">				cnt_d &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				cnt_d &lt;= cnt_d + <span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(state == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt_d == div_o - <span class="number">1&#x27;b1</span>)</span><br><span class="line">				cnt_d &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				cnt_d &lt;= cnt_d + <span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">//div</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~rst)</span><br><span class="line">			clk_out &lt;= <span class="number">1&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">case</span>(state)</span><br><span class="line">			<span class="number">1&#x27;b0</span>: <span class="keyword">begin</span></span><br><span class="line">				<span class="keyword">if</span>((cnt_d == div_e/<span class="number">2</span>) | (cnt_d == <span class="number">4&#x27;d0</span>)) </span><br><span class="line">					clk_out &lt;= ~clk_out;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">1&#x27;b1</span>: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>((cnt_d == (div_o - <span class="number">1&#x27;b1</span>)/<span class="number">2</span>) | (cnt_d == <span class="number">4&#x27;d0</span>)) </span><br><span class="line">                    clk_out &lt;= ~clk_out;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL18-无占空比要去的奇数分频"><a href="#VL18-无占空比要去的奇数分频" class="headerlink" title="VL18 无占空比要去的奇数分频"></a>VL18 无占空比要去的奇数分频</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> odd_div (    </span><br><span class="line">    <span class="keyword">input</span>     <span class="keyword">wire</span> rst ,</span><br><span class="line">    <span class="keyword">input</span>     <span class="keyword">wire</span> clk_in,</span><br><span class="line">    <span class="keyword">output</span>    <span class="keyword">wire</span> clk_out5</span><br><span class="line">);</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">    <span class="keyword">localparam</span> N = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">localparam</span> SIZE = <span class="number">2</span>;</span><br><span class="line">	<span class="comment">//counter</span></span><br><span class="line">    <span class="keyword">reg</span> [SIZE:<span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst)</span><br><span class="line">            cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt == N - <span class="number">1</span>)</span><br><span class="line">            cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//div</span></span><br><span class="line">    <span class="keyword">reg</span> clk_out;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst)</span><br><span class="line">            clk_out &lt;= <span class="number">1&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((cnt == (N - <span class="number">1</span>)/<span class="number">2</span>) | (cnt == <span class="number">0</span>))</span><br><span class="line">            clk_out &lt;= ~clk_out;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">assign</span> clk_out5 = clk_out;</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL19-根据状态转移写状态机-三段式"><a href="#VL19-根据状态转移写状态机-三段式" class="headerlink" title="VL19 根据状态转移写状态机-三段式"></a>VL19 根据状态转移写状态机-三段式</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> fsm1(</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> clk  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> rst  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> data ,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> flag</span><br><span class="line">);</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">    <span class="comment">//set state</span></span><br><span class="line">    <span class="keyword">localparam</span> S0 = <span class="number">0</span>, S1 = <span class="number">1</span>, S2 = <span class="number">2</span>, S3 = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] state, next;</span><br><span class="line">    <span class="comment">//state transition</span></span><br><span class="line">    <span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(state)</span><br><span class="line">            S0: next = data ? S1 : S0;</span><br><span class="line">            S1: next = data ? S2 : S1;</span><br><span class="line">            S2: next = data ? S3 : S2;</span><br><span class="line">            S3: next = data ? S0 : S3;</span><br><span class="line">            <span class="keyword">default</span>: next = S0;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//state flip-flops</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst)</span><br><span class="line">            state &lt;= S0;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            state &lt;= next;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output  三段式输出用时序逻辑  可以防止出现毛刺</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst)</span><br><span class="line">            flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">case</span>(state)</span><br><span class="line">            S3: flag &lt;= data;</span><br><span class="line">            <span class="keyword">default</span>: flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL20-根据状态转移写状态机-二段式"><a href="#VL20-根据状态转移写状态机-二段式" class="headerlink" title="VL20 根据状态转移写状态机-二段式"></a>VL20 根据状态转移写状态机-二段式</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> fsm2(</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> clk  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> rst  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> data ,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> flag</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">    <span class="comment">//set state</span></span><br><span class="line">    <span class="keyword">localparam</span> S0 = <span class="number">0</span>, S1 = <span class="number">1</span>, S2 = <span class="number">2</span>, S3 = <span class="number">3</span>, S4 = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] state, next;</span><br><span class="line">    <span class="comment">//state transition</span></span><br><span class="line">    <span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(state)</span><br><span class="line">            S0: next = data ? S1 : S0;</span><br><span class="line">            S1: next = data ? S2 : S1;</span><br><span class="line">            S2: next = data ? S3 : S2;</span><br><span class="line">            S3: next = data ? S4 : S3;</span><br><span class="line">            S4: next = S0;</span><br><span class="line">            <span class="keyword">default</span>: next = S0;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//state flip-flops</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst)</span><br><span class="line">            state &lt;= S0;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            state &lt;= next;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output  二段式输出用组合逻辑</span></span><br><span class="line">    <span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">        flag = (state == S4);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL21-异步FIFO-（重点！！！）"><a href="#VL21-异步FIFO-（重点！！！）" class="headerlink" title="VL21 异步FIFO （重点！！！）"></a>VL21 异步FIFO （重点！！！）</h3><p> FIFO指First Input First Output，即先进先出。FIFO存储器一般作为系统的缓冲环节，作用</p>
<ol>
<li>对连续的数据流进行缓存，防止在进机和存储操作时丢失数据；</li>
<li>数据集中起来进行进栈和存储，可避免频繁的总线操作，减轻CPU的负担；</li>
<li>允许系统进行DMA操作，提高数据的传输速度。这是至关重要的一点，如果不采用DMA操作，数据传输将达不到传输要求，而且大大增加CPU的负担，无法同时完成数据的存储工作。</li>
</ol>
<details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************RAM*****************************************/</span></span><br><span class="line"><span class="comment">// #()中定义的是 “可以提供给外部调用” 的常数参数</span></span><br><span class="line"><span class="keyword">module</span> dual_port_RAM #(<span class="keyword">parameter</span> DEPTH = <span class="number">16</span>, <span class="keyword">parameter</span> WIDTH = <span class="number">8</span>)(</span><br><span class="line">	<span class="keyword">input</span> wclk,</span><br><span class="line">	<span class="keyword">input</span> wenc,</span><br><span class="line">    <span class="keyword">input</span> [<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>] waddr,	<span class="comment">//$clog2()是对2取对数函数，深度对2取对数，得到地址的位宽</span></span><br><span class="line">    <span class="keyword">input</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] wdata,			<span class="comment">//数据写入</span></span><br><span class="line">	<span class="keyword">input</span> rclk,</span><br><span class="line">	<span class="keyword">input</span> renc,</span><br><span class="line">	<span class="keyword">input</span> [<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>] raddr,	<span class="comment">//深度对2取对数，得到地址的位宽</span></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] rdata		<span class="comment">//数据输出</span></span><br><span class="line">);</span><br><span class="line">	<span class="keyword">reg</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] RAM_MEM [<span class="number">0</span>:DEPTH-<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> wclk) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(wenc)</span><br><span class="line">			RAM_MEM[waddr] &lt;= wdata;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> rclk) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(renc)</span><br><span class="line">			rdata &lt;= RAM_MEM[raddr];</span><br><span class="line">	<span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endmodule</span>  </span><br><span class="line"><span class="comment">/***************************************AFIFO*****************************************/</span></span><br><span class="line"><span class="keyword">module</span> asyn_fifo#(</span><br><span class="line">	<span class="keyword">parameter</span>	WIDTH = <span class="number">8</span>,</span><br><span class="line">	<span class="keyword">parameter</span> 	DEPTH = <span class="number">16</span></span><br><span class="line">)(</span><br><span class="line">	<span class="keyword">input</span> 					wclk	, </span><br><span class="line">	<span class="keyword">input</span> 					rclk	,   </span><br><span class="line">	<span class="keyword">input</span> 					wrstn	,</span><br><span class="line">	<span class="keyword">input</span>					rrstn	,</span><br><span class="line">	<span class="keyword">input</span> 					winc	,</span><br><span class="line">	<span class="keyword">input</span> 			 		rinc	,</span><br><span class="line">	<span class="keyword">input</span> 		[WIDTH-<span class="number">1</span>:<span class="number">0</span>]	wdata	,</span><br><span class="line"></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span>				wfull	,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span>				rempty	,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>]	rdata</span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL22-同步FIFO"><a href="#VL22-同步FIFO" class="headerlink" title="VL22 同步FIFO"></a>VL22 同步FIFO</h3><div class="tabs" id="tab-vl22"><ul class="nav-tabs"><li class="tab"><a href="#tab-vl22-1">单纯做题</a></li><li class="tab"><a href="#tab-vl22-2">实现功能</a></li><li class="tab"><a href="#tab-vl22-3">折叠表格</a></li></ul><div class="tab-content"><div class="tab-pane" id="tab-vl22-1"><p>虽然通过了，但我的代码实际上是有问题的，答案给的波形也是有点问题的，<a href="https://blog.nowcoder.net/n/d5411484475d4c5c84ce711a6d668f7d">参考</a>。在quartus上跑了一下，完全不能实现功能，这居然能通过，只能说牛客网这道题的testbench不是很理想。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="comment">/**********************************RAM************************************/</span></span><br><span class="line"><span class="keyword">module</span> dual_port_RAM #(<span class="keyword">parameter</span> DEPTH = <span class="number">16</span>,</span><br><span class="line">					   <span class="keyword">parameter</span> WIDTH = <span class="number">8</span>)(</span><br><span class="line">	 <span class="keyword">input</span> wclk</span><br><span class="line">	,<span class="keyword">input</span> wenc</span><br><span class="line">	,<span class="keyword">input</span> [<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>] waddr  <span class="comment">//深度对2取对数，得到地址的位宽。</span></span><br><span class="line">	,<span class="keyword">input</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] wdata      	<span class="comment">//数据写入</span></span><br><span class="line">	,<span class="keyword">input</span> rclk</span><br><span class="line">	,<span class="keyword">input</span> renc</span><br><span class="line">	,<span class="keyword">input</span> [<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>] raddr  <span class="comment">//深度对2取对数，得到地址的位宽。</span></span><br><span class="line">	,<span class="keyword">output</span> <span class="keyword">reg</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] rdata 		<span class="comment">//数据输出</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">reg</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] RAM_MEM [<span class="number">0</span>:DEPTH-<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> wclk) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(wenc)</span><br><span class="line">		RAM_MEM[waddr] &lt;= wdata;</span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line">    </span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> rclk) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(renc)</span><br><span class="line">		rdata &lt;= RAM_MEM[raddr];</span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endmodule</span>  </span><br><span class="line"><span class="comment">/**********************************SFIFO************************************/</span></span><br><span class="line"><span class="keyword">module</span> sfifo#(</span><br><span class="line">	<span class="keyword">parameter</span>	WIDTH = <span class="number">8</span>,</span><br><span class="line">	<span class="keyword">parameter</span> 	DEPTH = <span class="number">16</span></span><br><span class="line">)(</span><br><span class="line">	<span class="keyword">input</span> 					clk		, </span><br><span class="line">	<span class="keyword">input</span> 					rst_n	,</span><br><span class="line">	<span class="keyword">input</span> 					winc	,</span><br><span class="line">	<span class="keyword">input</span> 			 		rinc	,</span><br><span class="line">	<span class="keyword">input</span> 		[WIDTH-<span class="number">1</span>:<span class="number">0</span>]	wdata	,</span><br><span class="line"></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span>				wfull	,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span>				rempty	,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>]	rdata</span><br><span class="line">);</span><br><span class="line">    <span class="comment">//set enable signal</span></span><br><span class="line">    <span class="keyword">wire</span> wenc, renc;</span><br><span class="line">    <span class="keyword">assign</span> wenc = winc &amp; ~wfull;</span><br><span class="line">    <span class="keyword">assign</span> renc = rinc &amp; ~rempty;</span><br><span class="line">    <span class="comment">//RAM</span></span><br><span class="line">    dual_port_RAM  RAM1(</span><br><span class="line">        <span class="variable">.wclk</span>(clk),</span><br><span class="line">        <span class="variable">.wenc</span>(wenc),</span><br><span class="line">        <span class="variable">.waddr</span>(waddr[<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>]),			<span class="comment">//深度对2取对数，得到地址的位宽。</span></span><br><span class="line">        <span class="variable">.wdata</span>(wdata),		<span class="comment">//数据写入</span></span><br><span class="line">        <span class="variable">.rclk</span>(clk),</span><br><span class="line">        <span class="variable">.renc</span>(renc),</span><br><span class="line">        <span class="variable">.raddr</span>(raddr[<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>]),			<span class="comment">//深度对2取对数，得到地址的位宽。</span></span><br><span class="line">        <span class="variable">.rdata</span>(rdata)		<span class="comment">//数据输出</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//address</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="built_in">$clog2</span>(DEPTH):<span class="number">0</span>] waddr, raddr;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span>		<span class="comment">//waddr，when wfull == 1, keep waddr</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            waddr &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(winc) <span class="keyword">begin</span>							<span class="comment">//这部分可以简化，改成以下代码</span></span><br><span class="line">            <span class="keyword">if</span>((waddr[<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>] == raddr[<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>]) &amp; (waddr[<span class="built_in">$clog2</span>(DEPTH)] != raddr[<span class="built_in">$clog2</span>(DEPTH)]))</span><br><span class="line">                waddr &lt;= waddr;						<span class="comment">//else if(wenc)</span></span><br><span class="line">            <span class="keyword">else</span>									<span class="comment">//    waddr &lt;= waddr + 1&#x27;b1;</span></span><br><span class="line">                waddr &lt;= waddr + <span class="number">1&#x27;b1</span>;				<span class="comment">// </span></span><br><span class="line">        <span class="keyword">end</span>											<span class="comment">//</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span>		<span class="comment">//raddr，when rempty == 1, keep raddr</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            raddr &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rinc) <span class="keyword">begin</span>							<span class="comment">//同理可简化为以下</span></span><br><span class="line">            <span class="keyword">if</span>((waddr[<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>] == raddr[<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>]) &amp; (waddr[<span class="built_in">$clog2</span>(DEPTH)] == raddr[<span class="built_in">$clog2</span>(DEPTH)]))</span><br><span class="line">                raddr &lt;= raddr;						<span class="comment">//else if(renc)</span></span><br><span class="line">            <span class="keyword">else</span>									<span class="comment">//    raddr &lt;= raddr + 1&#x27;b1;</span></span><br><span class="line">                raddr &lt;= raddr + <span class="number">1&#x27;b1</span>;				<span class="comment">//</span></span><br><span class="line">        <span class="keyword">end</span>											<span class="comment">//</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//flag output</span></span><br><span class="line">    <span class="comment">//当读地址和写地址[$clog2(DEPTH)-1:0]位相同时，且最高位不同时，表明写地址超了读地址一圈，即写满了</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            wfull &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((waddr[<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>] == raddr[<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>]) &amp; (waddr[<span class="built_in">$clog2</span>(DEPTH)] != raddr[<span class="built_in">$clog2</span>(DEPTH)]))</span><br><span class="line">            wfull &lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            wfull &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//当读地址和写地址[$clog2(DEPTH)-1:0]位相同时，且最高位相同时，表明写地址与读地址相同，即读空了</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            rempty &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((waddr[<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>] == raddr[<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>]) &amp; (waddr[<span class="built_in">$clog2</span>(DEPTH)] == raddr[<span class="built_in">$clog2</span>(DEPTH)]))</span><br><span class="line">            rempty &lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rempty &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p><img src="/1651296351961.png" alt="1651296351961"></p></div><div class="tab-pane" id="tab-vl22-2"><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-vl22-3"></div></div></div>



<details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

</details>]]></content>
      <tags>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网Verilog刷题笔记1</title>
    <url>/2022/04/26/nowcoder/nowcoder1-verilog24/</url>
    <content><![CDATA[<h3 id="VL24-边沿检测"><a href="#VL24-边沿检测" class="headerlink" title="VL24 边沿检测"></a>VL24 边沿检测</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> edge_detect(</span><br><span class="line">	<span class="keyword">input</span> clk,</span><br><span class="line">	<span class="keyword">input</span> rst_n,</span><br><span class="line">	<span class="keyword">input</span> a,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> rise,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> down</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">reg</span> past;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            past &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            past &lt;= a;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            rise &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            down &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            rise &lt;= ((~past &amp; a) === <span class="number">1&#x27;b1</span>)? <span class="number">1</span> : <span class="number">0</span>;		<span class="comment">//使用全等于，避免未知态带来的影响</span></span><br><span class="line">            down &lt;= ((past &amp; ~a) === <span class="number">1&#x27;b1</span>)? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h2 id="进阶挑战"><a href="#进阶挑战" class="headerlink" title="进阶挑战"></a>进阶挑战</h2><h3 id="VL2-含有无关项的序列检测"><a href="#VL2-含有无关项的序列检测" class="headerlink" title="VL2 含有无关项的序列检测"></a>VL2 含有无关项的序列检测</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> sequence_detect(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> rst_n,</span><br><span class="line">    <span class="keyword">input</span> a,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> match</span><br><span class="line">    );</span><br><span class="line">	<span class="comment">//因为存在三位无关项，用状态机需要用到太多状态了，实现起来较为困难</span></span><br><span class="line">	<span class="comment">//故使用9位移位寄存器实现</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">8</span>:<span class="number">0</span>] data;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (~rst_n)</span><br><span class="line">            data &lt;= <span class="number">9&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            data &lt;=&#123;data[<span class="number">7</span>:<span class="number">0</span>], a&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (~rst_n)</span><br><span class="line">            match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((data[<span class="number">8</span>:<span class="number">6</span>]==<span class="number">3&#x27;b011</span>)&amp;(data[<span class="number">2</span>:<span class="number">0</span>]==<span class="number">3&#x27;b110</span>))	<span class="comment">//中间三项为无关项</span></span><br><span class="line">            match &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL3-不重叠序列检测"><a href="#VL3-不重叠序列检测" class="headerlink" title="VL3 不重叠序列检测"></a>VL3 不重叠序列检测</h3><h4 id="移位寄存器方法"><a href="#移位寄存器方法" class="headerlink" title="移位寄存器方法"></a>移位寄存器方法</h4><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> sequence_detect(</span><br><span class="line">	<span class="keyword">input</span> clk,</span><br><span class="line">	<span class="keyword">input</span> rst_n,</span><br><span class="line">	<span class="keyword">input</span> data,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> match,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> not_match</span><br><span class="line">	);</span><br><span class="line">    <span class="comment">//counter</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            cnt &lt;= <span class="number">3&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">3&#x27;d6</span>)</span><br><span class="line">            cnt &lt;= <span class="number">3&#x27;d1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//shifting register</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">5</span>:<span class="number">0</span>] data_in;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_in &lt;= <span class="number">6&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            data_in &lt;= &#123;data_in[<span class="number">4</span>:<span class="number">0</span>], data&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">3&#x27;d6</span>)</span><br><span class="line">            <span class="keyword">case</span>(data_in)</span><br><span class="line">                <span class="number">6&#x27;b011100</span>: <span class="keyword">begin</span></span><br><span class="line">                    match &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                    not_match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                    match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    not_match &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            not_match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h4 id="状态机方法"><a href="#状态机方法" class="headerlink" title="状态机方法"></a>状态机方法</h4><details class="note info no-icon"><summary><p>code</p>
</summary>
<p>用状态机方法还是会用到计数器，个人感觉移位寄存器方法要更简单一点，以下是状态机方法：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> sequence_detect(</span><br><span class="line">	<span class="keyword">input</span> clk,</span><br><span class="line">	<span class="keyword">input</span> rst_n,</span><br><span class="line">	<span class="keyword">input</span> data,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> match,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> not_match</span><br><span class="line">	);</span><br><span class="line">    <span class="comment">//state machine</span></span><br><span class="line">    <span class="comment">//counter</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            cnt &lt;= <span class="number">3&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">3&#x27;d6</span>)</span><br><span class="line">            cnt &lt;= <span class="number">3&#x27;d1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//set state</span></span><br><span class="line">    <span class="keyword">localparam</span> IDLE = <span class="number">0</span>, S0 = <span class="number">1</span>, S01 = <span class="number">2</span>, S011 = <span class="number">3</span>, S0111 = <span class="number">4</span>, S01110 = <span class="number">5</span>, S011100 = <span class="number">6</span>, SErro = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] state , next;</span><br><span class="line">    <span class="comment">//state transition</span></span><br><span class="line">    <span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(state)</span><br><span class="line">            IDLE   : next = data ? SErro : S0;</span><br><span class="line">            SErro  : <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(cnt == <span class="number">3&#x27;d6</span>) </span><br><span class="line">                    next = data ? SErro : S0;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    next = SErro;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S0     : next = data ? S01  : SErro;</span><br><span class="line">            S01    : next = data ? S011 : SErro;</span><br><span class="line">            S011   : next = data ? S0111: SErro;</span><br><span class="line">            S0111  : next = data ? SErro: S01110;</span><br><span class="line">            S01110 : next = data ? SErro: S011100;</span><br><span class="line">            S011100: next = data ? SErro: S0;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//state flip-flops</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            state &lt;= IDLE;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            state &lt;= next;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            not_match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(state == S011100) <span class="keyword">begin</span></span><br><span class="line">            match &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            not_match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((state == SErro)&amp;(cnt == <span class="number">3&#x27;d6</span>)) <span class="keyword">begin</span></span><br><span class="line">            match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            not_match &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            not_match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL4-输入序列不连续的序列检测"><a href="#VL4-输入序列不连续的序列检测" class="headerlink" title="VL4 输入序列不连续的序列检测"></a>VL4 输入序列不连续的序列检测</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> sequence_detect(</span><br><span class="line">	<span class="keyword">input</span> clk,</span><br><span class="line">	<span class="keyword">input</span> rst_n,</span><br><span class="line">	<span class="keyword">input</span> data,</span><br><span class="line">	<span class="keyword">input</span> data_valid,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> match</span><br><span class="line">	);</span><br><span class="line">    <span class="comment">//state machine</span></span><br><span class="line">    <span class="comment">//set state</span></span><br><span class="line">    <span class="keyword">localparam</span> IDLE = <span class="number">0</span>, S0 = <span class="number">1</span>, S01 = <span class="number">2</span>, S011 = <span class="number">3</span>, S0110 = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] state, next;</span><br><span class="line">    <span class="comment">//state transition</span></span><br><span class="line">    <span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(state)</span><br><span class="line">            IDLE: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(data_valid)</span><br><span class="line">                    next = data ? IDLE : S0;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    next = IDLE;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S0: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(data_valid)</span><br><span class="line">                    next = data ? S01 : S0;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    next = IDLE;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S01: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(data_valid)</span><br><span class="line">                    next = data ? S011 : S0;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    next = IDLE;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S011: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(data_valid)</span><br><span class="line">                    next = data ? IDLE : S0110;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    next = IDLE;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S0110: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(data_valid)</span><br><span class="line">                    next = data ? S01 : S0;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    next = IDLE;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//state flip-flops</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            state &lt;= IDLE;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            state &lt;= next;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">case</span>(next)</span><br><span class="line">            S0110: match &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">default</span>: match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL5-信号发生器-（这道题蛮难的）"><a href="#VL5-信号发生器-（这道题蛮难的）" class="headerlink" title="VL5 信号发生器 （这道题蛮难的）"></a>VL5 信号发生器 （这道题蛮难的）</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> signal_generator(</span><br><span class="line">	<span class="keyword">input</span> clk,</span><br><span class="line">	<span class="keyword">input</span> rst_n,</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] wave_choise,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>]wave</span><br><span class="line">	);</span><br><span class="line">    <span class="comment">//counter (only for retangular wave)</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n | (wave_choise != <span class="number">2&#x27;b00</span>)) </span><br><span class="line">            cnt &lt;= <span class="number">5&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">5&#x27;d19</span>)</span><br><span class="line">            cnt &lt;= <span class="number">5&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//delta wave flag (only for delta wave)</span></span><br><span class="line">    <span class="keyword">reg</span> flag;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n | (wave_choise != <span class="number">2&#x27;b10</span>)) </span><br><span class="line">            flag &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(wave == <span class="number">5&#x27;d1</span>)</span><br><span class="line">            flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(wave == <span class="number">5&#x27;d19</span>)</span><br><span class="line">            flag &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            wave &lt;= <span class="number">5&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">case</span>(wave_choise)</span><br><span class="line">            <span class="number">2&#x27;b00</span>: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(cnt == <span class="number">5&#x27;d19</span>)</span><br><span class="line">                    wave &lt;= <span class="number">5&#x27;d0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">5&#x27;d9</span>)</span><br><span class="line">                    wave &lt;= <span class="number">5&#x27;d20</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">2&#x27;b01</span>: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(wave == <span class="number">5&#x27;d20</span>)</span><br><span class="line">                    wave &lt;= <span class="number">5&#x27;d0</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    wave &lt;= wave + <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">2&#x27;b10</span>: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(wave == <span class="number">5&#x27;d20</span>)				<span class="comment">//考虑到刚好在wave=20以及wave=0时发生波形变化</span></span><br><span class="line">                    wave &lt;= wave - <span class="number">1&#x27;b1</span>;		<span class="comment">//</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(wave == <span class="number">5&#x27;d0</span>)			<span class="comment">//</span></span><br><span class="line">                    wave &lt;= wave + <span class="number">1&#x27;b1</span>;		<span class="comment">//</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(flag)</span><br><span class="line">                    wave &lt;= wave - <span class="number">1&#x27;b1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    wave &lt;= wave + <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span>: wave &lt;= <span class="number">5&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL6-数据串转并电路"><a href="#VL6-数据串转并电路" class="headerlink" title="VL6 数据串转并电路"></a>VL6 数据串转并电路</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> s_to_p(</span><br><span class="line">	<span class="keyword">input</span> 				clk 		,   </span><br><span class="line">	<span class="keyword">input</span> 				rst_n		,</span><br><span class="line">	<span class="keyword">input</span>				valid_a		,</span><br><span class="line">	<span class="keyword">input</span>	 			data_a		,</span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">output</span>	<span class="keyword">reg</span> 		ready_a		,</span><br><span class="line"> 	<span class="keyword">output</span>	<span class="keyword">reg</span>			valid_b		,</span><br><span class="line">	<span class="keyword">output</span>  <span class="keyword">reg</span> [<span class="number">5</span>:<span class="number">0</span>] 	data_b</span><br><span class="line">);</span><br><span class="line">    <span class="comment">//根据题意，一直拉高ready_a</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) </span><br><span class="line">            ready_a &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ready_a &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//counter</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) </span><br><span class="line">            cnt &lt;= <span class="number">3&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_a &amp; ready_a) <span class="keyword">begin</span>        <span class="comment">//输入数据有效时，counter才开始计数</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">3&#x27;d5</span>)</span><br><span class="line">                cnt &lt;= <span class="number">3&#x27;d0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cnt &lt;= cnt;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//6-bit shifting register</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">5</span>:<span class="number">0</span>] data_temp;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_temp &lt;= <span class="number">6&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_a &amp; ready_a)</span><br><span class="line">            data_temp &lt;= &#123;data_a, data_temp[<span class="number">5</span>:<span class="number">1</span>]&#125;;    <span class="comment">//最新的输入数据存放在最高位</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            valid_b &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            data_b &lt;= <span class="number">6&#x27;b000000</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">3&#x27;d5</span>) <span class="keyword">begin</span></span><br><span class="line">            valid_b &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            data_b &lt;= &#123;data_a, data_temp[<span class="number">5</span>:<span class="number">1</span>]&#125;;        <span class="comment">//此时的输出应当是最新的1位输入和计数时暂存的5位拼接而成</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            valid_b &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            data_b &lt;= data_b;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL7-数据累加输出-（抄的答案，这题还需加深理解）"><a href="#VL7-数据累加输出-（抄的答案，这题还需加深理解）" class="headerlink" title="VL7 数据累加输出 （抄的答案，这题还需加深理解）"></a>VL7 数据累加输出 （抄的答案，这题还需加深理解）</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> valid_ready(</span><br><span class="line">	<span class="keyword">input</span> 				clk 		,   </span><br><span class="line">	<span class="keyword">input</span> 				rst_n		,</span><br><span class="line">	<span class="keyword">input</span>		[<span class="number">7</span>:<span class="number">0</span>]	data_in		,</span><br><span class="line">	<span class="keyword">input</span>				valid_a		,</span><br><span class="line">	<span class="keyword">input</span>	 			ready_b		,</span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">output</span>		 		ready_a		,</span><br><span class="line"> 	<span class="keyword">output</span>	<span class="keyword">reg</span>			valid_b		,</span><br><span class="line">	<span class="keyword">output</span>  <span class="keyword">reg</span> [<span class="number">9</span>:<span class="number">0</span>] 	data_out</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] data_cnt;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">assign</span> ready_a = ~valid_b | ready_b;	<span class="comment">//表示下游准备好接受本模块的输出或者本模块还没有产生有效输出时，本模块可以接受上游的输出。如此保证不会产生数据丢失，且保持本模块保持满速。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n ) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) </span><br><span class="line">            data_cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_a &amp;&amp; ready_a)</span><br><span class="line">            data_cnt &lt;= (data_cnt == <span class="number">2&#x27;d3</span>) ? <span class="number">&#x27;d0</span> : (data_cnt + <span class="number">1&#x27;d1</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n ) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) </span><br><span class="line">            valid_b &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data_cnt == <span class="number">2&#x27;d3</span> &amp;&amp; valid_a &amp;&amp; ready_a)</span><br><span class="line">            valid_b &lt;= <span class="number">1&#x27;d1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_b &amp;&amp; ready_b)</span><br><span class="line">            valid_b &lt;= <span class="number">1&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n ) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) </span><br><span class="line">            data_out &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ready_b &amp;&amp; valid_a &amp;&amp; ready_a &amp;&amp; (data_cnt == <span class="number">2&#x27;d0</span>))</span><br><span class="line">            data_out &lt;= data_in;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_a &amp;&amp; ready_a)</span><br><span class="line">            data_out &lt;= data_out + data_in;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL8-非整数倍数据位宽转换24to128-（看懂了VL7，这题就感觉蛮简单了）"><a href="#VL8-非整数倍数据位宽转换24to128-（看懂了VL7，这题就感觉蛮简单了）" class="headerlink" title="VL8 非整数倍数据位宽转换24to128 （看懂了VL7，这题就感觉蛮简单了）"></a>VL8 非整数倍数据位宽转换24to128 （看懂了VL7，这题就感觉蛮简单了）</h3><div class="tabs" id="tab-vl8"><ul class="nav-tabs"><li class="tab"><a href="#tab-vl8-1">Solution 1</a></li><li class="tab"><a href="#tab-vl8-2">Solution2</a></li><li class="tab"><a href="#tab-vl8-3">折叠表格</a></li></ul><div class="tab-content"><div class="tab-pane" id="tab-vl8-1"><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> width_24to128(</span><br><span class="line">	<span class="keyword">input</span> 				clk 		,   </span><br><span class="line">	<span class="keyword">input</span> 				rst_n		,</span><br><span class="line">	<span class="keyword">input</span>				valid_in	,</span><br><span class="line">	<span class="keyword">input</span>	[<span class="number">23</span>:<span class="number">0</span>]		data_in		,</span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">output</span>	<span class="keyword">reg</span>			valid_out	,</span><br><span class="line">	<span class="keyword">output</span>  <span class="keyword">reg</span> [<span class="number">127</span>:<span class="number">0</span>]	data_out</span><br><span class="line">);</span><br><span class="line">    <span class="comment">//16-counter</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            cnt &lt;= <span class="number">4&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in)</span><br><span class="line">            cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output valid_out</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((cnt == <span class="number">4&#x27;d5</span>)|(cnt == <span class="number">4&#x27;d10</span>)|(cnt == <span class="number">4&#x27;d15</span>))</span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output data</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">23</span>:<span class="number">0</span>] data_temp1;			<span class="comment">//设置data_temp1用以缓存一个data_in</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_temp1 &lt;= <span class="number">24&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in)</span><br><span class="line">            data_temp1 &lt;= data_in;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">128</span>:<span class="number">0</span>] data_temp2;			<span class="comment">//设置data_temp2只是为了迎合牛客网的tb，它的tb要求在输出无效时，输出必须为0，故用data_temp2作为移位寄存器</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_temp2 &lt;= <span class="number">128&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">4&#x27;d5</span>)</span><br><span class="line">                data_temp2 &lt;= &#123;data_temp2[<span class="number">119</span>:<span class="number">0</span>], data_in[<span class="number">23</span>:<span class="number">16</span>]&#125;;	<span class="comment">//5*24 + 8 = 128</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">4&#x27;d6</span>)</span><br><span class="line">                data_temp2 &lt;= &#123;data_temp2[<span class="number">87</span>:<span class="number">0</span>], data_temp1[<span class="number">15</span>:<span class="number">0</span>], data_in&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">4&#x27;d10</span>)</span><br><span class="line">                data_temp2 &lt;= &#123;data_temp2[<span class="number">111</span>:<span class="number">0</span>], data_in[<span class="number">23</span>:<span class="number">8</span>]&#125;;	<span class="comment">//16 + 24*4 + 16 = 128</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">4&#x27;d11</span>)</span><br><span class="line">                data_temp2 &lt;= &#123;data_temp2[<span class="number">95</span>:<span class="number">0</span>], data_temp1[<span class="number">7</span>:<span class="number">0</span>], data_in&#125;;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                data_temp2 &lt;= &#123;data_temp2[<span class="number">103</span>:<span class="number">0</span>], data_in&#125;;			<span class="comment">//8 + 24*5 = 128</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_out &lt;= <span class="number">128&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">4&#x27;d5</span>)</span><br><span class="line">                data_out &lt;= &#123;data_temp2[<span class="number">119</span>:<span class="number">0</span>], data_in[<span class="number">23</span>:<span class="number">16</span>]&#125;;	<span class="comment">//5*24 + 8 = 128</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">4&#x27;d10</span>)</span><br><span class="line">                data_out &lt;= &#123;data_temp2[<span class="number">111</span>:<span class="number">0</span>], data_in[<span class="number">23</span>:<span class="number">8</span>]&#125;;		<span class="comment">//16 + 24*4 + 16 = 128</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">4&#x27;d15</span>)</span><br><span class="line">                data_out &lt;= &#123;data_temp2[<span class="number">103</span>:<span class="number">0</span>], data_in&#125;;			<span class="comment">//8 + 24*5 = 128</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-vl8-2"><p>修改后占用资源更少：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> width_24to128(</span><br><span class="line">	<span class="keyword">input</span> 				clk 		,   </span><br><span class="line">	<span class="keyword">input</span> 				rst_n		,</span><br><span class="line">	<span class="keyword">input</span>				valid_in	,</span><br><span class="line">	<span class="keyword">input</span>	[<span class="number">23</span>:<span class="number">0</span>]		data_in		,</span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">output</span>	<span class="keyword">reg</span>			valid_out	,</span><br><span class="line">	<span class="keyword">output</span>  <span class="keyword">reg</span> [<span class="number">127</span>:<span class="number">0</span>]	data_out</span><br><span class="line">);</span><br><span class="line">    <span class="comment">//16-counter</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            cnt &lt;= <span class="number">4&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in)</span><br><span class="line">            cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output valid_out</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((cnt == <span class="number">4&#x27;d5</span>)|(cnt == <span class="number">4&#x27;d10</span>)|(cnt == <span class="number">4&#x27;d15</span>)&amp;valid_in)</span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output data</span></span><br><span class="line">    <span class="comment">//cnt==5时，data_temp的值为&#123;data_in_0[7:0],data_in_1,data_in_2,data_in_3,data_in_4,data_in_5&#125;；</span></span><br><span class="line">    <span class="comment">//cnt==9时，data_temp的值为&#123;data_in_4[7:0],data_in_5,data_in_6,data_in_7,data_in_8,data_in_9&#125;；</span></span><br><span class="line">    <span class="comment">//cnt==14时，data_temp的值为&#123;data_in_9[7:0],data_in_10,data_in_11,data_in_12,data_in_13,data_in_14&#125;</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">128</span>:<span class="number">0</span>] data_temp;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_temp &lt;= <span class="number">128&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in) </span><br><span class="line">            data_temp &lt;= &#123;data_temp[<span class="number">103</span>:<span class="number">0</span>], data_in&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_out &lt;= <span class="number">128&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">4&#x27;d5</span>)</span><br><span class="line">                data_out &lt;= &#123;data_temp[<span class="number">119</span>:<span class="number">0</span>], data_in[<span class="number">23</span>:<span class="number">16</span>]&#125;;	<span class="comment">//5*24 + 8 = 128</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">4&#x27;d10</span>)</span><br><span class="line">                data_out &lt;= &#123;data_temp[<span class="number">111</span>:<span class="number">0</span>], data_in[<span class="number">23</span>:<span class="number">8</span>]&#125;;	<span class="comment">//16 + 24*4 + 16 = 128</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">4&#x27;d15</span>)</span><br><span class="line">                data_out &lt;= &#123;data_temp[<span class="number">103</span>:<span class="number">0</span>], data_in&#125;;		<span class="comment">//8 + 24*5 = 128</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-vl8-3"></div></div></div>

<h3 id="VL9-非整数倍数据位宽转换8to12"><a href="#VL9-非整数倍数据位宽转换8to12" class="headerlink" title="VL9 非整数倍数据位宽转换8to12"></a>VL9 非整数倍数据位宽转换8to12</h3><div class="tabs" id="tab-vl9"><ul class="nav-tabs"><li class="tab"><a href="#tab-vl9-1">Solution 1</a></li><li class="tab"><a href="#tab-vl9-2">Solution2</a></li><li class="tab"><a href="#tab-vl9-3">折叠表格</a></li></ul><div class="tab-content"><div class="tab-pane" id="tab-vl9-1"><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> width_8to12(</span><br><span class="line">	<span class="keyword">input</span> 				   clk 		,   </span><br><span class="line">	<span class="keyword">input</span> 			      rst_n		,</span><br><span class="line">	<span class="keyword">input</span>				      valid_in	,</span><br><span class="line">	<span class="keyword">input</span>	[<span class="number">7</span>:<span class="number">0</span>]			   data_in	,</span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">output</span>  <span class="keyword">reg</span>			   valid_out,</span><br><span class="line">	<span class="keyword">output</span>  <span class="keyword">reg</span> [<span class="number">11</span>:<span class="number">0</span>]   data_out</span><br><span class="line">);</span><br><span class="line">    <span class="comment">//counter</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            cnt &lt;= <span class="number">2&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">2&#x27;b10</span>)</span><br><span class="line">                cnt &lt;= <span class="number">2&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output valid_out</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(((cnt == <span class="number">2&#x27;b01</span>) | (cnt == <span class="number">2&#x27;b10</span>)) &amp; valid_in)</span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//shifting register</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] data_temp1;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">11</span>:<span class="number">0</span>] data_temp2;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_temp1 &lt;= <span class="number">8&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in)</span><br><span class="line">            data_temp1 &lt;= data_in;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_temp2 &lt;= <span class="number">8&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">2&#x27;b01</span>)</span><br><span class="line">                data_temp2 &lt;= &#123;data_temp2[<span class="number">7</span>:<span class="number">0</span>], data_in[<span class="number">7</span>:<span class="number">4</span>]&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">2&#x27;b10</span>)</span><br><span class="line">                data_temp2 &lt;= &#123;data_temp1[<span class="number">3</span>:<span class="number">0</span>], data_in&#125;;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                data_temp2 &lt;= &#123;data_temp2[<span class="number">3</span>:<span class="number">0</span>], data_in&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_out &lt;= <span class="number">12&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">2&#x27;b01</span>)</span><br><span class="line">                data_out &lt;= &#123;data_temp2[<span class="number">7</span>:<span class="number">0</span>], data_in[<span class="number">7</span>:<span class="number">4</span>]&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">2&#x27;b10</span>)</span><br><span class="line">                data_out &lt;= &#123;data_temp1[<span class="number">3</span>:<span class="number">0</span>], data_in&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-vl9-2"><p>修改后资源占用更少：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> test(</span><br><span class="line">	<span class="keyword">input</span> 				   clk 		,   </span><br><span class="line">	<span class="keyword">input</span> 			      rst_n		,</span><br><span class="line">	<span class="keyword">input</span>				      valid_in	,</span><br><span class="line">	<span class="keyword">input</span>	[<span class="number">7</span>:<span class="number">0</span>]			   data_in	,</span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">output</span>  <span class="keyword">reg</span>			   valid_out,</span><br><span class="line">	<span class="keyword">output</span>  <span class="keyword">reg</span> [<span class="number">11</span>:<span class="number">0</span>]   data_out</span><br><span class="line">);</span><br><span class="line">    <span class="comment">//counter</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            cnt &lt;= <span class="number">2&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">2&#x27;b10</span>)</span><br><span class="line">                cnt &lt;= <span class="number">2&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output valid_out</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(((cnt == <span class="number">2&#x27;b01</span>) | (cnt == <span class="number">2&#x27;b10</span>)) &amp; valid_in)</span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//shifting register</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">11</span>:<span class="number">0</span>] data_temp;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_temp &lt;= <span class="number">12&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in)</span><br><span class="line">            data_temp &lt;= &#123;data_temp[<span class="number">3</span>:<span class="number">0</span>], data_in&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_out &lt;= <span class="number">12&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">2&#x27;b01</span>)</span><br><span class="line">                data_out &lt;= &#123;data_temp[<span class="number">7</span>:<span class="number">0</span>], data_in[<span class="number">7</span>:<span class="number">4</span>]&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">2&#x27;b10</span>)</span><br><span class="line">                data_out &lt;= &#123;data_temp[<span class="number">3</span>:<span class="number">0</span>], data_in&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-vl9-3"></div></div></div>

<h3 id="VL10-整数倍数据位宽转换8to16"><a href="#VL10-整数倍数据位宽转换8to16" class="headerlink" title="VL10 整数倍数据位宽转换8to16"></a>VL10 整数倍数据位宽转换8to16</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> width_8to16(</span><br><span class="line">	<span class="keyword">input</span> clk,   </span><br><span class="line">	<span class="keyword">input</span> rst_n,</span><br><span class="line">	<span class="keyword">input</span> valid_in,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] data_in,</span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">output</span> <span class="keyword">reg</span> valid_out,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] data_out</span><br><span class="line">);</span><br><span class="line">    <span class="comment">//counter</span></span><br><span class="line">    <span class="keyword">reg</span> cnt;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            cnt &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in)</span><br><span class="line">            cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output valid_out</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((cnt == <span class="number">1&#x27;b1</span>) &amp; valid_in)</span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//shifting register</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] data_temp;							<span class="comment">//整数倍转换只需要一个寄存器</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_temp &lt;= <span class="number">8&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in)</span><br><span class="line">            data_temp &lt;= data_in;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_out &lt;= <span class="number">16&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((cnt== <span class="number">1&#x27;b1</span>) &amp; valid_in)</span><br><span class="line">            data_out &lt;= &#123;data_temp, data_in&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL11-状态机-非重叠的序列检测"><a href="#VL11-状态机-非重叠的序列检测" class="headerlink" title="VL11 状态机-非重叠的序列检测"></a>VL11 状态机-非重叠的序列检测</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<p>用了一个很常规的三段式状态机：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> sequence_test1(</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> clk  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> rst  ,				<span class="comment">//这里的rst其实是低电平有效，但是题目给的名字时rst</span></span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> data ,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> flag</span><br><span class="line">);</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">    <span class="comment">//set state</span></span><br><span class="line">    <span class="keyword">localparam</span> IDLE = <span class="number">0</span>, S1 = <span class="number">1</span>, S10 = <span class="number">2</span>, S101 = <span class="number">3</span>, S1011 = <span class="number">4</span>, S10111 = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] state, next;</span><br><span class="line">    <span class="comment">//state transition</span></span><br><span class="line">    <span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(state)</span><br><span class="line">            IDLE:   next = data ? S1	: IDLE	;</span><br><span class="line">            S1:		next = data ? S1	: S10	;</span><br><span class="line">			S10:	next = data ? S101	: IDLE	;</span><br><span class="line">			S101:	next = data ? S1011	: S10	;</span><br><span class="line">			S1011:	next = data ? S10111: S10	;</span><br><span class="line">			S10111:	next = data ? S1	: IDLE	;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">	 <span class="comment">//state flip-flops</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~rst)</span><br><span class="line">			state &lt;= IDLE;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			state &lt;= next;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">//output</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~rst)</span><br><span class="line">			flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">case</span>(next)</span><br><span class="line">			S10111:	flag &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">			<span class="keyword">default</span>: flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL12-状态机-重叠序列检测"><a href="#VL12-状态机-重叠序列检测" class="headerlink" title="VL12 状态机-重叠序列检测"></a>VL12 状态机-重叠序列检测</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> sequence_test2(</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> clk  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> rst  ,				<span class="comment">//这里的rst其实是低电平有效，但是题目给的名字时rst</span></span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> data ,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> flag</span><br><span class="line">);</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">	<span class="comment">//set state</span></span><br><span class="line">	<span class="keyword">localparam</span> IDLE = <span class="number">0</span>, S1 = <span class="number">1</span>, S10 = <span class="number">2</span>, S101 = <span class="number">3</span>, S1011 = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] state, next;</span><br><span class="line">	<span class="comment">//state transition</span></span><br><span class="line">	<span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">case</span>(state)</span><br><span class="line">			IDLE:   next = data ? S1	: IDLE	;</span><br><span class="line">			S1:		next = data ? S1	: S10	;</span><br><span class="line">			S10:	next = data ? S101	: IDLE	;</span><br><span class="line">			S101:	next = data ? S1011	: S10	;</span><br><span class="line">			S1011:	next = data ? S1	: S10	;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">	 <span class="comment">//state flip-flops</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~rst)</span><br><span class="line">			state &lt;= IDLE;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			state &lt;= next;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">//output</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~rst)</span><br><span class="line">			flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">case</span>(state)</span><br><span class="line">			S1011:	flag &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">			<span class="keyword">default</span>: flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL13-时钟分频（偶数）"><a href="#VL13-时钟分频（偶数）" class="headerlink" title="VL13 时钟分频（偶数）"></a>VL13 时钟分频（偶数）</h3><div class="tabs" id="tab-vl13"><ul class="nav-tabs"><li class="tab"><a href="#tab-vl13-1">有计数器</a></li><li class="tab"><a href="#tab-vl13-2">无计数器</a></li><li class="tab"><a href="#tab-vl13-3">折叠表格</a></li></ul><div class="tab-content"><div class="tab-pane" id="tab-vl13-1"><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> even_div</span><br><span class="line">    (</span><br><span class="line">    <span class="keyword">input</span>     <span class="keyword">wire</span> rst ,			<span class="comment">//这里的rst其实是低电平有效，但是题目给的名字时rst</span></span><br><span class="line">    <span class="keyword">input</span>     <span class="keyword">wire</span> clk_in,</span><br><span class="line">    <span class="keyword">output</span>    <span class="keyword">reg</span> clk_out2,</span><br><span class="line">    <span class="keyword">output</span>    <span class="keyword">reg</span> clk_out4,</span><br><span class="line">    <span class="keyword">output</span>    <span class="keyword">reg</span> clk_out8</span><br><span class="line">    );</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">    <span class="comment">//counter</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) </span><br><span class="line">            cnt &lt;= <span class="number">3&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//clk_out2</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) </span><br><span class="line">            clk_out2 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            clk_out2 &lt;= ~clk_out2;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//clk_out4</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) </span><br><span class="line">            clk_out4 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((cnt == <span class="number">2&#x27;d0</span>) | (cnt == <span class="number">2&#x27;d2</span>))</span><br><span class="line">            clk_out4 &lt;= ~clk_out4;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//clk_out8</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) </span><br><span class="line">            clk_out8 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">2&#x27;d0</span>)</span><br><span class="line">            clk_out8 &lt;= ~clk_out8;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-vl13-2"><p>不含计数器的做法，实际使用时不推荐：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> even_div</span><br><span class="line">    (</span><br><span class="line">    <span class="keyword">input</span>	<span class="keyword">wire</span> rst ,				<span class="comment">//这里的rst其实是低电平有效，但是题目给的名字时rst</span></span><br><span class="line">    <span class="keyword">input</span>	<span class="keyword">wire</span> clk_in,				</span><br><span class="line">    <span class="keyword">output</span>	<span class="keyword">reg</span> clk_out2,</span><br><span class="line">    <span class="keyword">output</span>	<span class="keyword">reg</span> clk_out4,</span><br><span class="line">    <span class="keyword">output</span>	<span class="keyword">reg</span> clk_out8</span><br><span class="line">    );</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">    <span class="comment">//clk_out2</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) </span><br><span class="line">            clk_out2 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            clk_out2 &lt;= ~clk_out2;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//clk_out4</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_out2 <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) </span><br><span class="line">            clk_out4 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            clk_out4 &lt;= ~clk_out4;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//clk_out8</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_out4 <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) </span><br><span class="line">            clk_out8 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            clk_out8 &lt;= ~clk_out8;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p> 此方法在<u>低频信号中可以使用，但是在高频时钟下会出现失误</u>， 在FPGA中所有的时钟都要连接到<strong>全局时钟网络</strong>中去，又叫全局时钟数，其目的是为了保证时钟信号到达每一个器件的时间都尽可能相同，<u>而这种方法并没有连接到全局时钟网络中</u> 。</p>
<p>想要改进，可以使用脉冲标志信号，即在每个所需周期末尾输出一个clk_flag脉冲信号，利用<code>always@(posedge clk or negedge rst_n) </code>和<code>if(clk_flag = 1&#39;b1)</code>达到分频的目的。</p></div><div class="tab-pane" id="tab-vl13-3"></div></div></div>

<h3 id="VL14-自动贩售机1"><a href="#VL14-自动贩售机1" class="headerlink" title="VL14 自动贩售机1"></a>VL14 自动贩售机1</h3><div class="tabs" id="tab-vl14"><ul class="nav-tabs"><li class="tab"><a href="#tab-vl14-1">状态机方法</a></li><li class="tab"><a href="#tab-vl14-2">非状态机方法</a></li><li class="tab"><a href="#tab-vl14-3">折叠表格</a></li></ul><div class="tab-content"><div class="tab-pane" id="tab-vl14-1"><p>因为题目中的d1，d2，d3只输入半个周期高电平，所以需要增加3个寄存器来存放输入，写出来的代码有点笨重：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> seller1(</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> clk  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> rst  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> d1 ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> d2 ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> d3 ,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> out1,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>]out2</span><br><span class="line">);</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">    <span class="comment">//state machine</span></span><br><span class="line">    <span class="comment">//set state</span></span><br><span class="line">    <span class="keyword">localparam</span> IDLE = <span class="number">0</span>, S05 = <span class="number">1</span>, S10 = <span class="number">2</span>, S15 = <span class="number">3</span>, S20 = <span class="number">4</span>, S25 = <span class="number">5</span>, S30 = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] state, next;</span><br><span class="line">    <span class="comment">//state transition</span></span><br><span class="line">    <span class="keyword">reg</span> rg1, rg2, rg3;        <span class="comment">//save d1, d2, d3</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            rg1 &lt;= <span class="number">0</span>;</span><br><span class="line">            rg2 &lt;= <span class="number">0</span>;</span><br><span class="line">            rg3 &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            rg1 &lt;= d1;</span><br><span class="line">            rg2 &lt;= d2;</span><br><span class="line">            rg3 &lt;= d3;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(state)</span><br><span class="line">            IDLE: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(rg3)</span><br><span class="line">                    next = S20;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rg2)</span><br><span class="line">                    next = S10;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rg1)</span><br><span class="line">                    next = S05;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    next = IDLE;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S05: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(rg3)</span><br><span class="line">                    next = S25;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rg2)</span><br><span class="line">                    next = S15;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rg1)</span><br><span class="line">                    next = S10;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    next = S05;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S10: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(rg3)</span><br><span class="line">                    next = S30;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rg2)</span><br><span class="line">                    next = S20;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rg1)</span><br><span class="line">                    next = S15;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    next = S10;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S15: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(rg3)</span><br><span class="line">                    next = S20;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rg2)</span><br><span class="line">                    next = S10;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rg1)</span><br><span class="line">                    next = S05;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    next = IDLE;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S20: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(rg3)</span><br><span class="line">                    next = S20;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rg2)</span><br><span class="line">                    next = S10;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rg1)</span><br><span class="line">                    next = S05;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    next = IDLE;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S25: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(rg3)</span><br><span class="line">                    next = S20;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rg2)</span><br><span class="line">                    next = S10;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rg1)</span><br><span class="line">                    next = S05;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    next = IDLE;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S30: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(rg3)</span><br><span class="line">                    next = S20;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rg2)</span><br><span class="line">                    next = S10;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rg1)</span><br><span class="line">                    next = S05;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    next = IDLE;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//state flip-flps</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst)</span><br><span class="line">            state &lt;= IDLE;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            state &lt;= next;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            out1 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            out2 &lt;= <span class="number">2&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">case</span>(next)</span><br><span class="line">            S15: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                out2 &lt;= <span class="number">2&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S20: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                out2 &lt;= <span class="number">2&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S25: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                out2 &lt;= <span class="number">2&#x27;d2</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S30: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                out2 &lt;= <span class="number">2&#x27;d3</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                out2 &lt;= <span class="number">2&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-vl14-2"><p>从代码量来看都能看出比状态机方法简单一些</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> seller1(</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> clk  ,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> rst  ,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> d1 ,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> d2 ,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> d3 ,</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> out1,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>]out2</span><br><span class="line">);</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] money05;</span><br><span class="line">    <span class="comment">//accumulating money</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst)</span><br><span class="line">            money05 &lt;= <span class="number">3&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((money05[<span class="number">2</span>]==<span class="number">1</span>) | (money05[<span class="number">1</span>:<span class="number">0</span>]==<span class="number">2&#x27;b11</span>))	<span class="comment">//此时累积金钱大于3 * 0.5元</span></span><br><span class="line">            money05 &lt;= <span class="number">3&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">case</span>(&#123;d3, d2, d1&#125;)</span><br><span class="line">            <span class="number">3&#x27;b001</span>: money05 &lt;= money05 + <span class="number">1&#x27;d1</span>;</span><br><span class="line">            <span class="number">3&#x27;b010</span>: money05 &lt;= money05 + <span class="number">2&#x27;d2</span>;</span><br><span class="line">            <span class="number">3&#x27;b100</span>: money05 &lt;= money05 + <span class="number">3&#x27;d4</span>;</span><br><span class="line">            <span class="keyword">default</span>: money05 &lt;= money05;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">	<span class="comment">//output</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            out1 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            out2 &lt;= <span class="number">2&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">case</span>(money05)				<span class="comment">//根据累积金钱来判断输出</span></span><br><span class="line">            <span class="number">3&#x27;d3</span>: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                out2 &lt;= <span class="number">2&#x27;d0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;d4</span>: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                out2 &lt;= <span class="number">2&#x27;d1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;d5</span>: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                out2 &lt;= <span class="number">2&#x27;d2</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;d6</span>: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                out2 &lt;= <span class="number">2&#x27;d3</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                out2 &lt;= <span class="number">2&#x27;d0</span>;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-vl14-3"></div></div></div>

<h3 id="VL15-自动贩售机2"><a href="#VL15-自动贩售机2" class="headerlink" title="VL15 自动贩售机2"></a>VL15 自动贩售机2</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> seller2(</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> clk  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> rst  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> d1 ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> d2 ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> sel ,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> out1,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> out2,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> out3</span><br><span class="line">);</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] money05;</span><br><span class="line">    <span class="comment">//accumulating money</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst)</span><br><span class="line">            money05 &lt;= <span class="number">3&#x27;d0</span>;</span><br><span class="line">        <span class="comment">//判断是否满足出饮料的条件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(((money05[<span class="number">2</span>] | (money05[<span class="number">1</span>] &amp; money05[<span class="number">0</span>])) &amp; ~sel) | (money05[<span class="number">2</span>] &amp; (money05[<span class="number">1</span>] | money05[<span class="number">0</span>]) &amp; sel))</span><br><span class="line">            money05 &lt;= <span class="number">3&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">case</span>(&#123;d2, d1&#125;)</span><br><span class="line">            <span class="number">2&#x27;b01</span>: money05 &lt;= money05 + <span class="number">1&#x27;d1</span>;</span><br><span class="line">            <span class="number">2&#x27;b10</span>: money05 &lt;= money05 + <span class="number">2&#x27;d2</span>;</span><br><span class="line">            <span class="keyword">default</span>: money05 &lt;= money05;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">	<span class="comment">//output    </span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            out1 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            out2 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            out3 &lt;= <span class="number">2&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">case</span>(money05)				<span class="comment">//根据累积金钱来判断输出</span></span><br><span class="line">            <span class="number">3&#x27;d3</span>: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= sel ? <span class="number">1&#x27;b0</span> : <span class="number">1&#x27;b1</span>;</span><br><span class="line">                out2 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                out3 &lt;= <span class="number">2&#x27;d0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;d4</span>: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= sel ? <span class="number">1&#x27;b0</span> : <span class="number">1&#x27;b1</span>;</span><br><span class="line">                out2 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                out3 &lt;= sel ? <span class="number">2&#x27;d0</span> : <span class="number">2&#x27;d1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;d5</span>: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= sel ? <span class="number">1&#x27;b0</span> : <span class="number">1&#x27;b1</span>;</span><br><span class="line">                out2 &lt;= sel ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line">                out3 &lt;= sel ? <span class="number">2&#x27;d0</span> : <span class="number">2&#x27;d2</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;d6</span>: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= sel ? <span class="number">1&#x27;b0</span> : <span class="number">1&#x27;b1</span>;</span><br><span class="line">                out2 &lt;= sel ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line">                out3 &lt;= sel ? <span class="number">2&#x27;d1</span> : <span class="number">2&#x27;d3</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                out2 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                out3 &lt;= <span class="number">2&#x27;d0</span>;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL16-占空比50-的奇数分频-（这题是重点！！）"><a href="#VL16-占空比50-的奇数分频-（这题是重点！！）" class="headerlink" title="VL16 占空比50%的奇数分频 （这题是重点！！）"></a>VL16 占空比50%的奇数分频 （这题是重点！！）</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> odo_div_or</span><br><span class="line">	(</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>	rst,</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>	clk_in,</span><br><span class="line">	<span class="keyword">output</span>	<span class="keyword">wire</span>	clk_out7</span><br><span class="line">);</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">	<span class="keyword">localparam</span> N = <span class="number">7</span>;</span><br><span class="line">	<span class="comment">//counter_p</span></span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] cnt_p;</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~rst)</span><br><span class="line">			cnt_p &lt;= <span class="number">3&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(cnt_p == N-<span class="number">1</span>)</span><br><span class="line">			cnt_p &lt;= <span class="number">3&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			cnt_p &lt;= cnt_p + <span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">//clk_p</span></span><br><span class="line">	<span class="keyword">reg</span> clk_p;</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~rst)</span><br><span class="line">			clk_p &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>((cnt_p == (N-<span class="number">1</span>)/<span class="number">2</span>) | (cnt_p == N-<span class="number">1</span>))</span><br><span class="line">			clk_p &lt;= ~clk_p;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">//counter_n</span></span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] cnt_n;</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">negedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~rst)</span><br><span class="line">			cnt_n &lt;= <span class="number">3&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(cnt_n == N-<span class="number">1</span>)</span><br><span class="line">			cnt_n &lt;= <span class="number">3&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			cnt_n &lt;= cnt_n + <span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">//clk_n</span></span><br><span class="line">	<span class="keyword">reg</span> clk_n;</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">negedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~rst)</span><br><span class="line">			clk_n &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>((cnt_n == (N-<span class="number">1</span>)/<span class="number">2</span>) | (cnt_n == N-<span class="number">1</span>))</span><br><span class="line">			clk_n &lt;= ~clk_n;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">//output</span></span><br><span class="line">	<span class="keyword">assign</span> clk_out7 = clk_p | clk_n;</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <tags>
        <tag>Verilog</tag>
      </tags>
  </entry>
</search>
