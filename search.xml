<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/04/13/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>搭建博客相关问题</title>
    <url>/2022/04/13/hexo-note/</url>
    <content><![CDATA[<h2 id="【随时补充】搭建个人博客时遇到的一些问题"><a href="#【随时补充】搭建个人博客时遇到的一些问题" class="headerlink" title="【随时补充】搭建个人博客时遇到的一些问题"></a>【随时补充】搭建个人博客时遇到的一些问题</h2><h3 id="如何解决无法访问Github"><a href="#如何解决无法访问Github" class="headerlink" title="如何解决无法访问Github"></a>如何解决无法访问Github</h3><p>在 C:\Windows\System32\drivers\etc\hosts 文件中末尾添加两行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">140.82.113.4 github.com</span><br><span class="line">140.82.113.4 www.github.com</span><br></pre></td></tr></table></figure>
<p>其中ip地址可在 <a href="https://github.com.ipaddress.com/www.github.com">https://github.com.ipaddress.com/www.github.com</a> 中查询</p>
<p>若完成上述操作后仍无法访问，可以再添加两行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">69.171.224.40 github.global.ssl.fastly.net</span><br><span class="line">185.199.111.153 assets-cdn.github.com</span><br></pre></td></tr></table></figure>
<p>其中ip地址可以在 <a href="http://tool.chinaz.com/dns">http://tool.chinaz.com/dns</a> 中输入网址查询，选取TTL值较低的ip地址即可</p>
<p>在修改hosts文件时，通常先将其复制到其他路径得到一个副本，将副本修改保存后替换原文件。（建议修改前备份一个hosts文件）</p>
<p>参考：<a href="https://www.cnblogs.com/yanch01/p/GitHub-access.html">https://www.cnblogs.com/yanch01/p/GitHub-access.html</a></p>
<hr>
<h3 id="修改主题配置"><a href="#修改主题配置" class="headerlink" title="修改主题配置"></a>修改主题配置</h3><p>在hexo根目录下创建一个_config.[主题名].yml，例如：_config.next.yml，可以覆盖主题目录下_config.yml文件的作用。这样可以在不修改主题_config.yml文件的情况下，很方便的修改主题配置。</p>
<h3 id="styles-styl文件"><a href="#styles-styl文件" class="headerlink" title="styles.styl文件"></a>styles.styl文件</h3><p>在next 8.x版本中，用户需要自行创建styles.styl文件，放在[hexo根目录]\source\_data\下，注意不是next主题目录下的source文件夹。如果你的source文件夹里没有_data文件夹，创建一个即可。</p>
<p>然后在_config.next.yml中，找到以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Define custom file paths.</span><br><span class="line"># Create your custom files in site directory `source/_data` and uncomment needed files below.</span><br><span class="line">custom_file_path:</span><br><span class="line">  #head: source/_data/head.njk</span><br><span class="line">  #header: source/_data/header.njk</span><br><span class="line">  #sidebar: source/_data/sidebar.njk</span><br><span class="line">  #postMeta: source/_data/post-meta.njk</span><br><span class="line">  #postBodyEnd: source/_data/post-body-end.njk</span><br><span class="line">  #footer: source/_data/footer.njk</span><br><span class="line">  #bodyEnd: source/_data/body-end.njk</span><br><span class="line">  #variable: source/_data/variables.styl</span><br><span class="line">  #mixin: source/_data/mixins.styl</span><br><span class="line">  #style: source/_data/styles.styl</span><br></pre></td></tr></table></figure>

<p>将其中的style项取消注释，即可通过修改styles.styl的方式来进行个性化设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">style: source/_data/styles.styl			//取消注释，即删去#号</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://github.com/iissnan/hexo-theme-next/issues/680">https://github.com/iissnan/hexo-theme-next/issues/680</a></p>
<hr>
<h3 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h3><p>想要在远端部署时实现正文首行缩进2字符，可以在 styles.styl文件中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//仅正文首行缩进2字符</span><br><span class="line">.post-body p &#123; text-indent: 2em; &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="制作Table"><a href="#制作Table" class="headerlink" title="制作Table"></a>制作Table</h3><p>参考：<a href="https://theme-next.js.org/docs/tag-plugins/tabs.html">https://theme-next.js.org/docs/tag-plugins/tabs.html</a></p>
<h3 id="修改tab缩进距离"><a href="#修改tab缩进距离" class="headerlink" title="修改tab缩进距离"></a>修改tab缩进距离</h3><p>在[hexo根目录]\source\_data\styles.styl文件中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//设置tab-size</span><br><span class="line">pre &#123;</span><br><span class="line">    tab-size: 4;			//数字即是tab的缩进距离</span><br><span class="line">&#125;</span><br><span class="line">.hljs &#123;</span><br><span class="line">    tab-size: 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过尝试后发现，pre对本地部署一定有效，对远端部署我也不知道哪个是有效的，所以就都加上了。</p>
<p>参考：<a href="https://github.com/blinkfox/hexo-theme-matery/issues/637">https://github.com/blinkfox/hexo-theme-matery/issues/637</a></p>
<h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><p>我用的是typora编辑markdown文件，为了更方便的插入图片，先修改一下typora的设置，在<code>文件—&gt;偏好设置中</code>设置为下图所示：</p>
<img src="/2022/04/13/hexo-note/1651300673162.png" class="" width="1651300673162">

<p>为hexo安装两个插件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-marked</span><br><span class="line">npm install hexo-image-link --save	//该插件能够帮助实现路径转换，hexo部署后图片路径与md文件中不同</span><br></pre></td></tr></table></figure>

<p>更改 _config.yml 配置 ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true				//hexo会为文稿生成一个同名文件夹，文稿中所用图片存入文件夹中</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.csdn.net/rentonhe/article/details/123666769">https://blog.csdn.net/rentonhe/article/details/123666769</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>学习FPGA（一）</title>
    <url>/2022/04/13/FPGA/FPGA-1/</url>
    <content><![CDATA[<p>刚好今天尝试使用hexo框架搭建了个人博客，索性记录一下自己学习FPGA的过程，方便日后查看和复习。</p>
<h2 id="BCD计数器设计与验证"><a href="#BCD计数器设计与验证" class="headerlink" title="BCD计数器设计与验证"></a>BCD计数器设计与验证</h2><p>目的是通过将三个BCD计数器级联来实现1000的计数单个BCD计数器的Verilog代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> bcd_counter(Clk, Cin, Rst_n, Cout, Q);</span><br><span class="line">	<span class="keyword">input</span> Clk;<span class="comment">//时间基准信号</span></span><br><span class="line">	<span class="keyword">input</span> Cin;<span class="comment">//计数器进位输入</span></span><br><span class="line">	<span class="keyword">input</span> Rst_n;<span class="comment">//计数器复位输入</span></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> Cout;<span class="comment">//计数器进位输出</span></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] Q;<span class="comment">//计数器计数输出</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//产生输出进位信号</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> Clk <span class="keyword">or</span> <span class="keyword">negedge</span> Rst_n) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(Rst_n==<span class="number">1&#x27;b0</span>) Cout = <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(Q==<span class="number">4&#x27;d9</span> &amp;&amp; Cin==<span class="number">1&#x27;b1</span>) Cout = <span class="number">1&#x27;b1</span>;	<span class="comment">//此处的进位设置并不合理，级联后会发生错误</span></span><br><span class="line">		<span class="keyword">else</span> Cout = <span class="number">1&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//执行计数过程</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> Clk <span class="keyword">or</span> <span class="keyword">negedge</span> Rst_n) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(Rst_n==<span class="number">1&#x27;b0</span>) Q &lt;= <span class="number">4&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(Cin==<span class="number">1&#x27;b1</span>) <span class="keyword">begin</span></span><br><span class="line">			<span class="keyword">if</span>(Q==<span class="number">4&#x27;d9</span>)Q &lt;= <span class="number">4&#x27;b0</span>;</span><br><span class="line">			<span class="keyword">else</span> Q &lt;= Q + <span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> Q &lt;= Q;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>使用modelsim分析时，先从sim中把子模块的输入输出信号全部添加到波形窗口中然后在波形窗口中选中所有信号（Ctrl+a）</p>
<img src="/2022/04/13/FPGA/FPGA-1/1651396297097.png" class="" width="1651396297097">

<p>再按下快捷键Ctrl+g，完成按模块分组</p>
<img src="/2022/04/13/FPGA/FPGA-1/1651396327618.png" class="" width="1651396327618">

<p>将”&#x2F;&#x2F;产生输出进位信号”部分修改为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(Rst_n==<span class="number">1&#x27;b0</span>) Cout = <span class="number">1&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(Q==<span class="number">4&#x27;d9</span> &amp;&amp; Cin==<span class="number">1&#x27;b1</span>) Cout = <span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="keyword">else</span> Cout = <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>此即行为级建模实现的组合逻辑，但仿真的结果出现了奇怪的毛刺，这是rtl级仿真不该出现的</p>
<p>于是再将其改为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> Cout = (Q==<span class="number">4&#x27;d9</span> &amp;&amp; Cin==<span class="number">1&#x27;b1</span>);</span><br></pre></td></tr></table></figure>
<p>此即数据流建模实现的组合逻辑。需要注意的是，此时应当将Cout的类型变更为wire型，否则会发生编译错误。</p>
<p>两种建模方式的资源占用率有所不同：</p>
]]></content>
      <tags>
        <tag>FPGA</tag>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>学习FPGA（二）</title>
    <url>/2022/04/14/FPGA/FPGA-2/</url>
    <content><![CDATA[<h1 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h1><p>状态的表示常用编码方法有二进制码、格雷码（Gray code）、独热码（one-hot code）。</p>
<h2 id="二进制码"><a href="#二进制码" class="headerlink" title="二进制码"></a>二进制码</h2><p>即用二进制计数</p>
<p>优点：属于压缩状态编码，状态机所需的状态向量位数较少；</p>
<p>缺点：1、译码复杂；2、相邻状态变换时，会有多位发生改变，电噪声大、转换速度较慢、易出错；（实际电路中多位改变很难做到完全同时发生）；</p>
<h2 id="格雷码（Gray-code）"><a href="#格雷码（Gray-code）" class="headerlink" title="格雷码（Gray code）"></a>格雷码（Gray code）</h2><p>在一组数的编码中，任意两个相邻的代码只有一位二进制数不同，且最大数与最小数之间也仅有一位数不同<br>构造方法：<br>1位格雷码有两个码字<br>(n+1)位格雷码中的前2n个码字等于n位格雷码的码字，按顺序书写，加前缀0<br>(n+1)位格雷码中的后2n个码字等于n位格雷码的码字，按逆序书写，加前缀1<br>n+1位格雷码的集合 &#x3D; n位格雷码集合(顺序)加前缀0 + n位格雷码集合(逆序)加前缀1<br>如：二进制码：000-001-010-011-100-101-110-111 相应的格雷码：000-001-011-010-110-111-101<br>    优点：1、属于压缩状态编码，状态机所需的状态向量位数较少；2、相邻状态变换时，仅有一位发生改变，电噪声小、转换速度较快；<br>    缺点：1、译码复杂；2、是一种变权码，每一位码没有固定的大小，难以直接比较大小和算术运算；</p>
<h2 id="独热码（one-hot-code）"><a href="#独热码（one-hot-code）" class="headerlink" title="独热码（one-hot code）"></a>独热码（one-hot code）</h2><p>有多少个状态就有多少个比特，其中有且只有一个比特为1，其余为0<br>用独热码表示三个状态可以写为：001，010，100</p>
<p>优点：译码简单；</p>
<p>缺点：速度较慢，占用触发器资源较多，面积较大；</p>
<h2 id="编写一个检测”Hello”序列的状态机"><a href="#编写一个检测”Hello”序列的状态机" class="headerlink" title="编写一个检测”Hello”序列的状态机"></a>编写一个检测”Hello”序列的状态机</h2><p>设置状态时，常用localparam或者parameter。其中parameter可用作在顶层模块中例化底层模块时传递参数的接口；而localparam的作用域仅仅限于当前module，不能作为参数传递的接口。</p>
<p>状态机分为一段时状态机、两段式状态机、三段式状态机，</p>
<p>作者第一次写出的代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> state_machine (Clk, Rst_n, data, led); <span class="comment">//Hello状态机</span></span><br><span class="line">	<span class="keyword">input</span> Clk;	<span class="comment">//基准时钟信号50M</span></span><br><span class="line">	<span class="keyword">input</span> Rst_n;	<span class="comment">//输入异步复位信号</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] data;	<span class="comment">//输入数据</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> led; <span class="comment">//当前状态输入</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//set state</span></span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] state, next;</span><br><span class="line">	<span class="keyword">localparam</span></span><br><span class="line">		CHECK_H = <span class="number">&#x27;d0</span>, </span><br><span class="line">		CHECK_e = <span class="number">&#x27;d1</span>, </span><br><span class="line">		CHECK_la = <span class="number">&#x27;d2</span>, </span><br><span class="line">		CHECK_lb = <span class="number">&#x27;d3</span>, </span><br><span class="line">		CHECK_o = <span class="number">&#x27;d4</span>;</span><br><span class="line">	<span class="comment">//state transition (combinational logic)</span></span><br><span class="line">	<span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">case</span>(state)</span><br><span class="line">			CHECK_H:	<span class="keyword">begin</span></span><br><span class="line">				<span class="keyword">if</span>(data == <span class="string">&quot;H&quot;</span>) </span><br><span class="line">					next = CHECK_e;</span><br><span class="line">				<span class="keyword">else</span> </span><br><span class="line">					next = CHECK_H;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			CHECK_e:	<span class="keyword">begin</span></span><br><span class="line">				<span class="keyword">if</span>(data == <span class="string">&quot;e&quot;</span>) </span><br><span class="line">					next = CHECK_la;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(data == <span class="string">&quot;H&quot;</span>)</span><br><span class="line">					next = CHECK_e;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					next = CHECK_H;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			CHECK_la:	<span class="keyword">begin</span></span><br><span class="line">				<span class="keyword">if</span>(data == <span class="string">&quot;l&quot;</span>) </span><br><span class="line">					next = CHECK_lb;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(data == <span class="string">&quot;H&quot;</span>)</span><br><span class="line">					next = CHECK_e;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					next = CHECK_H;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			CHECK_lb:	<span class="keyword">begin</span></span><br><span class="line">				<span class="keyword">if</span>(data == <span class="string">&quot;l&quot;</span>) </span><br><span class="line">					next = CHECK_o;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(data == <span class="string">&quot;H&quot;</span>)</span><br><span class="line">					next = CHECK_e;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					next = CHECK_H;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			CHECK_o:	<span class="keyword">begin</span></span><br><span class="line">				<span class="keyword">if</span>(data == <span class="string">&quot;o&quot;</span>) </span><br><span class="line">					next = CHECK_H;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(data == <span class="string">&quot;H&quot;</span>)</span><br><span class="line">					next = CHECK_e;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					next = CHECK_H;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">default</span>: next = CHECK_H;<span class="comment">//默认状态下reset</span></span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">//state flip-flops (sequential logic)</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> Clk <span class="keyword">or</span> <span class="keyword">negedge</span> Rst_n) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~Rst_n) state &lt;= CHECK_H;</span><br><span class="line">		<span class="keyword">else</span> state &lt;= next;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">//output</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> Clk <span class="keyword">or</span> <span class="keyword">negedge</span> Rst_n) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~Rst_n) led &lt;= <span class="number">1&#x27;b1</span>;	<span class="comment">//通常led低电平有效，高电平无效</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">case</span>(state)</span><br><span class="line">			CHECK_o: led &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">			<span class="keyword">default</span>: led &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>FPGA</tag>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>学习FPGA（三）</title>
    <url>/2022/04/15/FPGA/FPGA-3/</url>
    <content><![CDATA[<h1 id="按键消抖"><a href="#按键消抖" class="headerlink" title="按键消抖"></a>按键消抖</h1><h2 id="主模块"><a href="#主模块" class="headerlink" title="主模块"></a>主模块</h2><p>三段式状态机代码如下</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目的：设计一个按键消抖，滤波时间为20ms</span></span><br><span class="line"><span class="comment">//晶振为50M，即一个时间周期为20ns</span></span><br><span class="line"><span class="comment">//需要滤波1_000_000个时间周期</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> filter_time 20&#x27;d1_000_000</span></span><br><span class="line"><span class="keyword">module</span> key_filter(Clk, Rst_n, Key_in, Key_flag, Key_state);</span><br><span class="line">	<span class="keyword">input</span> Clk;	<span class="comment">//时钟输入</span></span><br><span class="line">	<span class="keyword">input</span> Rst_n;	<span class="comment">//复位输入</span></span><br><span class="line">	<span class="keyword">input</span> Key_in;	<span class="comment">//按键输入，按下时为0，断开时为1</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> Key_flag;	<span class="comment">//按键输入变化后出现稳定状态时，显示为1（保持一个时钟周期），其余时候为0</span></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> Key_state;	<span class="comment">//按键状态，按下时显示为0， 断开时为1</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//set state(one-hot code)</span></span><br><span class="line">	<span class="keyword">localparam</span> </span><br><span class="line">		IDLE		= <span class="number">4&#x27;b0001</span>, </span><br><span class="line">		FILTER0	= <span class="number">4&#x27;b0010</span>, </span><br><span class="line">		DOWN		= <span class="number">4&#x27;b0100</span>,</span><br><span class="line">		FILTER1	= <span class="number">4&#x27;b1000</span>;</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] state, next;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//edge check</span></span><br><span class="line">	<span class="keyword">reg</span> Key_tmp0, Key_tmp1;</span><br><span class="line">	<span class="keyword">wire</span> Key_posedge, Key_negedge;</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> Clk <span class="keyword">or</span> <span class="keyword">negedge</span> Rst_n) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~Rst_n) <span class="keyword">begin</span></span><br><span class="line">			Key_tmp0 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">			Key_tmp1 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">			Key_tmp0 &lt;= Key_in;		<span class="comment">//当Key_tmp0 = 1 且 Key_tmp1 = 0时即为一个上升沿</span></span><br><span class="line">			Key_tmp1 &lt;= Key_tmp0;	<span class="comment">//当Key_tmp0 = 0 且 Key_tmp1 = 1时即为一个下降沿</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">assign</span> Key_posedge = ~Key_tmp1 &amp; Key_tmp0;</span><br><span class="line">	<span class="keyword">assign</span> Key_negedge = Key_tmp1 &amp; ~Key_tmp0;</span><br><span class="line">	<span class="comment">//filter counter</span></span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">19</span>:<span class="number">0</span>] cnt;</span><br><span class="line">	<span class="keyword">reg</span> cnt_full;	<span class="comment">//计数器计满信号</span></span><br><span class="line">	<span class="keyword">reg</span> en_cnt;		<span class="comment">//计数器使能信号</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> Clk <span class="keyword">or</span> <span class="keyword">negedge</span> Rst_n) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~Rst_n) <span class="keyword">begin</span></span><br><span class="line">			cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">			cnt_full &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(en_cnt) <span class="keyword">begin</span></span><br><span class="line">			<span class="keyword">if</span>(cnt == (`filter_time - <span class="number">1</span>)) <span class="keyword">begin</span></span><br><span class="line">				cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">				cnt_full &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">				cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">				cnt_full &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">			cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">			cnt_full &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//state transition(combinational)</span></span><br><span class="line">	<span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">case</span>(state)</span><br><span class="line">			IDLE: <span class="keyword">begin</span></span><br><span class="line">				<span class="keyword">if</span>(Key_negedge)</span><br><span class="line">					next = FILTER0;</span><br><span class="line">				<span class="keyword">else</span> </span><br><span class="line">					next = IDLE;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			FILTER0: <span class="keyword">begin</span></span><br><span class="line">				<span class="keyword">if</span>(cnt_full)</span><br><span class="line">					next = DOWN;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(Key_posedge)</span><br><span class="line">					next = IDLE;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					next = FILTER0;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			DOWN: <span class="keyword">begin</span></span><br><span class="line">				<span class="keyword">if</span>(Key_posedge)</span><br><span class="line">					next = FILTER1;</span><br><span class="line">				<span class="keyword">else</span> </span><br><span class="line">					next = DOWN;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			FILTER1: <span class="keyword">begin</span> </span><br><span class="line">				<span class="keyword">if</span>(cnt_full) </span><br><span class="line">					next = IDLE;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(Key_negedge)</span><br><span class="line">					next = DOWN;</span><br><span class="line">				<span class="keyword">else</span> </span><br><span class="line">					next = FILTER1;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">default</span>: next = IDLE;</span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//state flip-flops(sequential)</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> Clk <span class="keyword">or</span> <span class="keyword">negedge</span> Rst_n) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~Rst_n) state &lt;= IDLE;</span><br><span class="line">		<span class="keyword">else</span> state &lt;= next;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//output</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> Clk <span class="keyword">or</span> <span class="keyword">negedge</span> Rst_n) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~Rst_n)</span><br><span class="line">			Key_state &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">case</span>(next)</span><br><span class="line">			IDLE: <span class="keyword">begin</span> </span><br><span class="line">				en_cnt &lt;= <span class="number">1&#x27;b0</span>;		<span class="comment">//IDLE状态下计数器不计数</span></span><br><span class="line">				Key_state &lt;= <span class="number">1&#x27;b1</span>;	<span class="comment">//此时Key未被按下</span></span><br><span class="line">				Key_flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			FILTER0: <span class="keyword">begin</span></span><br><span class="line">				en_cnt &lt;= <span class="number">1&#x27;b1</span>;		<span class="comment">//FILTER0状态下计数器开始计数	</span></span><br><span class="line">				Key_state &lt;= <span class="number">1&#x27;b1</span>;	<span class="comment">//此时Key仍处于未被按下状态</span></span><br><span class="line">				Key_flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			DOWN: <span class="keyword">begin</span></span><br><span class="line">				en_cnt &lt;= <span class="number">1&#x27;b0</span>;		<span class="comment">//DOWN状态下计数器不计数	</span></span><br><span class="line">				Key_state &lt;= <span class="number">1&#x27;b0</span>;	<span class="comment">//此时Key已被按下</span></span><br><span class="line">				Key_flag &lt;= cnt_full;<span class="comment">//探测到Key被按下</span></span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			FILTER1: <span class="keyword">begin</span></span><br><span class="line">				en_cnt &lt;= <span class="number">1&#x27;b1</span>;		<span class="comment">//FILTER0状态下计数器开始计数	</span></span><br><span class="line">				Key_state &lt;= <span class="number">1&#x27;b0</span>;	<span class="comment">//此时Key仍处于被按下状态</span></span><br><span class="line">				Key_flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">				en_cnt &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">				Key_state &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">				Key_flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//assign Key_flag = Key_negedge;	//组合逻辑输出方式来输出Key_flag</span></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>
<h2 id="Testbench"><a href="#Testbench" class="headerlink" title="Testbench"></a>Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1 ns/ 1 ns</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> clk_period 20</span></span><br><span class="line"><span class="keyword">module</span> key_filter_vlg_tst();</span><br><span class="line">	<span class="comment">// test vector input registers</span></span><br><span class="line">	<span class="keyword">reg</span> Clk;</span><br><span class="line">	<span class="keyword">reg</span> Key_in;</span><br><span class="line">	<span class="keyword">reg</span> Rst_n;</span><br><span class="line">	<span class="comment">// wires</span></span><br><span class="line">	<span class="keyword">wire</span> Key_flag;</span><br><span class="line">	<span class="keyword">wire</span> Key_state;</span><br><span class="line">									</span><br><span class="line">	key_filter i1 (</span><br><span class="line">	<span class="comment">// port map - connection between master ports and signals/registers</span></span><br><span class="line">		<span class="variable">.Clk</span>(Clk),</span><br><span class="line">		<span class="variable">.Key_flag</span>(Key_flag),</span><br><span class="line">		<span class="variable">.Key_in</span>(Key_in),</span><br><span class="line">		<span class="variable">.Key_state</span>(Key_state),</span><br><span class="line">		<span class="variable">.Rst_n</span>(Rst_n)</span><br><span class="line">	);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		Clk = <span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="keyword">forever</span> <span class="variable">#(`clk_period/2)</span> Clk = ~Clk;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		Rst_n = <span class="number">1&#x27;b0</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="variable">#(`clk_period*10)</span> Rst_n = <span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="variable">#(`clk_period*10 + 1)</span>;</span><br><span class="line">		<span class="comment">//按下一次</span></span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">10000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">5_400_000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2600</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1300</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">200</span>;</span><br><span class="line">		</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">20_000_100</span>;</span><br><span class="line">		#<span class="number">10000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1400</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2600</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1300</span>;</span><br><span class="line">		</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">20_000_100</span>;</span><br><span class="line">		#<span class="number">10_000_000</span>;</span><br><span class="line">		<span class="comment">//second time</span></span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1400</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2600</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1300</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">200</span>;</span><br><span class="line">		</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">20_000_100</span>;</span><br><span class="line">		#<span class="number">10000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1400</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2600</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1300</span>;</span><br><span class="line">		</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">20_000_100</span>;</span><br><span class="line">		#<span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//third time</span></span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1400</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2600</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1300</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">200</span>;</span><br><span class="line">		</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">20_000_100</span>;</span><br><span class="line">		#<span class="number">10000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2000</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1400</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">2600</span>;</span><br><span class="line">		Key_in = <span class="number">1&#x27;b0</span>;#<span class="number">1300</span>;</span><br><span class="line">		</span><br><span class="line">		Key_in = <span class="number">1&#x27;b1</span>;#<span class="number">20_000_100</span>;</span><br><span class="line">		#<span class="number">10000</span>;</span><br><span class="line">		<span class="built_in">$stop</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>
<h1 id="仿真模型"><a href="#仿真模型" class="headerlink" title="仿真模型"></a>仿真模型</h1><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>{$random}默认是32位的随机数，根据自己的需要来取余计算，例如：需要0 ~ 65535的随机数，则可：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span>	[<span class="number">15</span>:<span class="number">0</span>] myrand;</span><br><span class="line"><span class="keyword">initial</span> myrand = &#123;<span class="built_in">$random</span>&#125;%<span class="number">65536</span>;</span><br></pre></td></tr></table></figure>
<p>其中，myrand就是所需的随机数。</p>
<h2 id="task"><a href="#task" class="headerlink" title="task"></a>task</h2><p>定义一个task如下所示</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] myrand;</span><br><span class="line"><span class="keyword">task</span> press_key;</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">repeat</span>(<span class="number">50</span>) <span class="keyword">begin</span></span><br><span class="line">			myrand = &#123;<span class="built_in">$random</span>&#125;%<span class="number">65536</span>;</span><br><span class="line">			#myrand key_in = ~key_in;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		key_in = <span class="number">0</span>;</span><br><span class="line">		#<span class="number">50_000_000</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">repeat</span>(<span class="number">50</span>) <span class="keyword">begin</span></span><br><span class="line">			myrand = &#123;<span class="built_in">$random</span>&#125;%<span class="number">65536</span>;</span><br><span class="line">			#myrand key_in = ~key_in;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		key_in = <span class="number">0</span>;</span><br><span class="line">		#<span class="number">50_000_000</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure>
<p>然后就可以直接在testbench中使用</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">press_key;</span><br></pre></td></tr></table></figure>
<h2 id="仿真模型-1"><a href="#仿真模型-1" class="headerlink" title="仿真模型"></a>仿真模型</h2><p>新建一个key_module文件</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1 ns/1 ps</span></span><br><span class="line"><span class="keyword">module</span> key_module(key);</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> key;</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] myrand;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		key = <span class="number">1&#x27;b1</span>;</span><br><span class="line">		press_key;</span><br><span class="line">		#<span class="number">10000</span>;</span><br><span class="line">		press_key;</span><br><span class="line">		#<span class="number">10000</span>;</span><br><span class="line">		press_key;</span><br><span class="line">		<span class="built_in">$stop</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">task</span> press_key;</span><br><span class="line">		<span class="keyword">begin</span></span><br><span class="line">			<span class="keyword">repeat</span>(<span class="number">50</span>) <span class="keyword">begin</span></span><br><span class="line">				myrand = &#123;<span class="built_in">$random</span>&#125;%<span class="number">65536</span>;</span><br><span class="line">				#myrand key = ~key;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			key = <span class="number">0</span>;</span><br><span class="line">			#<span class="number">50_000_000</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">repeat</span>(<span class="number">50</span>) <span class="keyword">begin</span></span><br><span class="line">				myrand = &#123;<span class="built_in">$random</span>&#125;%<span class="number">65536</span>;</span><br><span class="line">				#myrand key = ~key;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			key = <span class="number">1</span>;</span><br><span class="line">			#<span class="number">50_000_000</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>
<p>使用时需将该文件添加到test bench中，test bench主文件为</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1 ns/ 1 ns</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> clk_period 20</span></span><br><span class="line"><span class="keyword">module</span> key_filter_vlg_tst();</span><br><span class="line">	<span class="comment">// test vector input registers</span></span><br><span class="line">	<span class="keyword">reg</span> Clk;</span><br><span class="line">	<span class="keyword">wire</span> Key_in;</span><br><span class="line">	<span class="keyword">reg</span> Rst_n;</span><br><span class="line">	<span class="comment">// wires</span></span><br><span class="line">	<span class="keyword">wire</span> Key_flag;</span><br><span class="line">	<span class="keyword">wire</span> Key_state;</span><br><span class="line">									</span><br><span class="line">	key_filter i1 (</span><br><span class="line">	<span class="comment">// port map - connection between master ports and signals/registers</span></span><br><span class="line">		<span class="variable">.Clk</span>(Clk),</span><br><span class="line">		<span class="variable">.Key_flag</span>(Key_flag),</span><br><span class="line">		<span class="variable">.Key_in</span>(Key_in),</span><br><span class="line">		<span class="variable">.Key_state</span>(Key_state),</span><br><span class="line">		<span class="variable">.Rst_n</span>(Rst_n)</span><br><span class="line">	);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		Clk = <span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="keyword">forever</span> <span class="variable">#(`clk_period/2)</span> Clk = ~Clk;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		Rst_n = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="variable">#(`clk_period*10)</span> Rst_n = <span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="variable">#(`clk_period*10 + 1)</span> ;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	key_module u1(<span class="variable">.key</span>(Key_in));</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>FPGA</tag>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>学习FPGA（四）</title>
    <url>/2022/04/17/FPGA/FPGA-4/</url>
    <content><![CDATA[<h1 id="实现FPGA驱动数码管动态显示"><a href="#实现FPGA驱动数码管动态显示" class="headerlink" title="实现FPGA驱动数码管动态显示"></a>实现FPGA驱动数码管动态显示</h1><p>知识点：</p>
<ol>
<li>数码管动态扫描实现。</li>
<li>In system sources and probes editor (ISSP)调试工具的使用。</li>
</ol>
<h2 id="工程代码"><a href="#工程代码" class="headerlink" title="工程代码"></a>工程代码</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现FPGA驱动数码管动态显示</span></span><br><span class="line"><span class="keyword">module</span> digital_display(Clk, Rst_n, En, disp_data, sel, seg);</span><br><span class="line">	<span class="keyword">input</span> Clk;					<span class="comment">//50M，一个周期为20ns</span></span><br><span class="line">	<span class="keyword">input</span> Rst_n;</span><br><span class="line">	<span class="keyword">input</span> En;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] disp_data;	<span class="comment">//输入要求显示的内容</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] sel;			<span class="comment">//数码管位选（当前要显示的数码管）</span></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">6</span>:<span class="number">0</span>] seg;			<span class="comment">//数码管段选（当前要显示的内容）</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//divider module</span></span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">14</span>:<span class="number">0</span>] divider_cnt;	<span class="comment">//产生1ms的时钟，每0.5ms时钟信号需要翻转一次，0.5ms/20ns=25_000=16&#x27;b0110_0001_1010_1000，故需要15位计数器</span></span><br><span class="line">	<span class="keyword">reg</span> Clk_1K;</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> Clk <span class="keyword">or</span> <span class="keyword">negedge</span> Rst_n) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~Rst_n) </span><br><span class="line">			divider_cnt &lt;= <span class="number">15&#x27;d0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(~En) </span><br><span class="line">			divider_cnt &lt;= <span class="number">15&#x27;d0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(divider_cnt== <span class="number">15&#x27;d24_999</span>) </span><br><span class="line">			divider_cnt &lt;= <span class="number">15&#x27;d0</span>;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			divider_cnt &lt;= divider_cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> Clk <span class="keyword">or</span> <span class="keyword">negedge</span> Rst_n) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~Rst_n) </span><br><span class="line">			Clk_1K &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(~En) </span><br><span class="line">			Clk_1K &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(divider_cnt== <span class="number">15&#x27;d24_999</span>) </span><br><span class="line">			Clk_1K &lt;= ~Clk_1K;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			Clk_1K &lt;= Clk_1K;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">//shift8 module</span></span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] sel_r;</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> Clk_1K <span class="keyword">or</span> <span class="keyword">negedge</span> Rst_n) <span class="keyword">begin</span>	<span class="comment">//注意，分频器的输出信号作为D触发器的时钟信号，在大型设计中是不被允许的，此处设计为数码管驱动模块，影响不大，允许存在这样的毛刺</span></span><br><span class="line">		<span class="keyword">if</span>(~Rst_n)</span><br><span class="line">			sel_r &lt;= <span class="number">8&#x27;b0000_0001</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(sel_r == <span class="number">8&#x27;b1000_0000</span>)</span><br><span class="line">			sel_r &lt;= <span class="number">8&#x27;b0000_0001</span>;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			sel_r &lt;= &#123;sel_r[<span class="number">6</span>:<span class="number">0</span>],<span class="number">1&#x27;b0</span>&#125;;	<span class="comment">//此句也可改为	sel_r &lt;= sel_r &lt;&lt; 1;</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//MUX8 (combitional)</span></span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] data_tmp;</span><br><span class="line">	<span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">case</span>(sel_r)</span><br><span class="line">			<span class="number">8&#x27;b0000_0001</span>: data_tmp = disp_data[<span class="number">3</span>:<span class="number">0</span>];</span><br><span class="line">			<span class="number">8&#x27;b0000_0010</span>: data_tmp = disp_data[<span class="number">7</span>:<span class="number">4</span>];</span><br><span class="line">			<span class="number">8&#x27;b0000_0100</span>: data_tmp = disp_data[<span class="number">11</span>:<span class="number">8</span>];</span><br><span class="line">			<span class="number">8&#x27;b0000_1000</span>: data_tmp = disp_data[<span class="number">15</span>:<span class="number">12</span>];</span><br><span class="line">			</span><br><span class="line">			<span class="number">8&#x27;b0001_0000</span>: data_tmp = disp_data[<span class="number">19</span>:<span class="number">16</span>];</span><br><span class="line">			<span class="number">8&#x27;b0010_0000</span>: data_tmp = disp_data[<span class="number">23</span>:<span class="number">20</span>];</span><br><span class="line">			<span class="number">8&#x27;b0100_0000</span>: data_tmp = disp_data[<span class="number">27</span>:<span class="number">24</span>];</span><br><span class="line">			<span class="number">8&#x27;b1000_0000</span>: data_tmp = disp_data[<span class="number">31</span>:<span class="number">28</span>];</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">default</span>: data_tmp = <span class="number">4&#x27;b0000</span>;</span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//MUX2 (combitional)</span></span><br><span class="line">	<span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~En)</span><br><span class="line">			sel = <span class="number">8&#x27;b0000_0000</span>;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			sel = sel_r;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//LUT (combitional)</span></span><br><span class="line">	<span class="comment">//注意：数码管灯段在输入为0时亮起，输入为1时熄灭；</span></span><br><span class="line">	<span class="comment">//h段为最高位，a段为最低位；</span></span><br><span class="line">	<span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">case</span>(data_tmp)</span><br><span class="line">			<span class="number">4&#x27;b0000</span>: seg = <span class="number">7&#x27;b100_0000</span>;	<span class="comment">//0</span></span><br><span class="line">			<span class="number">4&#x27;b0001</span>: seg = <span class="number">7&#x27;b111_1001</span>;	<span class="comment">//1</span></span><br><span class="line">			<span class="number">4&#x27;b0010</span>: seg = <span class="number">7&#x27;b010_0100</span>;	<span class="comment">//2</span></span><br><span class="line">			<span class="number">4&#x27;b0011</span>: seg = <span class="number">7&#x27;b011_0000</span>;	<span class="comment">//3</span></span><br><span class="line">			</span><br><span class="line">			<span class="number">4&#x27;b0100</span>: seg = <span class="number">7&#x27;b001_1001</span>;	<span class="comment">//4</span></span><br><span class="line">			<span class="number">4&#x27;b0101</span>: seg = <span class="number">7&#x27;b001_0010</span>;	<span class="comment">//5</span></span><br><span class="line">			<span class="number">4&#x27;b0110</span>: seg = <span class="number">7&#x27;b000_0010</span>;	<span class="comment">//6</span></span><br><span class="line">			<span class="number">4&#x27;b0111</span>: seg = <span class="number">7&#x27;b111_1000</span>;	<span class="comment">//7</span></span><br><span class="line">			</span><br><span class="line">			<span class="number">4&#x27;b1000</span>: seg = <span class="number">7&#x27;b000_0000</span>;	<span class="comment">//8</span></span><br><span class="line">			<span class="number">4&#x27;b1001</span>: seg = <span class="number">7&#x27;b001_0000</span>;	<span class="comment">//9</span></span><br><span class="line">			<span class="number">4&#x27;b1010</span>: seg = <span class="number">7&#x27;b000_1000</span>;	<span class="comment">//a</span></span><br><span class="line">			<span class="number">4&#x27;b1011</span>: seg = <span class="number">7&#x27;b000_0011</span>;	<span class="comment">//b</span></span><br><span class="line">			</span><br><span class="line">			<span class="number">4&#x27;b1100</span>: seg = <span class="number">7&#x27;b100_0110</span>;	<span class="comment">//c</span></span><br><span class="line">			<span class="number">4&#x27;b1101</span>: seg = <span class="number">7&#x27;b010_0001</span>;	<span class="comment">//d</span></span><br><span class="line">			<span class="number">4&#x27;b1110</span>: seg = <span class="number">7&#x27;b000_0110</span>;	<span class="comment">//e</span></span><br><span class="line">			<span class="number">4&#x27;b1111</span>: seg = <span class="number">7&#x27;b000_1110</span>;	<span class="comment">//f</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">default</span>: seg = <span class="number">7&#x27;b111_1111</span>;	<span class="comment">//全灭</span></span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>
<h2 id="TestBench"><a href="#TestBench" class="headerlink" title="TestBench"></a>TestBench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1 ns/ 1 ps</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> clk_period 20</span></span><br><span class="line"><span class="keyword">module</span> digital_display_vlg_tst();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">reg</span> Clk;</span><br><span class="line">	<span class="keyword">reg</span> En;</span><br><span class="line">	<span class="keyword">reg</span> Rst_n;</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] disp_data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">wire</span> [<span class="number">6</span>:<span class="number">0</span>]  seg;</span><br><span class="line">	<span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>]  sel;</span><br><span class="line"></span><br><span class="line">	digital_display u1 (</span><br><span class="line">		<span class="variable">.Clk</span>(Clk),</span><br><span class="line">		<span class="variable">.En</span>(En),</span><br><span class="line">		<span class="variable">.Rst_n</span>(Rst_n),</span><br><span class="line">		<span class="variable">.disp_data</span>(disp_data),</span><br><span class="line">		<span class="variable">.seg</span>(seg),</span><br><span class="line">		<span class="variable">.sel</span>(sel)</span><br><span class="line">	);</span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		Clk = <span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="keyword">forever</span> <span class="variable">#(`clk_period/2)</span> Clk = ~Clk;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		Rst_n = <span class="number">1&#x27;b0</span>;</span><br><span class="line">		En = <span class="number">1&#x27;b1</span>;</span><br><span class="line">		disp_data = <span class="number">32&#x27;h12345678</span>;</span><br><span class="line">		<span class="variable">#(`clk_period*20)</span>;</span><br><span class="line">		Rst_n = <span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="variable">#(`clk_period*20)</span>;</span><br><span class="line">		#<span class="number">20_000_000</span>;</span><br><span class="line">		disp_data = <span class="number">32&#x27;h87654321</span>;</span><br><span class="line">		#<span class="number">20_000_000</span>;</span><br><span class="line">		disp_data = <span class="number">32&#x27;h89abcdef</span>;</span><br><span class="line">		#<span class="number">20_000_000</span>;</span><br><span class="line">		<span class="built_in">$stop</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>得到的仿真波形：</p>
<img src="/2022/04/17/FPGA/FPGA-4/1650940716028.png" class="" width="1650940716028">

<h2 id="ISSP"><a href="#ISSP" class="headerlink" title="ISSP"></a>ISSP</h2><p>使用IP核</p>
<img src="/2022/04/17/FPGA/FPGA-4/1650940825468.png" class="" width="1650940825468">

<ol>
<li>可以作为探针；</li>
<li>可以作为驱动源（数据源）；</li>
</ol>
<p>本次实验需要用到的探针宽度为0，数据源宽度为32</p>
<img src="/2022/04/17/FPGA/FPGA-4/1650940889217.png" class="" width="1650940889217">

<p>完成后，将文件烧录到开发板上，在Tools中找到In-System Sources and Probes Editor</p>
<img src="/2022/04/17/FPGA/FPGA-4/1650940973799.png" class="" width="1650940973799">

<img src="/2022/04/17/FPGA/FPGA-4/1650940980678.png" class="" width="1650940980678">

<p>设置改成十六进制，之后直接在data里面设置需要的数据，就可以将数据输入到开发板上</p>
]]></content>
      <tags>
        <tag>FPGA</tag>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>学习FPGA（五）——异步FIFO</title>
    <url>/2022/04/30/FPGA/FPGA-5-AsynchronousFIFO/</url>
    <content><![CDATA[<h1 id="异步FIFO"><a href="#异步FIFO" class="headerlink" title="异步FIFO"></a>异步FIFO</h1><p>​         <img src="/2022/04/30/FPGA/FPGA-5-AsynchronousFIFO/clip_image002-1651319177961.jpg" class="" title="img">  </p>
<p>异步FIFO代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Asynchronous_FIFO#(<span class="keyword">parameter</span> DEPTH = <span class="number">16</span>, <span class="keyword">parameter</span> WIDTH = <span class="number">8</span>)(wclk, wrstn, winc, wdata, wfull, rclk, rrstn, rinc, rdata, rempty);</span><br><span class="line">	<span class="comment">//write module I/O</span></span><br><span class="line">	<span class="keyword">input</span> wclk;</span><br><span class="line">	<span class="keyword">input</span> wrstn;</span><br><span class="line">	<span class="keyword">input</span> winc;			<span class="comment">//enable signal</span></span><br><span class="line">	<span class="keyword">input</span> [WIDTH-<span class="number">1</span> : <span class="number">0</span>] wdata;</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> wfull;</span><br><span class="line">	<span class="comment">//read module I/O</span></span><br><span class="line">	<span class="keyword">input</span> rclk;</span><br><span class="line">	<span class="keyword">input</span> rrstn;</span><br><span class="line">	<span class="keyword">input</span> rinc;			<span class="comment">//enable signal</span></span><br><span class="line">	<span class="keyword">output</span> [WIDTH-<span class="number">1</span> : <span class="number">0</span>] rdata;</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> rempty;</span><br><span class="line">	<span class="comment">//set enable signal</span></span><br><span class="line">	<span class="keyword">wire</span> wenc, renc;</span><br><span class="line">	<span class="keyword">assign</span> wenc = winc &amp; !wfull;</span><br><span class="line">	<span class="keyword">assign</span> renc = rinc &amp; !rempty;</span><br><span class="line">	<span class="comment">//adress counter *****************************************************************************************</span></span><br><span class="line">	<span class="keyword">reg</span> [<span class="built_in">$clog2</span>(DEPTH) : <span class="number">0</span>] waddr, raddr;</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> wclk <span class="keyword">or</span> <span class="keyword">negedge</span> wrstn) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(!wrstn) </span><br><span class="line">			waddr &lt;= <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(wenc)</span><br><span class="line">			waddr &lt;= waddr + <span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> rclk <span class="keyword">or</span> <span class="keyword">negedge</span> rrstn) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(!rrstn) </span><br><span class="line">			raddr &lt;= <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(renc)</span><br><span class="line">			raddr &lt;= raddr + <span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">//binary to gray *****************************************************************************************</span></span><br><span class="line">	<span class="keyword">reg</span> [<span class="built_in">$clog2</span>(DEPTH) : <span class="number">0</span>] waddr_gray, raddr_gray;</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> wclk <span class="keyword">or</span> <span class="keyword">negedge</span> wrstn) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(!wrstn) </span><br><span class="line">			waddr_gray &lt;= <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(wenc)</span><br><span class="line">			waddr_gray &lt;= (waddr + <span class="number">1&#x27;b1</span>) ^ (waddr + <span class="number">1&#x27;b1</span>)&gt;&gt;<span class="number">1</span>;	<span class="comment">//保证gray code与当前的binary code同步</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> rclk <span class="keyword">or</span> <span class="keyword">negedge</span> rrstn) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(!rrstn) </span><br><span class="line">			raddr_gray &lt;= <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(renc)</span><br><span class="line">			raddr_gray &lt;= (raddr + <span class="number">1&#x27;b1</span>) ^ (raddr + <span class="number">1&#x27;b1</span>)&gt;&gt;<span class="number">1</span>;	<span class="comment">//保证gray code与当前的binary code同步</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">//synchonize *****************************************************************************************</span></span><br><span class="line">	<span class="keyword">reg</span> [<span class="built_in">$clog2</span>(DEPTH) : <span class="number">0</span>] raddr_gray_temp1, raddr_gray_temp2;</span><br><span class="line">	<span class="keyword">reg</span> [<span class="built_in">$clog2</span>(DEPTH) : <span class="number">0</span>] waddr_gray_temp1, waddr_gray_temp2;</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> wclk <span class="keyword">or</span> <span class="keyword">negedge</span> wrstn) <span class="keyword">begin</span>		<span class="comment">//将raddr_gray同步到wclk</span></span><br><span class="line">		<span class="keyword">if</span>(!wrstn) <span class="keyword">begin</span> </span><br><span class="line">			raddr_gray_temp1 &lt;= <span class="number">0</span>;</span><br><span class="line">			raddr_gray_temp2 &lt;= <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">			raddr_gray_temp1 &lt;= raddr_gray;</span><br><span class="line">			raddr_gray_temp2 &lt;= raddr_gray_temp1;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> rclk <span class="keyword">or</span> <span class="keyword">negedge</span> rrstn) <span class="keyword">begin</span>		<span class="comment">//将raddr_gray同步到wclk</span></span><br><span class="line">		<span class="keyword">if</span>(!rrstn) <span class="keyword">begin</span> </span><br><span class="line">			waddr_gray_temp1 &lt;= <span class="number">0</span>;</span><br><span class="line">			waddr_gray_temp2 &lt;= <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">			waddr_gray_temp1 &lt;= waddr_gray;</span><br><span class="line">			waddr_gray_temp2 &lt;= waddr_gray_temp1;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">//full or empty *****************************************************************************************</span></span><br><span class="line">	<span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(!wrstn)</span><br><span class="line">			wfull = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(&#123;~waddr_gray[<span class="built_in">$clog2</span>(DEPTH) : <span class="built_in">$clog2</span>(DEPTH) - <span class="number">1</span>], waddr_gray[<span class="built_in">$clog2</span>(DEPTH) - <span class="number">2</span> : <span class="number">0</span>]&#125; == raddr_gray_temp2)		<span class="comment">//gray code最高两位不同而其他位全等时，写满</span></span><br><span class="line">			wfull = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			wfull = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(!rrstn) </span><br><span class="line">			rempty = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(raddr_gray == waddr_gray_temp2)		<span class="comment">//gray code全等时，读空</span></span><br><span class="line">			rempty = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			rempty = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">//RAM *****************************************************************************************</span></span><br><span class="line">	FIFO_DUAL_RAM RAM1(</span><br><span class="line">		<span class="variable">.wclk</span>(wclk), </span><br><span class="line">		<span class="variable">.wenc</span>(wenc), </span><br><span class="line">		<span class="variable">.waddr</span>(waddr), </span><br><span class="line">		<span class="variable">.wdata</span>(wdata), </span><br><span class="line">		<span class="variable">.rclk</span>(rclk), </span><br><span class="line">		<span class="variable">.renc</span>(renc), </span><br><span class="line">		<span class="variable">.raddr</span>(raddr), </span><br><span class="line">		<span class="variable">.rdata</span>(rdata)</span><br><span class="line">	);</span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>

<p>RAM代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FIFO_DUAL_RAM需要的端口有时钟、地址、使能、数据端，读、写模块各四个端口，复位端看需求</span></span><br><span class="line"><span class="keyword">module</span> FIFO_DUAL_RAM#(<span class="keyword">parameter</span> DEPTH = <span class="number">16</span>, <span class="keyword">parameter</span> WIDTH = <span class="number">8</span>)(wclk, wenc, waddr, wdata, rclk, renc, raddr, rdata);</span><br><span class="line">	<span class="keyword">input</span> wclk;</span><br><span class="line">	<span class="keyword">input</span> wenc;</span><br><span class="line">	<span class="keyword">input</span> [<span class="built_in">$clog2</span>(DEPTH) - <span class="number">1</span> : <span class="number">0</span>] waddr;</span><br><span class="line">	<span class="keyword">input</span> [WIDTH - <span class="number">1</span> : <span class="number">0</span>] wdata;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">input</span> rclk;</span><br><span class="line">	<span class="keyword">input</span> renc;</span><br><span class="line">	<span class="keyword">input</span> [<span class="built_in">$clog2</span>(DEPTH) - <span class="number">1</span> : <span class="number">0</span>] raddr;</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> [WIDTH - <span class="number">1</span> : <span class="number">0</span>] rdata;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//write</span></span><br><span class="line">	<span class="keyword">reg</span> [WIDTH-<span class="number">1</span> : <span class="number">0</span>] RAM_MEM [<span class="number">0</span> : DEPTH - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> wclk) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(wenc)</span><br><span class="line">			RAM_MEM[waddr] &lt;= wdata;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">//read</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> rclk) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(renc)</span><br><span class="line">			rdata &lt;= RAM_MEM[raddr];</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>

<p>写入和读出的数据均正常，没有出现数据覆盖：</p>
<img src="/2022/04/30/FPGA/FPGA-5-AsynchronousFIFO/1651334164746.png" class="" width="1651334164746">

<p>波形总览：</p>
<img src="/2022/04/30/FPGA/FPGA-5-AsynchronousFIFO/1651336587973.png" class="" width="1651336587973">

<h3 id="FIFO-IP核"><a href="#FIFO-IP核" class="headerlink" title="FIFO IP核"></a>FIFO IP核</h3><p>利用quartus的IP核生成一个参数基本相同的IP核，对同一个testbench得到的波形如下图：</p>
<img src="/2022/04/30/FPGA/FPGA-5-AsynchronousFIFO/1651336123088.png" class="" width="1651336123088">



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>自己写的异步FIFO从RTL级仿真的图像来看勉强能实现双端口输入输出的功能，但也有很多瑕疵，比如没有初始化RAM等。</p>
]]></content>
      <tags>
        <tag>FPGA</tag>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>学习FPGA（六）——I2C协议</title>
    <url>/2022/05/10/FPGA/FPGA-6-I2C/</url>
    <content><![CDATA[<h1 id="I2C协议"><a href="#I2C协议" class="headerlink" title="I2C协议"></a>I2C协议</h1><img src="/2022/05/10/FPGA/FPGA-6-I2C/1652164312734.png" class="" width="1652164312734">

<p>主控芯片向总线上发出指令，<strong>芯片自己判断是否发给自己（通过地址判断）</strong>，<strong>读操作、写操作</strong></p>
]]></content>
      <tags>
        <tag>FPGA</tag>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>学习FPGA过程中遇到的一些问题</title>
    <url>/2022/05/03/FPGA/FPGA-note/</url>
    <content><![CDATA[<h3 id="quartus门级仿真出错"><a href="#quartus门级仿真出错" class="headerlink" title="quartus门级仿真出错"></a>quartus门级仿真出错</h3><p>在确认verilog代码没有问题，testbench代码没有问题，RTL级仿真正常后，门级仿真中许多信号都出现了红线（此时testbench中时间单位为1 ns）：</p>
<p>（没有图了，我没办法复现出错的波形了，我也不知道我改了什么了，怎么这么玄学？！）</p>
<p>原因可能是在testbench中设定的时间单位太小，导致在门级仿真的延迟时间内，信号就已经发生了变化，即激励信号维持的时间没有大于触发器的建立时间和保持时间与逻辑门的延迟时间之和。</p>
<p>下面是将testbench中时间单位改成1 ms后的波形：</p>
<img src="/2022/05/03/FPGA/FPGA-note/1651555105786.png" class="" width="1651555105786">



<p>放大可以看出：</p>
<img src="/2022/05/03/FPGA/FPGA-note/1651555205837.png" class="" width="1651555205837">

<p>上图中第二行为clk信号，可以看出，触发器从接受时钟上升沿直到变化成下一个稳态经过了约9ns左右。</p>
]]></content>
      <tags>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>C++游戏开发（一）</title>
    <url>/2022/05/12/cpp/cpp-game-1/</url>
    <content><![CDATA[<h2 id="图形库"><a href="#图形库" class="headerlink" title="图形库"></a>图形库</h2><h4 id="1、easyx"><a href="#1、easyx" class="headerlink" title="1、easyx"></a>1、easyx</h4><p>上手简单，游戏效果较差；</p>
<h4 id="2、SDL"><a href="#2、SDL" class="headerlink" title="2、SDL"></a>2、SDL</h4><p>专业游戏库，使用不方便；</p>
<h4 id="3、SFML库"><a href="#3、SFML库" class="headerlink" title="3、SFML库"></a>3、SFML库</h4><p>专业跨平台2D库，使用方便，功能强大；</p>
<h4 id="4、Qt"><a href="#4、Qt" class="headerlink" title="4、Qt"></a>4、Qt</h4><p>产品级跨平台库游戏库</p>
<h4 id="5、UE4"><a href="#5、UE4" class="headerlink" title="5、UE4"></a>5、UE4</h4><p>门槛高，需要熟练使用C++</p>
<h2 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h2><p>1、搭建环境</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++笔记（一）——变量和复合类型</title>
    <url>/2022/04/18/cpp/cpp-note-1/</url>
    <content><![CDATA[<h2 id="不同初始化方式的区别"><a href="#不同初始化方式的区别" class="headerlink" title="不同初始化方式的区别"></a>不同初始化方式的区别</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">double</span> ld = <span class="number">3.1415926536</span>;</span><br><span class="line">	<span class="type">int</span> a&#123; ld &#125;, b = &#123; ld &#125;;  <span class="comment">//错误：会提示error C2397: 从“long double”转换到“int”需要收缩转换</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">c</span><span class="params">(ld)</span>, d </span>= ld;<span class="comment">//能够完成编译，且确实丢失了部分值，c和d输出均为3</span></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; c &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于局部变量来说，初始化很重要；在编写某个类的时候，尽量申明当该类的某个对象未被显式初始化时，生成一个合适的默认值。</p>
<h2 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h2><p>C++支持分离式编译(separate compilation)</p>
<p>声明(declaration)：使得某个名字为程序所知，即这个变量已经在别处定义了，我现在拿来用。（声明一个其他地方定义过的全局变量）</p>
<p>定义(definition)：创建与名字关联的实体。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;	<span class="comment">//声明i而非定义i，但如果显式初始化后则会抵消了extern的作用</span></span><br><span class="line"><span class="type">int</span> j;	<span class="comment">//定义j</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">double</span> pi = <span class="number">3.1416</span>;	<span class="comment">//定义pi，且初始化为3.1416</span></span><br></pre></td></tr></table></figure>
<p>在函数内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。</p>
<p>ps: C++是一种静态类型（statically typed）语言，其含义是在编译阶段执行类型检查（type checking）。如果编译器发现数据类型不支持要执行的运算，则会报错且不会生成任何可执行的程序。程序越复杂，静态类型检查越有助于发现问题。这要求我们在使用某个变量之前必须声明其类型。</p>
<h2 id="标识符-identifier"><a href="#标识符-identifier" class="headerlink" title="标识符(identifier)"></a>标识符(identifier)</h2><p>变量命名规范：</p>
<ol>
<li>标识符要体现实际含义；</li>
<li>变量名一般用小写字母，如index；</li>
<li>用户自定义的类名一般以大写字母开头，如Sales_item；</li>
<li>如果标识符由多个单词组成，则单词间要有明显区分，如student_loan或studentLoan；</li>
</ol>
<p>建议：当第一次使用变量时再定义它，即随用随定义</p>
<ol>
<li>有助于找到变量的定义；</li>
<li>可以赋予一个合理的初始值；</li>
<li>防止在程序一开始初始化一堆未用到的变量，从而拖慢运行速度；</li>
</ol>
<h2 id="作用域-scope"><a href="#作用域-scope" class="headerlink" title="作用域(scope)"></a>作用域(scope)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> i = <span class="number">420</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; i++)	<span class="comment">//for()中的i作用域仅在()之中</span></span><br><span class="line">		sum += i;</span><br><span class="line">	cout &lt;&lt; i &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; sum &lt;&lt; endl;	<span class="comment">//得到的输出为420	45</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> i = <span class="number">420</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">100</span>;	<span class="comment">//覆盖了全局变量i</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; i++)	<span class="comment">//for()中的i作用域仅在()之中</span></span><br><span class="line">		sum += i;</span><br><span class="line">	cout &lt;&lt; ::i &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; sum &lt;&lt; endl;	<span class="comment">//得到的输出为420 100 45</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="引用-reference"><a href="#引用-reference" class="headerlink" title="引用(reference)"></a>引用(reference)</h2><p>引用并非对象，而是为一个已经存在的对象所起的别名，不需要独立的内存空间；</p>
<p>引用初始化后，无法再令该引用重新绑定到另一个对象，因此引用必须初始化；</p>
<p>因为引用并非一个对象，所以不能定义引用的引用；</p>
<p>引用的类型必须与引用绑定的对象严格匹配。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line">	<span class="type">int</span> &amp;refVal0 = ival;	<span class="comment">//正确</span></span><br><span class="line">	<span class="type">int</span> &amp;refVal1 = refVal;	<span class="comment">//正确：实际上是以与引用绑定的对象再定义了另一个引用</span></span><br><span class="line">	<span class="type">int</span> &amp;refVal2;	<span class="comment">//错误：没有初始化引用</span></span><br><span class="line">	<span class="type">int</span> &amp;refVal3 = &amp;refVal1;	<span class="comment">//错误：不能定义引用的引用</span></span><br><span class="line">	<span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line">	<span class="type">int</span> &amp;refVal4 = dval;	<span class="comment">//错误：类型不匹配</span></span><br><span class="line">	refVal = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针-pointer"><a href="#指针-pointer" class="headerlink" title="指针(pointer)"></a>指针(pointer)</h2><p>指针本身就是一个对象，需要独立的内存空间;</p>
<p>指针初始化后，可以通过赋值来改变指针的值或指针指向的对象；</p>
<p>因为指针是一个对象，所以可以定义指针的指针；</p>
<p>指针的类型必须与指针的对象严格匹配。</p>
<p>指针的值（即地址）属于下列4中状态之一：</p>
<ol>
<li>指向一个对象</li>
<li>指向紧邻对象所占空间的下一个位置</li>
<li>空指针，没有指向任何对象</li>
<li>无效指针，上述情况之外的其他值</li>
</ol>
<p>建议：</p>
<ol>
<li>初始化所有指针；</li>
<li>尽量定义了对象之后再定义指向它的指针；</li>
<li>如果实在不清楚指针应该指向何处，就先初始化为nullptr或者0；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ival1 = <span class="number">0</span>, ival2 = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *pi = &amp;ival1;</span><br><span class="line">pi = &amp;ival2;	<span class="comment">//pi的值被改变，现在pi指向了ival，或者说pi的值变成了存放ival的地址</span></span><br><span class="line">*pi = <span class="number">0</span>;	<span class="comment">//ival的值被改变，指针pi并没有改变</span></span><br></pre></td></tr></table></figure>
<p><strong>赋值改变的永远是&#x3D;左侧的对象！！！</strong></p>
<p>void* 指针是一种特殊的指针类型，可以存放任意对象的地址。它可以用于和其他指针比较、作为函数的输入输出、赋值给另一个void* 指针。但是，不能对它所指向的对象进行操作，因为我们并不知道这个对象到底是什么类型。</p>
<p>概括来讲，void* 的视角来看，内存空间仅仅只是内存空间，没办法访问内存空间中所存的对象。</p>
<p><em>练习2.18</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ival1 = <span class="number">1</span>, ival2 = <span class="number">1</span>, ival3 = <span class="number">4</span>;</span><br><span class="line">	<span class="type">int</span>* p1 = &amp;ival1, * p2 = &amp;ival2;</span><br><span class="line">	<span class="comment">//改变指针的值</span></span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; ival1 &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; ival3 &lt;&lt; endl;</span><br><span class="line">	p1 = &amp;ival3;</span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; ival1 &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; ival3 &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//改变指针指向对象的值</span></span><br><span class="line">	cout &lt;&lt; p2 &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; *p2 &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; ival2 &lt;&lt; endl;</span><br><span class="line">	*p2 = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; p2 &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; *p2 &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; ival2 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>练习2.23</em></p>
<p>设给定指针为p</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(p) ival = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> ival = <span class="number">2</span>;	<span class="comment">//这个if...else...可以判断出p是否有一个合法的值（即合法地址）</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++笔记（十）——语句</title>
    <url>/2022/05/07/cpp/cpp-note-10/</url>
    <content><![CDATA[<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><p>和绝大多是语言一样，C++提供条件执行语句、重复执行相同代码的循环语句和用于中断当前控制流的跳转语句。</p>
<h2 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h2><p>在一个语法上需要而逻辑上不需要语句的地方会用到空语句<code> ;</code></p>
<p>在一个语法上只需要一条语句而逻辑上需要多条语句的地方会用到块<code>&#123; /*many statements*/ &#125;</code>，一个块就是一个作用域，<u>块的后面不需要分号</u>。</p>
<h2 id="语句作用域"><a href="#语句作用域" class="headerlink" title="语句作用域"></a>语句作用域</h2><p>在if、switch、while、和for语句中的控制结构内定义的变量，其作用域仅在相应语句的内部</p>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p><em>练习5.5</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; svec = &#123; <span class="string">&quot;E&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;B&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A++&quot;</span> &#125;;</span><br><span class="line"><span class="type">int</span> grade = <span class="number">0</span>;</span><br><span class="line">string lettergrade;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; grade &amp;&amp; grade &lt;= <span class="number">100</span> &amp;&amp; grade &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> temp = grade / <span class="number">10</span>, temp2 = grade % <span class="number">10</span>;		<span class="comment">//temp表示分数百十位，temp2表示个位</span></span><br><span class="line">    <span class="keyword">if</span> (temp &lt; <span class="number">6</span>)</span><br><span class="line">        cout &lt;&lt; svec[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= <span class="number">5</span> &amp;&amp; temp &lt; svec.<span class="built_in">size</span>() + <span class="number">5</span>)</span><br><span class="line">            cout &lt;&lt; svec[temp - <span class="number">5</span>];</span><br><span class="line">        <span class="keyword">if</span> (temp != <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp2 &gt; <span class="number">7</span>)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;+&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (temp2 &lt; <span class="number">3</span>)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>如果表达式和某个case标签的值匹配成功，程序从该标签之后的第一条语句开始执行，**<u>直到到达了switch的结尾或者是遇到一条break语句为止</u>**：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> aCnt = <span class="number">0</span>, eCnt = <span class="number">0</span>, iCnt = <span class="number">0</span>, oCnt = <span class="number">0</span>, uCnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; ch) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">            ++aCnt;</span><br><span class="line">            <span class="keyword">break</span>;		<span class="comment">//当输入为a时，如果没有这条break，程序还会执行后面的 ++eCnt;</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">            ++eCnt;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">            ++iCnt;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">            ++oCnt;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">            ++uCnt;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:		<span class="comment">//即使default什么也不做，也最好加上default，表示已经考虑了default</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如统计a、e、i、o、u的总数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> vowelCnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">	<span class="keyword">case</span><span class="number">&#x27;</span>a<span class="number">&#x27;</span>: <span class="keyword">case</span><span class="number">&#x27;e&#x27;</span>: <span class="keyword">case</span><span class="number">&#x27;</span>i<span class="number">&#x27;</span>: <span class="keyword">case</span><span class="number">&#x27;</span>o<span class="number">&#x27;</span>: <span class="keyword">case</span><span class="number">&#x27;u</span><span class="number">&#x27;</span>: </span><br><span class="line">        ++vowelCnt;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;			<span class="comment">//即使在switch语句的结尾，也最好加上一句 break;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="switch内部的变量定义"><a href="#switch内部的变量定义" class="headerlink" title="switch内部的变量定义"></a>switch内部的变量定义</h4><p>初始化操作和定义变量对于编译器来说是两码事，初始化操作（包括隐式初始化，例如<code>string s;</code>，和显示初始化，列如<code>int i = 0;</code>）是程序运行时才会被调用的语句，可能被case跳转屏蔽掉；而定义则是在编译时就完成检查，不能跳过分配空间。</p>
<p>C++不允许使用未初始化的变量，为了防止switch语句中发生这种情况，C++规定不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">	string file_name;		<span class="comment">//错误：控制流绕过一个隐式初始化的变量（编译器会告诉你这是不合法的）</span></span><br><span class="line">	<span class="type">int</span> ival = <span class="number">0</span>;			<span class="comment">//错误：控制流绕过一个显式初始化的变量（编译器会告诉你这是不合法的）</span></span><br><span class="line">	<span class="type">int</span> jval;				<span class="comment">//正确：在作用域内定义jval</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">	jval = <span class="built_in">next_num</span>();		<span class="comment">//正确：jval在作用域内有定义，此处给jval赋一个值</span></span><br><span class="line">	<span class="keyword">if</span>(file_name.<span class="built_in">empty</span>())	<span class="comment">//file_name在作用域内，但没有被初始化</span></span><br></pre></td></tr></table></figure>

<h2 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h2><p><em>练习5.14</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string input, temp;</span><br><span class="line">vector&lt;string&gt; svec;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (cin &gt;&gt; input) &#123;</span><br><span class="line">    ++cnt;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; temp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (input == temp) &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; max) &#123;</span><br><span class="line">                svec = &#123;&#125;;</span><br><span class="line">                max = cnt;</span><br><span class="line">                svec.<span class="built_in">push_back</span>(input);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cnt == max) &#123;</span><br><span class="line">                svec.<span class="built_in">push_back</span>(input);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">            input = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (max &gt; <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : svec)</span><br><span class="line">        cout &lt;&lt; c &lt;&lt; <span class="string">&quot;出现了&quot;</span> &lt;&lt; max &lt;&lt; <span class="string">&quot;次&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;没有连续出现的单词&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p><em>练习5.17</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; ivec1&#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>, <span class="number">0</span>, <span class="number">99</span>, <span class="number">3</span> &#125;, ivec2&#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span> &#125;;</span><br><span class="line"><span class="type">int</span> small_size = (ivec1.<span class="built_in">size</span>() &gt; ivec2.<span class="built_in">size</span>()) ? ivec2.<span class="built_in">size</span>() : ivec1.<span class="built_in">size</span>();</span><br><span class="line">cout &lt;&lt; ((ivec1.<span class="built_in">size</span>() &gt; ivec2.<span class="built_in">size</span>()) ? <span class="string">&quot;ivec2&quot;</span> : <span class="string">&quot;ivec1&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != small_size; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ivec1[i] != ivec2[i]) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;不是&quot;</span> &lt;&lt; ((ivec1.<span class="built_in">size</span>() &gt; ivec2.<span class="built_in">size</span>()) ? <span class="string">&quot;ivec1&quot;</span> : <span class="string">&quot;ivec2&quot;</span>) &lt;&lt; <span class="string">&quot;的前缀&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;是&quot;</span> &lt;&lt; ((ivec1.<span class="built_in">size</span>() &gt; ivec2.<span class="built_in">size</span>()) ? <span class="string">&quot;ivec1&quot;</span> : <span class="string">&quot;ivec2&quot;</span>) &lt;&lt; <span class="string">&quot;的前缀&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="范围for语句"><a href="#范围for语句" class="headerlink" title="范围for语句"></a>范围for语句</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : v)&#123;<span class="comment">/*statements*/</span>&#125;		<span class="comment">//来源于下述传统for语句，其中v是一个vector&lt;int&gt;对象</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> beg = v.<span class="built_in">begin</span>(), end = v.<span class="built_in">end</span>(); beg != end; ++beg)&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r = *beg;</span><br><span class="line">    <span class="comment">/*statements*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do while语句"></a>do while语句</h3><p><strong>condition使用的变量必须定义在循环体之外</strong>，<strong>先</strong>执行语句或块，<strong>后</strong>判断条件，不允许在条件部分定义变量，而且至少执行一次：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment">/*statements*/</span></span><br><span class="line"><span class="keyword">while</span> (<span class="comment">/*condition*/</span>);					<span class="comment">//注意这里有一个分号表示语句结束</span></span><br></pre></td></tr></table></figure>

<hr>
<p><em>练习5.19</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s1, s2;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Please input two strings: &quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; s1;</span><br><span class="line">	cin &gt;&gt; s2;</span><br><span class="line">	<span class="keyword">if</span> (s1.<span class="built_in">size</span>() == s2.<span class="built_in">size</span>())</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Size of s1 is equal to size of s2.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>())</span><br><span class="line">		cout &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">while</span> (cin);</span><br></pre></td></tr></table></figure>

<h2 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h2><h3 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h3><p>负责终止离它<strong>最近的</strong>迭代语句或者switch语句，只能出现在<strong>迭代语句或者switch语句内部</strong></p>
<h3 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h3><p>用于终止最近的循环中的当前迭代并<strong>立即开始下一次迭代</strong>，对于传统for，继续执行for语句头中的expression</p>
<h3 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h3><p> 作用是从goto语句无条件跳转到<strong>同一函数内</strong>的另一条语句 ，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">goto</span> end;</span><br><span class="line">    <span class="comment">/*statements*/</span></span><br><span class="line">    end: ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与switch类似，goto不能绕过一个带初始化的变量定义，但可以从带初始化的变量定义之后跳回到之前，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">begin:</span><br><span class="line">	<span class="type">int</span> sz = <span class="built_in">get_size</span>();</span><br><span class="line">	<span class="keyword">if</span>(sz &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">goto</span> begin;			<span class="comment">//此时goto执行后会先销毁sz，然后再重新执行sz的定义并初始化</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a>try语句块和异常处理</h2><p>当程序的某部分检测到一个它无法处理的问题时，需要用到异常处理。异常处理机制由程序中<strong>异常检测</strong>和<strong>异常处理</strong>两部分协作提供支持，其中异常检测部分只负责发出异常信号，无须知道故障将在何处解决；异常处理部分负责处理问题。</p>
<h3 id="throw表达式"><a href="#throw表达式" class="headerlink" title="throw表达式"></a>throw表达式</h3><p>异常检测部分使用throw引发一个异常或者说抛出一个异常：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(item1.<span class="built_in">isbn</span>() != item2.<span class="built_in">isbn</span>())</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Data must refer to same ISBN&quot;</span>);	<span class="comment">//该异常是类型runtime_error的对象</span></span><br></pre></td></tr></table></figure>

<p>runtime_error是标准库异常类型的一种，定义在stdexcept头文件中，我们必须初始化runtime_error对象，方式是给他提供一个string对象或者C风格字符串，如上文中的”Data must refer to same ISBN” 。</p>
<h3 id="try语句块"><a href="#try语句块" class="headerlink" title="try语句块"></a>try语句块</h3><p>在try块之后是一个或多个catch子句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">/*program-statements*/</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="comment">/*exception-declaration*/</span>)&#123;		<span class="comment">//()中是一个异常声明</span></span><br><span class="line">    <span class="comment">/*handler-statements*/</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="comment">/*exception-declaration*/</span>)&#123;</span><br><span class="line">    <span class="comment">/*handler-statements*/</span></span><br><span class="line">&#125; <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>当选中了某个catch子句处理异常之后，执行与之对应的块：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sales_item item1, item2;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; item1 &gt;&gt; item2) &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (item1.<span class="built_in">isbn</span>() != item2.<span class="built_in">isbn</span>()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Data must refer to same ISBN&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; item1 + item2 &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (runtime_error err) &#123;</span><br><span class="line">		cout &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\nTry Again ? Enter y or n&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="type">char</span> c;</span><br><span class="line">		cin &gt;&gt; c;</span><br><span class="line">		<span class="keyword">if</span> (!cin || c == <span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>catch完成后，程序将跳转到try语句块<strong>最后一个catch子句之后</strong>的那条语句继续执行。复杂系统中，一个try语句块①可能调用了包含另一个try语句块②的函数，try语句块②可能调用了包含try语句块③的函数，以此类推。</p>
<p>寻找处理代码的过程则是先从try语句块③中寻找匹配的catch子句，若没有，则再从try语句块②中寻找，以此类推。如果最终没有找到任何匹配的子句，<u>则程序转到名为terminate的标准库函数</u>，一般情况下，执行该函数将导致程序非正常退出。</p>
<h3 id="标准异常"><a href="#标准异常" class="headerlink" title="标准异常"></a>标准异常</h3><p>C++标准库定义了一组类，用于报告标准库函数遇到的问题，exception头文件定义了最通用的异常类exception；stdexcept头文件定义了集中常用的异常类；new头文件定义了bad_alloc异常类型；type_info头文件定义了bad_cast异常类型。</p>
<hr>
<p><em>练习5.25</em></p>
<p>try语句块至少要设定一个catch子句，否则编译器会报错</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i1, i2;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入两个整数用于除法运算，第一个为被除数，第二个为除数：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; i1 &gt;&gt; i2;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (i2 == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;除数不可以为0！&quot;</span>);</span><br><span class="line">		cout &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(i1) / i2 &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (runtime_error err) &#123;</span><br><span class="line">		cout &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\nTry again？ Enter y or n&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="type">char</span> c;</span><br><span class="line">		cin &gt;&gt; c;</span><br><span class="line">		<span class="keyword">if</span> (!cin || c == <span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (cin);</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++笔记（十一）——函数（一）</title>
    <url>/2022/05/08/cpp/cpp-note-11/</url>
    <content><![CDATA[<h1 id="函数-function"><a href="#函数-function" class="headerlink" title="函数(function)"></a>函数(function)</h1><p>C++中允许重载函数，也就是几个不同的函数可以使用同一个名字，程序员需要清楚地知道编译器如何从函数的若干重载形式中选取一个与调用匹配的版本。</p>
<h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p>一个典型的函数定义包括一下部分：返回类型、函数名字、由0个或多个形参(parameter)组成的列表以及函数体：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fact</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(val &gt; <span class="number">1</span>)</span><br><span class="line">        ret *= val--;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="built_in">fact</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5! is &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数的调用完成两项工作：一是用实参初始化函数对应的形参；二是将<strong>控制权转移给被调函数</strong>，此时主调函数(calling function)的执行被暂时<strong>中断</strong>，被调函数(called function)开始执行。</p>
<p>当遇到一条return时函数结束执行过程。和调用一样，return也完成两项工作：一是返回return语句中的值（如果有的话）；二是将<strong>控制权返还给主调函数</strong></p>
<h4 id="局部静态对象"><a href="#局部静态对象" class="headerlink" title="局部静态对象"></a>局部静态对象</h4><p>特点：</p>
<ol>
<li>该变量在全局数据区分配内存；</li>
<li>在程序执行到该对象的声明处时被首次初始化，此后的函数调用不再对其进行初始化；</li>
<li>如果没有显式初始化，会被程序自动初始化为0；</li>
<li>始终驻留在全局数据区，直到程序运行结束，<strong>但其作用域仅为局部作用域</strong>（仅在定义它的函数或语句块中）；</li>
</ol>
<p>可以用于记录函数被调用的次数等。</p>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>如果形参是引用类型，它将绑定到对应的实参上，称实参被<strong>引用传递</strong>(passed by reference)或者函数被<strong>传引用调用</strong>(called by reference)；否则，将实参的值拷贝后赋给形参，称实参被<strong>值传递</strong>(passed by value)或者称函数被<strong>传值调用</strong>(called by value)。</p>
<h3 id="传值参数"><a href="#传值参数" class="headerlink" title="传值参数"></a>传值参数</h3><p>使用值形参，函数中对形参做的所有操作都不会影响到实参</p>
<h4 id="指针形参"><a href="#指针形参" class="headerlink" title="指针形参"></a>指针形参</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">int</span> *ip)</span></span>&#123;</span><br><span class="line">    *ip = <span class="number">0</span>;	<span class="comment">//改变了形参ip所指对象的值，但此时形参与实参指针指向同一个对象，故实参所指对象也被改变</span></span><br><span class="line">    ip = <span class="number">0</span>;		<span class="comment">//仅改变形参，实参指针对象未被改变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++中，建议使用引用类型的形参替代指针（<u>编译器会把引用解释为常量指针，或者说机器码层面引用等价于常量指针</u>）。</p>
<h3 id="传引用参数"><a href="#传引用参数" class="headerlink" title="传引用参数"></a>传引用参数</h3><p>使用引用形参，允许函数改变一个或多个实参的值</p>
<h4 id="使用引用避免拷贝"><a href="#使用引用避免拷贝" class="headerlink" title="使用引用避免拷贝"></a>使用引用避免拷贝</h4><p>拷贝大的类类型对象或容器对象比较低效，而且<strong>有的类（包括IO类型）根本不支持拷贝操作</strong>，如果函数无须改变引用形参的值，<strong>最好将其声明为对常量的引用</strong>。</p>
<h4 id="使用引用形参返回额外信息"><a href="#使用引用形参返回额外信息" class="headerlink" title="使用引用形参返回额外信息"></a>使用引用形参返回额外信息</h4><p>一个函数只能返回一个值，让函数返回更多的信息，可以：</p>
<ol>
<li>使用引用形参，在函数中改变引用形参的值；</li>
<li>将函数返回值设定为自定义的类，类在定义中可以封装多个属性；</li>
</ol>
<h3 id="const形参和实参"><a href="#const形参和实参" class="headerlink" title="const形参和实参"></a>const形参和实参</h3><p>形参的初始化过程与变量的初始化过程一样，在初始化时，形参的顶层const会被忽略，即可以用非常量初始化const形参：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fcn</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i)</span> </span>&#123; <span class="comment">/*fcn可以读取i，但不可以向i写值*/</span> &#125;	<span class="comment">//初始化正确</span></span><br></pre></td></tr></table></figure>

<p>复习初始化规则：</p>
<ol>
<li>可以用非常量初始化顶层const对象；</li>
<li>可以用非常量初始化一个底层const对象，但不能用底层const对象初始化一个非常量对象；</li>
<li>一个普通的引用必须用同类型的对象初始化；</li>
</ol>
<p><strong>注意</strong>：定义形参时，尽量使用常量引用而不是普通引用，否则①会对函数使用者造成误导：②不能传递<strong>const对象、字面值、需要类型转换的对象</strong>（会产生临时变量，临时变量不可改变）；③其他拥有常量引用形参的函数中无法正常使用该函数。</p>
<h3 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h3><p> 数组不能被拷贝，因此无法以值传递的方式使用数组参数；数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下三个print函数等价</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span> <span class="params">(<span class="type">const</span> <span class="type">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span> <span class="params">(<span class="type">const</span> <span class="type">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span> <span class="params">(<span class="type">const</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;		<span class="comment">//这里的维度表示我们期望数组含有多少元素，但实际不一定</span></span><br></pre></td></tr></table></figure>

<p>编译器在处理时，只会检查传入的参数是否是const int<em>类型的，而不会考虑其是否指向一个数组，<u>但对于多维数组，*<em>只有第一维长度不检查，其他维度的长度必须与形参一致</em></em></u>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以两个print函数等价</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> matrix[][<span class="number">10</span>], <span class="type">int</span> rowSize)</span></span>&#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> (*matrix)[<span class="number">10</span>], <span class="type">int</span> rowSize)</span></span>&#123; <span class="comment">/*...*/</span> &#125;	<span class="comment">//*matrix两端的()不可去掉</span></span><br></pre></td></tr></table></figure>

<h4 id="确定数组长度"><a href="#确定数组长度" class="headerlink" title="确定数组长度"></a>确定数组长度</h4><p>任何使用数组的代码，必须确保不会越界，大致有三种方法：</p>
<ol>
<li><p>使用标记指定数组长度（常用于C风格字符串，以<code>\0</code>为标记）；</p>
</li>
<li><p>向函数传递数组首元素和尾后元素的指针（受标准库技术启发而来）；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *beg, <span class="type">const</span> <span class="type">int</span> *end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(beg != end)</span><br><span class="line">        cout &lt;&lt; *beg++ &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>显式传递一个表示数组大小的形参；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span> <span class="params">(<span class="type">const</span> <span class="type">int</span> ia[], <span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> = <span class="number">0</span>; i != size; ++i)</span><br><span class="line">        cout &lt;&lt; ia[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="数组引用形参"><a href="#数组引用形参" class="headerlink" title="数组引用形参"></a>数组引用形参</h4><p>C++允许将变量定义成数组的引用，同样形参也可以是数组的引用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> (&amp;arr)[<span class="number">10</span>])</span></span>&#123;		<span class="comment">//此处不能写成 &amp;arr[10]，它表示引用的数组（C++不允许定义引用的数组），与原意相悖</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> elem : arr)</span><br><span class="line">        cout &lt;&lt; elem &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><em>练习6.22</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">exchange_pointer</span><span class="params">(<span class="type">int</span>* (&amp;px), <span class="type">int</span>* (&amp;py))</span> </span>&#123; 	<span class="comment">//对指针的引用（从里向外，从右到左）</span></span><br><span class="line">	<span class="keyword">auto</span> temp = px;</span><br><span class="line">	px = py;</span><br><span class="line">	py = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="main-处理命令行选项"><a href="#main-处理命令行选项" class="headerlink" title="main:处理命令行选项"></a>main:处理命令行选项</h3><p>有时我们需要向main函数传递实参，常用于设置一组选项来确定函数所要执行的操作。例如，假设main函数位于可执行文件prog之内，我们可以如此向程序传递下面的选项：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">prog -d -o ofile data0</span><br></pre></td></tr></table></figure>

<p>这些命令行选项通过两个（可选的）形参传递给main函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>argc</code>表示数组中字符串的数量，<code>argv</code>是一个数组，它的元素是指向C风格字符串的指针（即指针数组）。当使用<code>argv</code>中的实参时，一定要记得可选实参从<code>argv[1]</code>开始，因为<code>argv[0]</code>保存程序的名字，而非用户输入。</p>
<hr>
<p><em>练习6.25、6.26</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	string s;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i != argc; ++i) &#123;</span><br><span class="line">		s += argv[i];</span><br><span class="line">		s += <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>VS2022可以在本地调试器中设置命令参数：</p>
<img src="/2022/05/08/cpp/cpp-note-11/1652018387995.png" class="" width="1652018387995">

<hr>
<h3 id="含有可变形参的函数"><a href="#含有可变形参的函数" class="headerlink" title="含有可变形参的函数"></a>含有可变形参的函数</h3><p>有时我们无法预知应该想函数传递几个实参，例如我们想要编写代码输出程序产生的错误信息，此时最好用同一个函数实现该功能，以便对所有错误的处理能够整齐划一。</p>
<p>C++11新标准提供了两种主要的方法：</p>
<ol>
<li>若所有实参类型相同，可以传递一个名为<strong>initializer_list</strong>的标准库类型；</li>
<li>若不同，可以利用<strong>可变参数模板</strong>编写一种特殊的函数；</li>
</ol>
<h4 id="initializer-list形参"><a href="#initializer-list形参" class="headerlink" title="initializer_list形参"></a>initializer_list形参</h4><p>和vector一样，initializer_list也是一种模板类型，定义时必须说明列表中所含元素的类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">initializer_list&lt;string&gt; ls;</span><br><span class="line">initializer_list&lt;<span class="type">int</span>&gt; li;</span><br></pre></td></tr></table></figure>

<p>与vector不同的是，initializer_list对象中的元素永远是常量值。</p>
<p>作用于未知数量实参的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_msg</span><span class="params">(initializer_list&lt;string&gt; i1)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> beg = i1.<span class="built_in">begin</span>(); beg != i1.<span class="built_in">end</span>(); ++beg)</span><br><span class="line">		cout &lt;&lt; *beg &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (expected != actual)</span><br><span class="line">		<span class="built_in">error_msg</span>(&#123; <span class="string">&quot;functionX&quot;</span>, expected, actual &#125;);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">error_msg</span>(&#123; <span class="string">&quot;functionX&quot;</span>, <span class="string">&quot;okay&quot;</span> &#125;);	<span class="comment">//通过&#123;&#125;为initializer_list形参中传递一个序列</span></span><br></pre></td></tr></table></figure>

<h4 id="省略符形参"><a href="#省略符形参" class="headerlink" title="省略符形参"></a>省略符形参</h4><p>仅仅用于C和C++通用的类型，大多数类类型的对象在传递给省略符形参时都无法正确拷贝，形式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(parm_list, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(...)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<p><em>练习6.27</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sumation</span><span class="params">(initializer_list&lt;<span class="type">int</span>&gt; ini1)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> c : ini1) &#123;</span><br><span class="line">		sum += c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="返回类型和return语句"><a href="#返回类型和return语句" class="headerlink" title="返回类型和return语句"></a>返回类型和return语句</h2><p>两种形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> ;	<span class="comment">//返回一个空语句，只能用在返回类型是void的函数中，void函数最后一句后面会隐式地执行return</span></span><br><span class="line"><span class="keyword">return</span> <span class="comment">/*expression*/</span>;</span><br></pre></td></tr></table></figure>

<p>返回类型是void的函数也能用第二种形式的return，但其expression必须是<strong>另一个返回void的函数</strong>。</p>
<h4 id="值是如何被返回的"><a href="#值是如何被返回的" class="headerlink" title="值是如何被返回的"></a>值是如何被返回的</h4><p>返回一个值的方式和初始化一个变量或形参的范式完全一样：返回的值在调用点产生一个临时量，该临时量就是函数调用的结果。</p>
<p>C++11新标准规定，函数可以返回花括号包围的值的列表，即用花括号列表来对临时量进行初始化。</p>
<h4 id="不要返回局部对象的引用或指针"><a href="#不要返回局部对象的引用或指针" class="headerlink" title="不要返回局部对象的引用或指针"></a>不要返回局部对象的引用或指针</h4><p>函数完成后，它所占用的内存空间随之被释放，局部变量的引用或指针将指向不在有效的内存区域：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">manip</span><span class="params">()</span></span>&#123;		<span class="comment">//表示返回值是对string常量的引用</span></span><br><span class="line">    string ret;</span><br><span class="line">    <span class="keyword">if</span>(!ret.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> ret;			<span class="comment">//错误：返回局部对象的引用</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Empty&quot;</span>;		<span class="comment">//错误：&quot;Empty&quot;是一个局部临时变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以返回对实参的引用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">shorterString</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1 : s2;	<span class="comment">//s1，s2都是对实参的引用，不会产生临时量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="返回类类型的函数"><a href="#返回类类型的函数" class="headerlink" title="返回类类型的函数"></a>返回类类型的函数</h4><p>如果函数返回指针、引用或类的对象，我们可以使用函数调用的结果访问结果对象的成员：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> sz = <span class="built_in">shorterString</span>(s1, s2).<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>

<h4 id="引用返回左值"><a href="#引用返回左值" class="headerlink" title="引用返回左值"></a>引用返回左值</h4><p>这意味着可以为返回类型是非常量引用的函数的结果赋值</p>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>函数调用自己：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(val &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">factorial</span>(val - <span class="number">1</span>) * val;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>至少有一条路径不包含递归调用，否则会无限递归直至程序栈空间耗尽；</li>
<li>main函数不能调用自己；</li>
</ol>
<hr>
<p><em>练习6.33</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Get_vector_val</span><span class="params">(vector&lt;<span class="type">int</span>&gt; ivec, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line">		cout &lt;&lt; ivec[ivec.<span class="built_in">size</span>() - size] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="built_in">Get_vector_val</span>(ivec, size - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="返回数组指针"><a href="#返回数组指针" class="headerlink" title="返回数组指针"></a>返回数组指针</h3><p>最直接的方法是使用类型别名：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> arrT[<span class="number">10</span>];	<span class="comment">//arrT是一个类型别名，它表示的类型是含有10个整数的数组</span></span><br><span class="line"><span class="keyword">using</span> arrT = <span class="type">int</span>[<span class="number">10</span>];	<span class="comment">//C++11新标准下arrT的等价声明</span></span><br><span class="line"><span class="function">arrT* <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span></span>;		<span class="comment">//func返回一个指向含有10个整数的数组的指针</span></span><br></pre></td></tr></table></figure>

<p>不使用类型别名：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> (*<span class="built_in">func</span>(<span class="type">int</span> i))[<span class="number">10</span>];	<span class="comment">//形参列表必须紧靠着函数名，表示调用func函数时需要一个int类型的实参</span></span><br></pre></td></tr></table></figure>

<p>C++11新标准中使用尾置返回类型(trailing return type)：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[10]</span>;</span><br></pre></td></tr></table></figure>

<p>如果提前知道函数返回值将指向哪个数组，可以使用decltype：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> odd[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> even[] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(odd) *<span class="built_in">arrPtr</span>(<span class="type">int</span> i)&#123;</span><br><span class="line">    <span class="keyword">return</span> (i % <span class="number">2</span>) ? &amp;odd : &amp;even;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u><strong>注意</strong>：<code>int mat1[][10]</code>和<code>int (*mat2) [10]</code>是等价的，但是<code>int **mat3</code>与它们不等价，因为++mat1和++mat2都表示指向下一个数组，地址移动了10个int元素，即40个字节；而++mat3只移动了1个int元素，即4个字节。</u></p>
<hr>
<p><em>练习6.33</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> (&amp;<span class="built_in">func1</span>(<span class="type">int</span> i))[<span class="number">10</span>]&#123;&#125;		<span class="comment">//直接声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> i)</span>-&gt;<span class="title">string</span><span class="params">(&amp;)</span>[10] </span>&#123;&#125;	<span class="comment">//尾置返回类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(s) &amp;<span class="built_in">func3</span>(<span class="type">int</span> i)&#123;&#125;			<span class="comment">//decltype</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> arrStr = string[<span class="number">10</span>];			<span class="comment">//类型别名</span></span><br><span class="line"><span class="function">arrStr &amp;<span class="title">func4</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++笔记（十二）——函数（二）</title>
    <url>/2022/05/09/cpp/cpp-note-12/</url>
    <content><![CDATA[<h2 id="重载函数"><a href="#重载函数" class="headerlink" title="重载函数"></a>重载函数</h2><p>如果同一作用域内的几个函数名字相同但形参列表不同（<strong>形参数量或类型有所不同</strong>），称之为重载(overloaded)函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *beg, <span class="type">const</span> <span class="type">int</span> *end)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ia[], <span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<p>编译器会根据实参类型推断想要的是哪个函数</p>
<p>注意：</p>
<ol>
<li>不允许两个函数除了返回类型外，其他所有要素（包括函数名在内）都相同；</li>
<li>一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开；</li>
<li>如果形参是指针或引用，可以通过底层const区分；</li>
</ol>
<h4 id="const-cast和重载"><a href="#const-cast和重载" class="headerlink" title="const_cast和重载"></a>const_cast和重载</h4><p>对于：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">shorterString</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回的结果仍然是const string的引用，可以重载一个新的函数，当实参不是常量时，返回一个普通引用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string &amp;<span class="title">shorterString</span><span class="params">(string &amp;s1, string &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r = <span class="built_in">shorterString</span>(<span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s1), <span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s2));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;string&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：这里在定义重载函数时，调用了原函数，为了<u>保证编译器确实使用的是原函数而不是重载后的函数</u>（防止造成递归死循环），必须<strong>把调用原函数时输入的实参进行一次强制转换</strong>。</p>
<h3 id="重载与作用域"><a href="#重载与作用域" class="headerlink" title="重载与作用域"></a>重载与作用域</h3><p>当外层作用域中声明的名字与内层作用域中声明的名字（函数名与函数名，变量名与变量名，变量名与函数名等）相同时，内层作用域的声明会隐藏掉外层作用域的声明，即<strong>不能在内层作用域重载外层作用域声明的函数</strong>。</p>
<h2 id="特殊语言特性"><a href="#特殊语言特性" class="headerlink" title="特殊语言特性"></a>特殊语言特性</h2><p>三种函数相关的语言特性：默认实参、内联函数、constexpr函数</p>
<h3 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h3><ol>
<li>靠右原则：具有默认实参的形参其右侧的形参必须都具有默认实参；</li>
<li>可以在声明中赋予默认实参，同一作用域中同一形参只能被赋予一次，并且也必须遵守靠右原则；</li>
<li><strong>局部变量不能作为默认实参</strong>，除此之外，类型相符合的表达式都能作为默认实参；</li>
</ol>
<p>举例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> string::size_type sz;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz, sz, <span class="type">char</span> = <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz, sz, <span class="type">char</span> = <span class="string">&#x27;*&#x27;</span>)</span></span>;	<span class="comment">//错误</span></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz = <span class="number">24</span>, sz = <span class="number">80</span>, <span class="type">char</span>)</span></span>;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">string window;</span><br><span class="line">window = <span class="built_in">screen</span>();					<span class="comment">//等价于 window = screen(24, 80, &#x27; &#x27;);</span></span><br><span class="line">window = <span class="built_in">screen</span>(<span class="number">66</span>);				<span class="comment">//等价于 window = screen(66, 80, &#x27; &#x27;);</span></span><br><span class="line">window = <span class="built_in">screen</span>(<span class="number">66</span>, <span class="number">256</span>);			<span class="comment">//等价于 window = screen(66, 256, &#x27; &#x27;);</span></span><br><span class="line">window = <span class="built_in">screen</span>(<span class="number">66</span>, <span class="number">256</span>, <span class="string">&#x27;#&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>注意：在设置默认实参和重载函数时，要<strong>避免发生调用不明确的情况</strong>，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz i, sz j, <span class="type">char</span> c = <span class="string">&#x27;*&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz i, sz j)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">screen</span>(<span class="number">24</span>, <span class="number">80</span>);						<span class="comment">//错误：编译器分不清调用的是第一个screen还是第二个screen函数</span></span><br></pre></td></tr></table></figure>

<h3 id="内联-inline-函数和constexpr函数"><a href="#内联-inline-函数和constexpr函数" class="headerlink" title="内联(inline)函数和constexpr函数"></a>内联(inline)函数和constexpr函数</h3><h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>可避免函数调用的开销，定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> string &amp; <span class="title">shorterString</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span>&#123;	<span class="comment">//inline关键字</span></span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">shorterString</span>(s1, s2) &lt;&lt; endl;		<span class="comment">//编译器会将其展开成如下形式</span></span><br><span class="line">cout &lt;&lt; (s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1 : s2) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h4 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h4><p>能用于常量表达式的函数，而且是隐式地inline函数，约定：</p>
<ol>
<li>返回类型和所有形参类型都必须是字面值类型或常量表达式；</li>
<li>函数体中有且仅有一条return语句；</li>
</ol>
<p>注意：</p>
<ol>
<li>constexpr函数内可以有其他语句，但要保证它们在运行时不执行任何操作；</li>
<li>允许constexpr函数返回一个非常量；</li>
</ol>
<h3 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h3><p>assert和NDEBUG两种预处理功能用于有选择地执行调试代码</p>
<h4 id="assert预处理宏-preprocessor-marco"><a href="#assert预处理宏-preprocessor-marco" class="headerlink" title="assert预处理宏(preprocessor marco)"></a>assert预处理宏(preprocessor marco)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert</span>(expr);</span><br></pre></td></tr></table></figure>

<p>对expr进行求值，若为假（0），assert输出信息并终止程序执行；若为真，什么也不发生</p>
<h3 id="NDEBUG预处理变量"><a href="#NDEBUG预处理变量" class="headerlink" title="NDEBUG预处理变量"></a>NDEBUG预处理变量</h3><p>assert的行为依赖于NDEBUG预处理变量的状态，如果定义了NDEBUG，则assert什么也不做；否则，assert将执行运行时检查</p>
<p>很多编译器都提供了命令行选项使我们可以定义预处理变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$CC -D NDEBUG main.C # use /D with the Microsoft compiler</span><br></pre></td></tr></table></figure>

<p>等价于在main.c文件<strong>开始处</strong>（至少在<code>#include&lt;cassert&gt;</code>之前，因为该头文件使用了<code>#ifdef NDEBUG</code>）写<code>#define NDEBUG</code></p>
<p>C++编译器定义了几个有利于程序调试的名字：</p>
<p><code>__func__</code>存放函数名</p>
<p><code>__FILE__</code>存放文件名</p>
<p><code>__LINE__</code>存放当前行号</p>
<p><code>__TIME__</code>存放文件编译时间</p>
<p><code>__DATE__</code>存放文件编译日期</p>
<hr>
<p><em>练习6.47</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output_vector</span><span class="params">(vector&lt;string&gt; svec)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">	cout &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;string向量的大小为：&quot;</span> &lt;&lt; svec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (!svec.<span class="built_in">empty</span>())</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : svec)</span><br><span class="line">			cout &lt;&lt; c &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;输入了一个空字符串向量！&quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	vector&lt;string&gt; svec;</span><br><span class="line">	string s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入一个字符串，输入stop停止程序：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; s)&#123;</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="string">&quot;stop&quot;</span> || s == <span class="string">&quot;STOP&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			svec.<span class="built_in">push_back</span>(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">output_vector</span>(svec);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h2><p>步骤：</p>
<ol>
<li><p>确定候选函数(candidate function)和可行函数(viable function)；</p>
<p>候选函数：①同名；②其声明在调用点可见；</p>
<p>可行函数：①实参数量够用；②实参与对应形参类型相同，或能转换成形参的类型；</p>
</li>
<li><p>寻找最佳匹配（实参类型越接近，匹配得越好）；</p>
<p><strong>有且只有</strong>一个函数满足下列条件时，匹配成功：</p>
<ul>
<li><p>该函数每个实参的匹配不劣于其他可行函数；</p>
</li>
<li><p>至少有一个实参的匹配优于其他可行函数；</p>
</li>
</ul>
<p>否则本次调用是<strong>错误的</strong></p>
</li>
</ol>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针即指向函数的指针，其类型要与函数的类型相同</p>
<p>函数的类型由它的返回值类型和形参类型共同决定，与函数名无关：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该函数的类型是bool (const string&amp;, const string&amp;)，声明一个可以指向该函数的指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> (*pf)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;);		<span class="comment">//未初始化</span></span><br><span class="line">pf = lengthCompare;								<span class="comment">//将lengthCompare的地址赋值给pf</span></span><br><span class="line">pf = &amp;lengthCompare;							<span class="comment">//与上一条语句等价</span></span><br></pre></td></tr></table></figure>

<p>此时可以通过指向函数的指针调用该函数，且无须解引用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> b1 = <span class="built_in">pf</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>);</span><br><span class="line"><span class="type">bool</span> b2 = (*pf)(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>);			<span class="comment">//与上一条语句等价</span></span><br><span class="line"><span class="type">bool</span> b1 = <span class="built_in">lengthCompare</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>);	<span class="comment">//与上一条语句等价</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>指向不同函数类型的指针间不存在类型转换，但可以赋值为空(nullptr)；</li>
<li>指向重载函数的指针必须与重载函数中某一个精确匹配；</li>
</ol>
<h4 id="函数指针形参"><a href="#函数指针形参" class="headerlink" title="函数指针形参"></a>函数指针形参</h4><p>不能定义函数类型的形参，但形参可以是指向函数的指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2, <span class="type">bool</span> pf(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;))</span></span>;</span><br><span class="line"><span class="comment">//等价的声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2, <span class="type">bool</span> (*pf)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;))</span></span>;</span><br></pre></td></tr></table></figure>

<p>调用时可以直接把函数作为实参使用，它会自动转换成指针（类似于数组）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">useBigger</span>(s1, s2, lengthCompare);</span><br></pre></td></tr></table></figure>

<p>类型别名可以简化定义指向函数的指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="type">bool</span> <span class="title">Func1</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;)</span></span>;	<span class="comment">//Func1是函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> Func2</span>;				<span class="comment">//Func1与Func2是等价的类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*Func3)</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;)</span></span>;<span class="comment">//Func3是指向函数的指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> *Func4</span>;				<span class="comment">//Func4与Func3是等价的类型</span></span><br></pre></td></tr></table></figure>

<h4 id="返回指向函数的指针"><a href="#返回指向函数的指针" class="headerlink" title="返回指向函数的指针"></a>返回指向函数的指针</h4><p>与数组类似，虽然不能返回一个函数，但可以返回指向函数的指针，方法也类似：</p>
<ol>
<li>直接声明；</li>
<li>类型别名；</li>
<li>尾置返回类型；</li>
<li>提前知道返回的函数时，decltype；</li>
</ol>
<hr>
<p><em>练习6.54、练习6.56、练习6.56</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">int_add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">int_minus</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x - y; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">int_multiply</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x * y; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">int_divide</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">if</span> (y != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> x / y;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cerr &lt;&lt; <span class="string">&quot;error: 除数不能为0！&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//直接声明</span></span><br><span class="line">	vector&lt;<span class="type">int</span>(*) (<span class="type">int</span>, <span class="type">int</span>)&gt; pFuncVec1;</span><br><span class="line">	<span class="comment">//类型别名</span></span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*type_Func)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">	vector&lt;type_Func&gt; pFuncVec2;</span><br><span class="line">	<span class="comment">//使用decltype</span></span><br><span class="line">	vector&lt;<span class="keyword">decltype</span>(int_add)*&gt; pFuncVec3;	<span class="comment">//decltype(Func)得到的仅是函数类型，需要加上*</span></span><br><span class="line">    </span><br><span class="line">	pFuncVec3.<span class="built_in">push_back</span>(&amp;int_add);</span><br><span class="line">	pFuncVec3.<span class="built_in">push_back</span>(&amp;int_minus);</span><br><span class="line">	pFuncVec3.<span class="built_in">push_back</span>(&amp;int_multiply);</span><br><span class="line">	pFuncVec3.<span class="built_in">push_back</span>(&amp;int_divide);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; pFuncVec3[<span class="number">0</span>](<span class="number">6</span>, <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; pFuncVec3[<span class="number">1</span>](<span class="number">6</span>, <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; pFuncVec3[<span class="number">2</span>](<span class="number">6</span>, <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; pFuncVec3[<span class="number">3</span>](<span class="number">6</span>, <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






















]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++笔记（十三）——类（一）</title>
    <url>/2022/05/09/cpp/cpp-note-13/</url>
    <content><![CDATA[<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类的基本思想是<strong>数据抽象</strong>(data abstraction)和<strong>封装</strong>(encapsulation)，数据抽象是一种依赖于<strong>接口</strong>(interface)和<strong>实现</strong>(implementation)分离的编程（以及设计）技术；封装隐藏了类的实现细节，实现了类的接口和实现的分离。</p>
<p>类的用户只能使用接口而无法访问实现部分。</p>
<h2 id="定义抽象数据类型-abstract-data-type"><a href="#定义抽象数据类型-abstract-data-type" class="headerlink" title="定义抽象数据类型(abstract data type)"></a>定义抽象数据类型(abstract data type)</h2><h3 id="设计Sales-data类"><a href="#设计Sales-data类" class="headerlink" title="设计Sales_data类"></a>设计Sales_data类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">	string BookNo;</span><br><span class="line">	<span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;BookNo;&#125;</span><br><span class="line">	<span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Sales_data的非成员接口函数</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">read</span><span class="params">(istream&amp;, Sales_data&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="定义成员函数"><a href="#定义成员函数" class="headerlink" title="定义成员函数"></a>定义成员函数</h4><p>所有成员都必须在类内声明，但成员函数体可以定义在类内或类外；</p>
<p>在类内定义的成员函数是隐式的inline函数；</p>
<p>在类外定义的成员函数，其定义和声明必须相匹配，且<strong>必须包含它所属的类名</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Sales_data::avg_price</span><span class="params">()</span> <span class="type">const</span></span>&#123;		<span class="comment">//包含类名</span></span><br><span class="line">    <span class="keyword">if</span>(units_sold)</span><br><span class="line">        <span class="keyword">return</span> revenue/units_sold;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h4><blockquote>
<p>C++中成员变量和成员函数时分开存储的，每一个非静态成员函数只会诞生一份函数实例，多个同类型的对象会公用一块代码，this指针就用于区分调用这一块代码的对象</p>
</blockquote>
<p>调用函数时，成员函数通过额外的隐式参数this来访问调用它的对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">total.<span class="built_in">isbn</span>();</span><br><span class="line"><span class="comment">//伪代码，用于说明调用成员函数的实际执行过程</span></span><br><span class="line">Sales_data::<span class="built_in">isbn</span>(&amp;total)</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ol>
<li>始终指向被调用的成员函数所属的对象，默认情况下是一个<strong>指向<u>非常量</u>的常量指针</strong></li>
<li>形参与成员变量同名时，可用this来区分</li>
<li>在类的非晶体成员函数中返回对象本身，可以使用<code>return *this</code></li>
</ol>
<h4 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h4><p>在形参列表后加一个const，可以将this指针修改为<strong>指向<u>常量</u>的常量指针</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo&#125;;	<span class="comment">//常量成员函数(const member function)</span></span><br></pre></td></tr></table></figure>

<p>常量对象、常量对象的引用或指针都只能调用常量成员函数，因为调用成员函数时，一定会隐式地定义一个this指针，只有当this指针是<strong>指向<u>常量</u>的常量指针</strong>时，它才能指向常量对象。</p>
<h4 id="类作用域和成员函数"><a href="#类作用域和成员函数" class="headerlink" title="类作用域和成员函数"></a>类作用域和成员函数</h4><p>编译器处理时，首先编译成员的声明，然后才处理成员函数体（如果有的话），因此无须在意成员出现的次序</p>
<hr>
<p><strong>注意</strong>：通常来讲，把类的<strong>声明</strong>和类的接口函数的<strong>声明</strong>（注意是声明而非定义）放在同一个头文件内，而类的<strong>定义</strong>和类的接口函数的<strong>定义</strong>放在同一个cpp文件内，目的是防止重复包含：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//***Person.h***</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">//对老系统使用下面三句</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#ifndef _PERSON_H_</span></span><br><span class="line"><span class="comment">#define _PERSON_H_</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	string _Name = <span class="string">&quot;ANONYM&quot;</span>;</span><br><span class="line">	string _Address = <span class="string">&quot;UNKNOW&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">const</span> string&amp; <span class="title">GET_NAME</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">const</span> string&amp; <span class="title">GET_ADDRESS</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//***Person.cpp***</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Person.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">const</span> string&amp; <span class="title">Person::GET_NAME</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;_Name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> string&amp; <span class="title">Person::GET_ADDRESS</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;_Address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//***main.cpp***</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Person.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	Person _MyPerson;</span><br><span class="line">	cout &lt;&lt; _MyPerson._Name &lt;&lt; <span class="string">&quot;住在&quot;</span> &lt;&lt; _MyPerson._Address &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; _MyPerson.<span class="built_in">GET_NAME</span>() &lt;&lt; <span class="string">&quot;住在&quot;</span> &lt;&lt; _MyPerson.<span class="built_in">GET_ADDRESS</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="构造函数-constructor"><a href="#构造函数-constructor" class="headerlink" title="构造函数(constructor)"></a>构造函数(constructor)</h3><p>构造函数用于初始化类对象的数据成员，其名字和类名相同，除了没有返回类型，其他与普通函数相同（也可以重载）；</p>
<p>默认情况下，C++编译器至少给一个类添加了3个函数：</p>
<ol>
<li>默认构造函数（无参，函数体空）；</li>
<li>默认析构函数（无参，函数体空）；</li>
<li>默认拷贝构造函数，对属性进行值拷贝；</li>
</ol>
<p>注意事项：</p>
<ul>
<li>如果用户定义有参构造函数，C++不再提供默认构造函数，但会提供默认拷贝构造函数；</li>
<li>如果用户定义拷贝构造函数，C++不再提供其他构造函数；</li>
<li>类中包含一个其他类类型成员，且这个成员的类型没有默认构造函数时，编译器无法初始化该成员</li>
<li>若一个构造函数为所<strong>有参数都提供了默认实参</strong>，则它实际上也定义了默认构造函数；</li>
</ul>
<h3 id="拷贝、赋值和析构"><a href="#拷贝、赋值和析构" class="headerlink" title="拷贝、赋值和析构"></a>拷贝、赋值和析构</h3><p>未主动定义时，编译器将替我们合成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">total = trans;</span><br><span class="line"><span class="comment">//默认赋值操作等价于：</span></span><br><span class="line">total.bookNo = trans.bookNo;</span><br><span class="line">total.units_sold = trans.units_sold;</span><br><span class="line">total.revenue = trans.revenue;</span><br></pre></td></tr></table></figure>

<p>当类需要分配类对象之外的资源（如动态内存）时，合成的版本常常会失效</p>
<h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><p>访问说明符(access specifiers)<code>public</code>和<code>private</code>在类的定义中出现的位置和次数都没有限制</p>
<h3 id="友元-friend"><a href="#友元-friend" class="headerlink" title="友元(friend)"></a>友元(friend)</h3><p>类可以通过友元声明来允许其他类或者函数访问它的<code>protected</code>和<code>private</code>成员：</p>
<ul>
<li><p>友元<strong>声明</strong>只能出现在类定义的内部，位置不限；</p>
</li>
<li><p>友元既不是类的成员也不受它所在区域访问控制级别的约束（即不受<code>public</code>、<code>protected</code>、<code>private</code>的约束）；</p>
</li>
<li><p>友元通常在类的头部&#x2F;尾部集中声明；</p>
</li>
<li><p>友元声明仅仅指定了访问的权限，有必要在类外声明一次这些接口函数（尽管有的编译器不需要）；</p>
</li>
<li><p>友元函数能定义在类内，这样的函数是<strong>隐式内联</strong>的；</p>
</li>
<li><p><strong>可以把其他的类（已经定义过的）定义成友元</strong>，友元类可以访问此类的所有成员；</p>
</li>
<li><p>可以把<strong>某个成员函数</strong>声明为友元，需要指明函数所在的类；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line">    <span class="comment">//Window_mgr::clear必须在Screen类之前被声明</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIndex)</span></span>;	<span class="comment">//指明clear在Window_mgr类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>想要把一组重载函数声明为友元，必须对<strong>每一个进行分别声明</strong>；</p>
</li>
<li><p><strong>友元关系不存在传递性</strong>；</p>
</li>
</ul>
<h2 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h2><p>可以自定义类型别名，必须先定义后使用，同样存在访问限制：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Screen.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> string::size_type pos;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">Screen</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Screen</span>(pos ht, pos wd, <span class="type">char</span> c) :<span class="built_in">height</span>(ht), <span class="built_in">width</span>(wd), <span class="built_in">contents</span>(ht* wd, c) &#123;&#125;</span><br><span class="line">	<span class="comment">//成员函数</span></span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> contents[cursor]; &#125;		<span class="comment">//隐式内联</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">get</span><span class="params">(pos ht, pos wd)</span> <span class="type">const</span></span>;				<span class="comment">//显示内联，并且重载get函数</span></span><br><span class="line">	<span class="function">Screen&amp; <span class="title">move</span><span class="params">(pos r, pos c)</span></span>;							<span class="comment">//能在之后设置为内联</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	pos cursor = <span class="number">0</span>;</span><br><span class="line">	pos height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line">	string contens;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义内联函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen&amp; <span class="title">Screen::move</span><span class="params">(pos r, pos c)</span> </span>&#123;				<span class="comment">//在定义处设置为内联</span></span><br><span class="line">	pos row = r * width;</span><br><span class="line">	cursor = row + c;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Screen.cpp</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">Screen::get</span><span class="params">(pos r, pos c)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">	pos row = r * width;</span><br><span class="line">	<span class="keyword">return</span> contents[row + c];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>inline</code> 函数在链接的时候仅仅在<strong>单个 cpp 文件</strong>中“可见”，并不是全局“可见”，其实是因为<code> inline</code>函数没有被编译成汇编码，无法用于链接，故inline成员函数应该与类定义在同一个头文件中（内联说明只是向编译器发出一个请求，编译器可以选择忽略这个请求）</p>
<h4 id="可变数据成员-mutable-data-member"><a href="#可变数据成员-mutable-data-member" class="headerlink" title="可变数据成员(mutable data member)"></a>可变数据成员(mutable data member)</h4><p>在数据成员的定义前加上<code>mutable</code>关键字，即使是const成员函数也可以改变它的值</p>
<h3 id="返回-this的成员函数"><a href="#返回-this的成员函数" class="headerlink" title="返回*this的成员函数"></a>返回*this的成员函数</h3><ul>
<li><p>如果函数返回类型是该类的引用，且返回值是*this，这意味着函数返回的是对象本身而非对象的副本</p>
</li>
<li><p>const成员函数以引用的形式返回*this时，应该返回一个指向常量的引用（<strong>解引用指向常量的指针将得到一个常量，即使它实际指向的不是常量</strong>）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* pci = &amp;i;		<span class="comment">//指向常量的指针，实际指向了普通整数i</span></span><br><span class="line"><span class="type">int</span>&amp; ir = *pci;				<span class="comment">//错误：不能用非常量初始化常量引用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以通过重载，得到const和非const两个版本的成员函数</p>
</li>
</ul>
<h4 id="对于公共代码使用私有功能函数"><a href="#对于公共代码使用私有功能函数" class="headerlink" title="对于公共代码使用私有功能函数"></a>对于公共代码使用私有功能函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">Screen&amp; <span class="title">display</span><span class="params">(ostream&amp; os)</span> </span>&#123; <span class="built_in">do_display</span>(os); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">const</span> Screen&amp; <span class="title">display</span><span class="params">(ostream&amp; os)</span> <span class="type">const</span> </span>&#123; <span class="built_in">do_display</span>(os); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">do_display</span><span class="params">(ostream&amp; os)</span> <span class="type">const</span> </span>&#123; os &lt;&lt; contents; &#125;		<span class="comment">//内联私有功能函数</span></span><br><span class="line">	string contents;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>非常量display中，this指向一个非常量对象，故可以返回一个普通引用；常量display中，this指向一个常量对象，解引用后为常量。</p>
<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>类在声明之后，定义之前是一个不完全类型，使用情景有限：</p>
<ol>
<li>可以定义指向不完全类型的指针或引用；</li>
<li>可以<strong>声明</strong>（但不能定义）以不完全类型为参数或返回类型的函数；</li>
</ol>
<blockquote>
<p>一个疑问，对于</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> parameter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">X <span class="title">display</span><span class="params">(ostream &amp;os)</span></span>&#123;os &lt;&lt; <span class="keyword">this</span>-&gt;parameter; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>函数display在类X内部，其返回类型是否是不完全类型呢？如果是，为什么此时的display可以定义呢？</p>
<p>一个猜想不一定对，该函数隐式地定义了一个this指针，一切操作都是通过指针完成的；</p>
</blockquote>
<p>只有当类全部完成后才算被定义，所以：</p>
<ul>
<li>类的成员类型不能是该类自己；</li>
<li>类的名字出现后，就被认为是声明过了，因此类的成员类型可以是指向它自身类型的引用或指针；</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++笔记（十四）——类（二）</title>
    <url>/2022/05/11/cpp/cpp-note-14/</url>
    <content><![CDATA[<h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><p>一个类就是一个作用域，在类外，成员的名字都被隐藏起来了</p>
<h3 id="名字查找与类的定义"><a href="#名字查找与类的定义" class="headerlink" title="名字查找与类的定义"></a>名字查找与类的定义</h3><p>名字查找(name lookup)步骤：</p>
<ol>
<li>先在名字所在块寻找声明，只考虑在名字使用之前出现的；</li>
<li>若没有，查找外层作用域；</li>
<li>若最终也没有，则报错；</li>
</ol>
<p>类的定义步骤：</p>
<ol>
<li>编译成员声明；</li>
<li>直到类全部可见后才编译函数体；</li>
</ol>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> Money;</span><br><span class="line">string bal;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Accout</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Money <span class="title">balance</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> bal;&#125;<span class="comment">//先在类Accout内寻找Money声明，没找到；于是匹配到typedef语句</span></span><br><span class="line"><span class="keyword">private</span>:						<span class="comment">//类完全可见后才编译函数体，return 返回名为bal的成员而非string对象</span></span><br><span class="line">    Money bal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><em>练习7.35</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> string Type;</span><br><span class="line"><span class="function">Type <span class="title">initVal</span><span class="params">()</span></span>;				<span class="comment">//这里的Type等价于string</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Exercise</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">double</span> Type;</span><br><span class="line">	<span class="function">Type <span class="title">setVal</span><span class="params">(Type)</span></span>;		<span class="comment">//这里的Type等价于double</span></span><br><span class="line">	<span class="function">Type <span class="title">initVal</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Type <span class="title">Exercise::setVal</span><span class="params">(Type parm)</span> </span>&#123;	<span class="comment">//第一个Type等价于string，第二个等价于double</span></span><br><span class="line">	val = parm + <span class="built_in">initVal</span>();	<span class="comment">//这里的initVal()应该是类内的initVal()，因为setVal前声明了作用域</span></span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Exercise::Type <span class="title">Exercise::setVal</span><span class="params">(Type parm)</span> </span>&#123;</span><br><span class="line">	val = parm + <span class="built_in">initVal</span>();</span><br><span class="line">	<span class="keyword">return</span> val;				<span class="comment">//val是一个int，不能转换为string，可以转换为double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，题目中的<code>initval()</code>函数未定义，需要添加定义</p>
<h2 id="构造函数-constructor"><a href="#构造函数-constructor" class="headerlink" title="构造函数(constructor)"></a>构造函数(constructor)</h2><p>构造函数用于初始化类对象的数据成员，其名字和类名相同，除了没有返回类型，其他与普通函数相同（也可以重载）；</p>
<p>默认情况下，C++编译器至少给一个类添加了3个函数：</p>
<ol>
<li>默认构造函数（无参，函数体空）；</li>
<li>默认析构函数（无参，函数体空）；</li>
<li>默认拷贝构造函数，对属性进行值拷贝；</li>
</ol>
<p>注意事项：</p>
<ul>
<li>如果用户定义有参构造函数，C++不再提供默认构造函数，但会提供默认拷贝构造函数；</li>
<li>如果用户定义拷贝构造函数，C++不再提供其他构造函数；</li>
<li>类中包含一个其他类类型成员，且这个成员的类型没有默认构造函数时，编译器无法初始化该成员</li>
<li>若一个构造函数为所<strong>有参数都提供了默认实参</strong>，则它实际上也定义了默认构造函数；</li>
</ul>
<hr>
<p><em>练习7.39</em></p>
<p>当两者都使用默认实参时，实际上两者的<strong>所有参数都有了默认实参</strong>，即定义了两个默认构造函数，而编译器无法判断哪个默认构造函数更好，出现了<strong>二义性错误</strong>。</p>
<hr>
<h3 id="委托构造函数-delegating-constructor"><a href="#委托构造函数-delegating-constructor" class="headerlink" title="委托构造函数(delegating constructor)"></a>委托构造函数(delegating constructor)</h3><p>C++11新标准中，委托构造函数可以使用它所属类的其他构造函数执行它自己的初始化过程：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//非委托构造函数</span></span><br><span class="line">	<span class="built_in">Sales_data</span>(<span class="type">const</span> string&amp; s, <span class="type">unsigned</span> n, <span class="type">double</span> p):<span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n),<span class="built_in">revenue</span>(p*n)&#123;&#125;</span><br><span class="line">    <span class="comment">//委托构造函数</span></span><br><span class="line">    <span class="built_in">Sales_data</span>(): <span class="built_in">Sales_data</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>)&#123;&#125;</span><br><span class="line">	<span class="built_in">Sales_data</span>(<span class="type">const</span> string&amp; s): <span class="built_in">Sales_data</span>(s, <span class="number">0</span>, <span class="number">0</span>)&#123;&#125;		<span class="comment">//利用第一个构造函数执行初始化</span></span><br><span class="line">    <span class="built_in">Sales_data</span>(istream&amp; is): <span class="built_in">Salse_data</span>()&#123; <span class="built_in">read</span>(is, *<span class="keyword">this</span>); &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p> 当构造函数委托给另一个构造函数时，<strong>受委托的构造函数的初始值列表及其函数体先被执行</strong>，接着才会执行到委托函数的函数体</p>
<hr>
<h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><p><em>练习7.43</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoDefault</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">NoDefault</span>(<span class="type">int</span> i) : <span class="built_in">para</span>(i), s1&#123;<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(i)&#125; &#123;&#125;</span><br><span class="line">	<span class="function">NoDefault <span class="title">display</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="keyword">this</span>-&gt;para &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s1 &lt;&lt; endl; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> para;</span><br><span class="line">	string s1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">C</span>():<span class="built_in">object</span>(<span class="number">5</span>) &#123; &#125;		<span class="comment">//因为NoDefault类没有默认构造函数，所以必须调用接受int的构造函数</span></span><br><span class="line">	<span class="function">C <span class="title">display</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>-&gt;object.<span class="built_in">display</span>(); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	NoDefault object;		<span class="comment">//注意object应该是一个对象，后面不能加()</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="隐式地类类型转换"><a href="#隐式地类类型转换" class="headerlink" title="隐式地类类型转换"></a>隐式地类类型转换</h3><p>通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则（<strong>但是只允许一步隐式类型转换</strong>）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string null_book = <span class="string">&quot;9-999-99999-9&quot;</span>;</span><br><span class="line">item.<span class="built_in">combine</span>(null_book);	<span class="comment">//编译器会先调用Sales_data(null_book)生成一个临时的Sales_data对象，然后将它传递给combine</span></span><br><span class="line">Sales_data item1 = null_book;	<span class="comment">//正确：发生了隐式类型转换</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="string">&quot;9-999-99999-9&quot;</span>);	<span class="comment">//错误：编译器值允许一步类型转换，不能把&quot;9-999-99999-9&quot;转换成string再转换成Sales_data</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">string</span>(<span class="string">&quot;9-999-99999-9&quot;</span>));	<span class="comment">//正确：进行了一次显式转换和一次隐式转换</span></span><br></pre></td></tr></table></figure>

<p>可以用<code>explicit</code>关键字（<strong>只能在类内声明，类外定义时不应重复</strong>）抑制构造函数的隐式转换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> string&amp; s, <span class="type">unsigned</span> n, <span class="type">double</span> p):<span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n),<span class="built_in">revenue</span>(p*n)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(<span class="type">const</span> string&amp; s)</span>:bookNo(s)&#123;</span>&#125;	<span class="comment">//如此就不能用于隐式创建Sales_data对象</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(istream&amp; is)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data::Sales_data</span><span class="params">(istream&amp; is)</span></span>&#123; 			<span class="comment">//错误：不应该出现explicit</span></span><br><span class="line">    <span class="built_in">read</span>(is, *<span class="keyword">this</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="聚合类-aggregate-class"><a href="#聚合类-aggregate-class" class="headerlink" title="聚合类(aggregate class)"></a>聚合类(aggregate class)</h3><p>满足以下条件的类称为聚合类：</p>
<ul>
<li>所有成员都是public；</li>
<li>没有定义任何构造函数；</li>
<li>没有类内初值；</li>
<li>没有基类或virtual函数;</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span>&#123;</span><br><span class="line">    <span class="type">int</span> ival;</span><br><span class="line">    string s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以列表初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Data val1 = &#123;<span class="number">0</span>, <span class="string">&quot;Anna&quot;</span>&#125;;		<span class="comment">//顺序必须一致</span></span><br><span class="line">Data val2= &#123;<span class="string">&quot;Anna&quot;</span>, <span class="number">0</span>&#125;;			<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<h3 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h3><ul>
<li>数据成员必须都是字面值类型（算术类型、引用、指针都属于字面值类型）；</li>
<li>类必须至少含有一个constexpr构造函数；</li>
<li>如果一个数据成员含有类内初始值，其必须是常量表达式；</li>
<li>若成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数；</li>
<li>类必须使用析构函数的默认定义；</li>
</ul>
<h4 id="constexpr构造函数"><a href="#constexpr构造函数" class="headerlink" title="constexpr构造函数"></a>constexpr构造函数</h4><p>尽管构造函数不能是const的，但字面值常量类的构造函数可以是constexpr的，并且一个字面值常量类至少提供一个constexpr构造函数；</p>
<hr>
<p><em>练习7.54</em></p>
<p>不应该，因为constexpr函数的函数体中）必须有且只有一条return 语句（constexpr构造函数除外）。</p>
<p><em>练习7.55</em></p>
<p>不是，因为string不是字面值类型。</p>
<hr>
<h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><p>使用关键字<code>static</code>可以声明静态成员，静态成员存在于任何对象之外（<strong>只存在一个静态成员对象且由所有类对象共享</strong>），静态成员函数也不与任何对象绑定在一起（<strong>没有this指针</strong>，因此在静态成员函数里调用的非静态成员函数也不能使用this指针）。</p>
<p>对于类Account：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123; amount += amount * interestRate; &#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">rate</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> interestRate; &#125;	<span class="comment">//内联静态成员函数定义</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rate</span><span class="params">(<span class="type">double</span>)</span></span>;						<span class="comment">//静态成员函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string owner;</span><br><span class="line">	<span class="type">double</span> amount;</span><br><span class="line">	<span class="type">static</span> <span class="type">double</span> interestRate;						<span class="comment">//静态成员</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">initRate</span><span class="params">()</span></span>;						<span class="comment">//私有静态成员函数声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用作用域运算符直接访问静态成员：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> r;</span><br><span class="line">r = Account::<span class="built_in">rate</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用类的对象、引用或指针来访问静态成员：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Account ac1;</span><br><span class="line">Account *ac2 = &amp;ac1;</span><br><span class="line">r = ac1.<span class="built_in">rate</span>();</span><br><span class="line">r = ac2-&gt;<span class="built_in">rate</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>成员函数不用作用域运算符就能直接使用静态成员；</li>
<li>可以在类外定义静态函数，<strong>此时不应重复<code>static</code>关键字</strong>；</li>
<li>静态成员不属于类的任何一个对象，它们不是在创建类的对象时被定义，因此<strong>必须在类外</strong>定义和初始化静态成员；</li>
<li>类似于全局变量和函数的静态变量，被定义后一直存在于程序的整个生命周期中；</li>
<li>可以为静态成员提供const整数类型的类内初始值，但要求该静态成员必须是constexpr类型；</li>
<li><strong>静态成员可以是其所属的类类型</strong>（非静态只能是引用或指针）；</li>
<li><strong>静态成员可以作为类内函数的默认实参</strong>（非静态不可，在定义类对象之前，无法真正提供一个对象以获取成员的值）；</li>
</ul>
<hr>
<p><em>练习7.58</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//example.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> rate = <span class="number">6.5</span>;			<span class="comment">//错误：静态成员必须在类外初始化</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> vecSize = <span class="number">20</span>;		<span class="comment">//正确：此处vecSize应用场景仅限可以替换它的值的情况，此时不需要区分const和constexpr</span></span><br><span class="line">    <span class="function"><span class="type">static</span> vector&lt;<span class="type">double</span>&gt; <span class="title">vec</span><span class="params">(vecSize)</span></span>;	<span class="comment">//错误：会被识别为定义了一个返回类型为vector&lt;double&gt;的静态成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//example.C</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example.h&quot;</span></span></span><br><span class="line"><span class="type">double</span> Example::rate;					<span class="comment">//错误：此处应该初始化</span></span><br><span class="line">vector&lt;<span class="type">double</span>&gt; Example::vec;			<span class="comment">//据题意应改为vector&lt;double&gt; Example::vec(vecSize);</span></span><br><span class="line"><span class="comment">//最好再加一句对vecSize的定义</span></span><br></pre></td></tr></table></figure>




]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++笔记（十五）——IO库</title>
    <url>/2022/05/14/cpp/cpp-note-15/</url>
    <content><![CDATA[<h1 id="IO库"><a href="#IO库" class="headerlink" title="IO库"></a>IO库</h1><h2 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h2><ul>
<li><p>IO对象无拷贝或赋值；</p>
</li>
<li><p>IO类的条件状态(condition state)；</p>
<p>badbit：指出流已经崩溃，最右边三位是100；</p>
<p>failbit：指出一个IO操作失败了，最右边三位是010；</p>
<p>eofbit：指出流达到了文件结束，最右边三位是001；</p>
<p>goodbit：指出流未处于错误状态，此值保证为0；</p>
<p>s.clear()可以为流s中所有状态复位；</p>
</li>
<li><p><strong>如果程序崩溃，输出缓冲区不会被刷新</strong>；</p>
<p>在调试已经崩溃的程序时，需要确认已经输出的数据是否刷新，否则可能会浪费时间在追踪代码为什么没有执行，而实际上代码已经执行了，只是输出停留在缓冲区；</p>
</li>
</ul>
<h2 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h2><p>头文件fstream定义了三个类型来支持文件IO：</p>
<ol>
<li>ifstream：从给定文件中读取数据；</li>
<li>ofstream：向给定文件中写入数据；</li>
<li>fstream：可以读写给定文件；</li>
</ol>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++笔记（二）——const限定符</title>
    <url>/2022/04/20/cpp/cpp-note-2/</url>
    <content><![CDATA[<h1 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h1><h2 id="const对象"><a href="#const对象" class="headerlink" title="const对象"></a>const对象</h2><p>const对象一旦创建后其值就不可改变，因此必须初始化；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="built_in">get_size</span>();	<span class="comment">//正确：运行时初始化，get_size()为有返回值的函数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> j = <span class="number">42</span>;			<span class="comment">//正确：编译时初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> k;				<span class="comment">//错误：k是一个未经初始化的常量</span></span><br></pre></td></tr></table></figure>
<p>默认状态下，const对象仅在文件内有效，因为编译器将在编译过程中会把用到该变量的地方都替换成对应的值，每个用了const对象的文件都必须含有对它的定义而非声明；<br>如：<br>在test1中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">1</span>;	<span class="comment">//定义全局常量i，初始化为1</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">2</span>;			<span class="comment">//定义全局变量j，初始化为2</span></span><br></pre></td></tr></table></figure>
<p>test2中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="type">int</span> i;</span><br><span class="line">	cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>test3中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="type">int</span> j;</span><br><span class="line">	cout &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中test2会报错error LNK2001: 无法解析的外部符号 “int i”；而test3中能够得到输出2。<br>对于一种const变量，它的初始值不是一个常量表达式，如果想只在一个文件中定义这类const对象，而且在其他多个文件中声明并使用它，方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file_1.cpp中</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize = <span class="built_in">fcn</span>();</span><br><span class="line"><span class="comment">//file_1.h中</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize;	<span class="comment">//与file_1.cpp中定义的bufSize是同一个</span></span><br></pre></td></tr></table></figure>
<h2 id="对常量的引用-reference-to-const"><a href="#对常量的引用-reference-to-const" class="headerlink" title="对常量的引用(reference to const)"></a>对常量的引用(reference to const)</h2><p>“对常量的引用”可以简称为“常量引用”，因为引用不是一个对象，所以实际上不存在常量引用</p>
<p>对常量进行引用时，引用也必须为常量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">1034</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = ci;	<span class="comment">//正确：引用及其对应的对象都是常量</span></span><br><span class="line"></span><br><span class="line">r1 = <span class="number">42</span>;			<span class="comment">//错误：r1是对常量的引用，不可改变其值</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = ci;		<span class="comment">//错误：试图让一个非常量引用指向一个常量对象</span></span><br></pre></td></tr></table></figure>
<h3 id="常量引用的两个例外（待补充）"><a href="#常量引用的两个例外（待补充）" class="headerlink" title="常量引用的两个例外（待补充）"></a>常量引用的两个例外（待补充）</h3><ul>
<li><h4 id="初始化常量引用时允许用任意表达式作为初值，只要其结果能够转换成常量引用的类型即可"><a href="#初始化常量引用时允许用任意表达式作为初值，只要其结果能够转换成常量引用的类型即可" class="headerlink" title="初始化常量引用时允许用任意表达式作为初值，只要其结果能够转换成常量引用的类型即可"></a>初始化常量引用时允许用任意表达式作为初值，只要其结果能够转换成常量引用的类型即可</h4></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = i;		<span class="comment">//允许将const int&amp;绑定到一个普通int对象上</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = <span class="number">42</span>;		<span class="comment">//正确</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 = r1 * <span class="number">2</span>;	<span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;r4 = r4 * <span class="number">2</span>;		<span class="comment">//错误：r4是一个普通的非常量引用</span></span><br></pre></td></tr></table></figure>
<p>原因：在使用常量引用时，系编译器生成了一个与该常量引用同类型的临时量(temporary)对象，再将常量引用绑定在这个临时量对象上。</p>
<p>常量引用绑定的对象可以是非const对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i =<span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r1 = i;			<span class="comment">//引用ri绑定对象i</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = i;		<span class="comment">//r2也绑定对象i，当时不允许通过r2修改i的值</span></span><br><span class="line">r1 = <span class="number">0</span>;					<span class="comment">//r1并非常量，i的值修改为0</span></span><br><span class="line">r2 = <span class="number">0</span>;					<span class="comment">//错误：r2是一个常量引用，不可通过r2修改i的值</span></span><br></pre></td></tr></table></figure>
<h2 id="指向常量的指针-pointer-to-const"><a href="#指向常量的指针-pointer-to-const" class="headerlink" title="指向常量的指针(pointer to const)"></a>指向常量的指针(pointer to const)</h2><p>指向常量的指针不能用于改变其所指对象的值；要想存放常量对象的地址，只能使用指向常量的指针。</p>
<h3 id="指向常量的指针的两个例外（待补充）"><a href="#指向常量的指针的两个例外（待补充）" class="headerlink" title="指向常量的指针的两个例外（待补充）"></a>指向常量的指针的两个例外（待补充）</h3><ul>
<li><h4 id="允许一个指向常量的指针指向一个非常量对象，指向常量的指针没有规定其所指对象必须是一个常量"><a href="#允许一个指向常量的指针指向一个非常量对象，指向常量的指针没有规定其所指对象必须是一个常量" class="headerlink" title="允许一个指向常量的指针指向一个非常量对象，指向常量的指针没有规定其所指对象必须是一个常量"></a>允许一个指向常量的指针指向一个非常量对象，指向常量的指针没有规定其所指对象必须是一个常量</h4></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;		</span><br><span class="line"><span class="type">double</span> *ptr = &amp;pi;			<span class="comment">//错误：ptr是一个普通指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *cptr = &amp;pi;	<span class="comment">//正确：cptr可以指向一个双精度常量</span></span><br><span class="line">*cptr = <span class="number">42</span>;					<span class="comment">//错误：不能给*cptr赋值</span></span><br></pre></td></tr></table></figure>
<p>原因同“对常量的引用”</p>
<p><u><em>ps：所谓指向常量的指针或常量引用，不过是指针或引用“自以为是”罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象的值。</em></u></p>
<h2 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h2><p>引用不是对象，而指针是对象，因此允许把指针本身定义为常量，即常量指针(const pointer)。常量指针必须初始化，而且一旦初始化后，它的值（存放在指针中的地址）就不能再改变了。把*放在const关键字之前，这样书写说明不变的是指针而非指针指向的那个值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span>* <span class="type">const</span> curErr = &amp;errNumb;	<span class="comment">//curErr是一个常量指针</span></span><br><span class="line">	<span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">double</span>* <span class="type">const</span> pip1 = &amp;pi;	<span class="comment">//pip是一个指向常量的常量指针</span></span><br><span class="line">    <span class="type">double</span>* <span class="type">const</span> pip2 = &amp;pi;		<span class="comment">//错误：pip2并不是一个指向常量的指针，不能“const double*”类型的值不能用于初始化“double* const”类型的实体</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指针本身是常量，不代表不能通过指针修改其所指对象的值，能否这样做取决于所指对象的类型，<u>即可以通过常量指针修改非常量对象的值</u>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> k = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p = &amp;i;</span><br><span class="line">*p = j;		<span class="comment">//正确：改变p的值（地址）存放的对象的值，即把i赋值为j，但并没有改变p的值（地址）</span></span><br><span class="line">			<span class="comment">//此操作后i = 0， j = 0， k = 2；</span></span><br><span class="line">p = &amp;k;		<span class="comment">//错误：此操作为把p赋值为k的地址，而p是一个常量指针，其值不可改变</span></span><br></pre></td></tr></table></figure>

<p><em><strong>建议：想要弄清这些声明的含义，最有效的方法是从右向左阅读</strong></em></p>
<p><em>练习2.27</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>  &amp;<span class="type">const</span> r2 = <span class="number">0</span>;	<span class="comment">//错误：引用不是对象，没有常量引用，只有对常量的引用</span></span><br></pre></td></tr></table></figure>

<p>虽然有的编译器会自动忽略掉&amp;后的const，但切记不要这样做。</p>
<img src="/2022/04/20/cpp/cpp-note-2/1650683511366.png" class="" width="1650683511366">

<h2 id="顶层const和底层const"><a href="#顶层const和底层const" class="headerlink" title="顶层const和底层const"></a>顶层const和底层const</h2><p>顶层const(top-level const)：表示指针本身是一个常量</p>
<p>底层const(low-level const)：表示指针所指对象是一个常量</p>
<p>更一般的，顶层const表示任意的对象是常量，底层const表示指针和引用等所指对象和所引用对象是常量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p1 = &amp;i;			<span class="comment">//不能改变p1的值，这是一个顶层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">42</span>;			<span class="comment">//不能改变ci的值，这是一个顶层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p2 = &amp;ci;		<span class="comment">//允许改变p2的值，但不能改变p2所指对象的值，这是一个底层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p3 = p2;	<span class="comment">//靠近p3的const是顶层，远离p3的const是底层</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; r1 = ci;			<span class="comment">//用于声明引用的const都是底层</span></span><br><span class="line"></span><br><span class="line">i = ci;						<span class="comment">//正确：拷贝ci的值，ci是一个顶层const，对此操作无影响</span></span><br><span class="line">p2 = p3;					<span class="comment">//正确：p2和p3所指对象类型相同，即两者都是底层常量，p2不是顶层const，其值可以改变，p3顶层const部分不影响</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p = p3;				<span class="comment">//错误：p3包含底层const对象，即p3所指对象为常量，而p所指对象不是，故不能将p3的值赋予p</span></span><br><span class="line"><span class="type">int</span>* p = &amp; *p3;				<span class="comment">//该操作完全同上，&amp;和*互为逆操作</span></span><br><span class="line">p2 = &amp;i;					<span class="comment">//正确：int*能转换成const int*，即底层非常量可以转换为底层常量</span></span><br><span class="line"><span class="type">int</span>&amp; r2 = ci;				<span class="comment">//错误：非常量int&amp;不能绑定到int常量上</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; r3 = i;			<span class="comment">//正确：常量int&amp;可以绑定到int非常量上</span></span><br></pre></td></tr></table></figure>

<p>提示：顶层const的对象初始化后不能被赋值，底层const的对象不能改变其所指或所引用对象的值，非底层const的对象不能拷贝底层const的对象。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++笔记（三）——处理类型</title>
    <url>/2022/04/23/cpp/cpp-note-3/</url>
    <content><![CDATA[<h1 id="常量表达式和constexpr"><a href="#常量表达式和constexpr" class="headerlink" title="常量表达式和constexpr"></a>常量表达式和constexpr</h1><h2 id="常量表达式-const-expression"><a href="#常量表达式-const-expression" class="headerlink" title="常量表达式(const expression)"></a>常量表达式(const expression)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> max_files = <span class="number">20</span>;			<span class="comment">//max_files是常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> limit = max_filse + <span class="number">1</span>;	<span class="comment">//limit是常量表达式</span></span><br><span class="line"><span class="type">int</span> staff_size = <span class="number">27</span>;				<span class="comment">//staff_size不是常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> sz = <span class="built_in">get_size</span>();			<span class="comment">//sz不是常量表达式，其具体值在程序运行时才能获得，而不是编译时获得</span></span><br></pre></td></tr></table></figure>

<p>在复杂系统中，无法分辨一个初始值到底是不是常量表达式。这种情况下，对象的定义和使用根本就是两回事儿。</p>
<h2 id="constexpr变量"><a href="#constexpr变量" class="headerlink" title="constexpr变量"></a>constexpr变量</h2><p>C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mf = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> limit = mf + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> sz = <span class="built_in">size</span>();		<span class="comment">//只有当size是一个constexpr函数时，这才是一条正确语句</span></span><br></pre></td></tr></table></figure>

<p>同时C++11新标准也允许定义一种constexpr函数，这种函数必须简单到在编译时就可以计算其结果，这样就能用constexpr函数去初始化constexpr变量。</p>
<p>在声明constexpr时，用到的类型只能是字面值类型</p>
<h2 id="字面值类型-literal-type"><a href="#字面值类型-literal-type" class="headerlink" title="字面值类型(literal type)"></a>字面值类型(literal type)</h2><p>目前接触过的数据类型中，算术类型、引用和指针都属于字面值类型，但被定义成constexpr的指针初值必须输nullptr或者0，或者存储于某个固定地址中的对象。</p>
<p>函数体内定义的变量一般并非存放在固定地址中，所有函数体之外的对象其地址固定不变。函数体内允许定义一类有效范围超出函数本身的变量，该变量夜游固定地址。</p>
<h2 id="constexpr指针"><a href="#constexpr指针" class="headerlink" title="constexpr指针"></a>constexpr指针</h2><p>constexpr声明中定义了一个指针，限定符constexpr只对指针有效：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* p = <span class="literal">nullptr</span>;			<span class="comment">//p是一个指向整型常量的指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span>* q = <span class="literal">nullptr</span>;		<span class="comment">//q是一个指向整数的常量指针</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h1><h2 id="类型别名-type-alias"><a href="#类型别名-type-alias" class="headerlink" title="类型别名(type alias)"></a>类型别名(type alias)</h2><p>传统定义方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages;			<span class="comment">//wages是double的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wages base, * p;		<span class="comment">//base是double的同义词，p是double*的同义词</span></span><br></pre></td></tr></table></figure>

<p>C++11新标准定义方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> SI = Sales_item;			<span class="comment">//SI是Sales_item的同义词</span></span><br></pre></td></tr></table></figure>

<p>类型别名引入的易错点，从右向左读可以轻松理解以下语句</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> * pstring;			<span class="comment">//pstring是char*的同义词，此时pstring的基本数据类型是指针</span></span><br><span class="line"><span class="type">const</span> pstring cstr = <span class="number">0</span>;			<span class="comment">//const限定了pstring，即基本数据类型是const pstring，指向char的常量指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * cstr = <span class="number">0</span>;			<span class="comment">//const限定了char，即基本数据类型是const char，指向char常量的指针</span></span><br><span class="line"><span class="type">const</span> pstring * ps;				<span class="comment">//ps是一个指针，其所指对象是一个指向char的常量指针</span></span><br></pre></td></tr></table></figure>

<h2 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h2><p>编程时常常需要把表达式的值赋给变量，这就要求声明变量时清楚地知道表达式的类型。C++11新标准引入了auto类型说明符，它可以分析表达式所属的类型</p>
<p>auto定义的变量必须有初始值，用以推断该变量的类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> item = val1 + val2;		<span class="comment">//item初始化为val1和val2相加的结果，由该结果可以推断出item的类型</span></span><br></pre></td></tr></table></figure>

<p>auto可以在一条语句中定义多个变量，由于一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>, * p = &amp;i;			<span class="comment">//正确：i是整数、p是整型指针</span></span><br><span class="line"><span class="keyword">auto</span> sz = <span class="number">0</span>, pi = <span class="number">3.14</span>;			<span class="comment">//错误：sz和pi的类型不一致</span></span><br></pre></td></tr></table></figure>

<p>auto一般会忽略顶层const，但保留底层const：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;					<span class="comment">//b是一个普通整数</span></span><br><span class="line"><span class="keyword">auto</span> c = cr;					<span class="comment">//c是一个普通整数（cr只是ci的别名，实际参与初始化的是被引用对象ci）</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i;					<span class="comment">//d是一个普通整型指针</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci;					<span class="comment">//e是一个指向整数常量的指针（对常量对象取地址是一种底层const）</span></span><br></pre></td></tr></table></figure>

<p>如果希望通过auto定义一个顶层const对象，则需要：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> f = ci;</span><br><span class="line"><span class="keyword">auto</span>&amp; r1 = <span class="number">42</span>;					<span class="comment">//错误：不能为非常量引用绑定字面值</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; r2 = <span class="number">42</span>;			<span class="comment">//正确：可以为常量引用绑定字面值</span></span><br></pre></td></tr></table></figure>

<p>当设置一个类型为auto的引用时，顶层常量属性仍然保留，即得到的引用具有底层常量属性：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">1</span>;				<span class="comment">//i具有顶层常量属性</span></span><br><span class="line"><span class="keyword">auto</span>&amp; r = i;					<span class="comment">//r是一个对整数常量的引用，此时r是一个对常量的引用</span></span><br><span class="line">r = <span class="number">100</span>;						<span class="comment">//错误：不可修改对常量的引用所引用的对象</span></span><br></pre></td></tr></table></figure>

<p><em><strong>切记，auto只是推断声明符的类型，而&amp;和*只是声明符的修饰符</strong></em></p>
<p>在声明语句中，*声明一个指针变量，&amp;声明一个对象引用；在定义语句中，*取指针所指向的数据，&amp;取对象的地址。</p>
<h2 id="decltype类型说明符"><a href="#decltype类型说明符" class="headerlink" title="decltype类型说明符"></a>decltype类型说明符</h2><p>C++11新标准引入了decltype，用于从表达式的类型推断出要定义的变量的类型，但是并不用该表达式的值初始化变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) sum = x;			<span class="comment">//sum的类型就是f()的返回类型</span></span><br></pre></td></tr></table></figure>

<p>decltype处理顶层const和引用的方式与auto不同：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">0</span>, &amp; cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>;				<span class="comment">//x的类型是const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x;				<span class="comment">//y的类型是const int&amp;，y绑定到常量x</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z;					<span class="comment">//错误：z是一个引用，必须初始化</span></span><br></pre></td></tr></table></figure>

<p><u>上述例子中，在decltype()中ci和cj不是一个同义词，而在其他任何地方，cj都是ci的同义词</u></p>
<p>几个需要注意的点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>, * p = &amp;i, &amp; r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b;				<span class="comment">//正确：尽管r是一个引用，但加法的结果是int而非一个引用，因此b是一个未初始化的int</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c;					<span class="comment">//错误：表达式内容是解引用操作，则decltype得到引用类型，故c是int&amp;，必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) d;				<span class="comment">//错误：d是int&amp;，必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(i) e;					<span class="comment">//正确：e是一个未初始化的int</span></span><br><span class="line"><span class="keyword">decltype</span>((i + <span class="number">0</span>)) f;			<span class="comment">//正确：f是一个未初始化的int</span></span><br></pre></td></tr></table></figure>

<p>上述例子中，当变量i被加上了一层括号时，编译器会把它当成一个表达式，而变量是一种<u><strong>可以作为赋值语句左值的特殊表达式</strong></u>，所以decltype((i))的结果类型是一个引用类型int&amp;</p>
<p><em>练习2.36</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) c = a;</span><br><span class="line"><span class="keyword">decltype</span>((b)) d = a;			<span class="comment">//d是一个引用，被引用的对象是a</span></span><br><span class="line">++c;</span><br><span class="line">++d;							<span class="comment">//d是a的同义词，实际进行操作时将d替换为a</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，c是int型，d是int&amp;型，最后a、b、c、d四个值都是4</p>
<p><em>练习2.37</em></p>
<p>如果i是int，则表达式i&#x3D;x的类型是int&amp;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) c = a;				<span class="comment">//c是一个整数，初始化为a</span></span><br><span class="line"><span class="keyword">decltype</span>(a = b) d = a;			<span class="comment">//d是一个引用，被引用的对象是a</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++笔记（四）——自定义数据结构</title>
    <url>/2022/04/23/cpp/cpp-note-4/</url>
    <content><![CDATA[<h1 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h1><p>数据结构是把一组相关的数据元素组织起来然后使用它们的策略和方法，如Sales_item类，把书本的ISBN编号、售出量和销售收入等数据组织在了一起，并且提供如isbn函数、&gt;&gt;、&lt;&lt;、+、+&#x3D;等运算在内的一系列操作，Sales_item类就是一个数据结构。</p>
<p>C++允许用户以类的形式自定义数据类型。</p>
<h2 id="定义Sales-data类型"><a href="#定义Sales-data类型" class="headerlink" title="定义Sales_data类型"></a>定义Sales_data类型</h2><p>在第七章之前，都使用struct（结构体）来自定义数据类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;									<span class="comment">//注意：类体右侧的表示结束的花括号后必须写一个分号，因为类体后面可以紧跟变量名以示对该类型对象的定义</span></span><br></pre></td></tr></table></figure>

<p>{}中的三条语句定义了struct的数据成员(data member)，C++11新标准规定，可以为数据成员提供一个类内初始值(in-class initializer)，没有初始值的成员将被默认初始化。</p>
<p><strong>千万牢记，定义数据类型的{}之后一定要有分号，而定义函数的{}之后则不需要分号。</strong></p>
<p>定义该类型的对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span>&#123;<span class="comment">/*...*/</span>&#125; accum, trans, *salesptr;</span><br><span class="line"><span class="comment">//以下两条语句等同于上一条语句，但更易读一些</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span>&#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line">Sales_data accum, trans, *salesptr;</span><br></pre></td></tr></table></figure>

<p><em>补充：cout标准输出(standard output)，cerr标准错误(standard error)，clog用来输出程序运行时的一般性信息。</em></p>
<h2 id="编写自己的头文件"><a href="#编写自己的头文件" class="headerlink" title="编写自己的头文件"></a>编写自己的头文件</h2><p>类一般都不定义在函数体内。为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在的头文件的名字应与类的名字一样。</p>
<p>头文件通常包含那些只能被定义一次的实体(entity)，如类、const和constexpr变量（定义时添加extern关键字）等。</p>
<p>确保头文件多次包含仍能安全工作的常用技术是<strong>预处理器</strong>(preprocessor)，它由C++语言从C语言里继承而来。#include就是一项预处理功能，当预处理器看到#include标记时就会用指定的头文件内容代替#include。</p>
<p>C++还会用到一项预处理功能是头<strong>文件保护符</strong>(header guard)，依赖于预处理变量。预处理变量有两种状态：已定义和未定义。#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真。</p>
<p>如此可以有效防止重复包含：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SALES_DATA_H				<span class="comment">//变量未定义时检查结果为真，执行后续操作直到#endif为止</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SALES_DATA_H				<span class="comment">//把SALES_DATA_H设定为预处理变量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><u><strong>头文件保护符必须唯一，通常是基于头文件中类的名字来构建保护符的名字。为了避免与程序中的其他实体发生名字冲突，一般把预处理变量的名字全部大写。</strong></u></p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++笔记（五）——标准库类型string</title>
    <url>/2022/04/27/cpp/cpp-note-5/</url>
    <content><![CDATA[<h1 id="字符串、向量和数组"><a href="#字符串、向量和数组" class="headerlink" title="字符串、向量和数组"></a>字符串、向量和数组</h1><p>命名空间的using声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> namespaece std;				<span class="comment">//using声明，获取std中的所有名字</span></span><br><span class="line"><span class="keyword">using</span> std::cin;						<span class="comment">//using声明，当我们使用名字cin时，从std中获取它</span></span><br></pre></td></tr></table></figure>

<h2 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>					<span class="comment">//一定要包含string头文件</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br></pre></td></tr></table></figure>

<h3 id="定义和初始化string对象"><a href="#定义和初始化string对象" class="headerlink" title="定义和初始化string对象"></a>定义和初始化string对象</h3><p>几个初始化方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s1;							<span class="comment">//默认初始化，s1是一个空串</span></span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(s1)</span></span>;						<span class="comment">//直接初始化(direct initialization)，s2是s1的副本</span></span><br><span class="line">string s2 = s1;						<span class="comment">//拷贝初始化(copy initialization)，s2是s1的副本</span></span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(<span class="string">&quot;value&quot;</span>)</span></span>;					<span class="comment">//直接初始化，s3是字面值&quot;value&quot;的副本，除了字面值最后的那个空字符外</span></span><br><span class="line">string s3 = <span class="string">&quot;value&quot;</span>;				<span class="comment">//拷贝初始化，s3是字面值&quot;value&quot;的副本</span></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(n, <span class="string">&#x27;c&#x27;</span>)</span></span>;					<span class="comment">//直接初始化，s4是由连续n个字符c组成的串</span></span><br><span class="line">string s5 = <span class="built_in">string</span>(<span class="number">10</span>,<span class="string">&#x27;c&#x27;</span>)			<span class="comment">//拷贝初始化，创建了一个临时对象用于拷贝，s5内容是cccccccccc</span></span><br></pre></td></tr></table></figure>

<h3 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作"></a>string对象上的操作</h3><p>读入数量未知的string对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string word;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; word)				<span class="comment">//反复读取，直到输入文件结束标记</span></span><br><span class="line">        cout &lt;&lt; word &lt;&lt; endl;		<span class="comment">//逐个输出单词，每个单词之间有一个换行符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取整行：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(cin, line))		<span class="comment">//如果输入换行符，会直接结束读取，并返回结果（结果为空string）</span></span><br><span class="line">        cout &lt;&lt; line &lt;&lt; endl;		<span class="comment">//触发getline的换行符被丢弃掉了，所以手动加上换行符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>empty根据string是否为空返回一个布尔值，可以用来筛除空string：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string line;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(cin,line))</span><br><span class="line">		<span class="keyword">if</span>(!line.<span class="built_in">empty</span>())			<span class="comment">//只有当line是非空string时，才会执行输出</span></span><br><span class="line">			cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>size返回一个size_type类型的值，表示string对象的大小，它是一个无符号的值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> len = line.<span class="built_in">size</span>();				<span class="comment">//len的类型是string::size_type</span></span><br></pre></td></tr></table></figure>

<p><em><strong>切记，表达式中混用带符号数和无符号数时，带符号数会自动转换成无符号数，负值会转换成（负值+无符号数的模）</strong></em> <em>（int是有符号数）</em></p>
<p>字面值和string对象相加：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//必须确保+两侧的对象至少有一个是string</span></span><br><span class="line">string s1 = <span class="string">&quot;hello&quot;</span>, s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">string s3 = s1 + <span class="string">&quot;, &quot;</span> + s2 + <span class="string">&#x27;\n&#x27;</span>;	<span class="comment">//正确</span></span><br><span class="line">string s4 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;, &quot;</span> + s2;	<span class="comment">//错误：不能把字面值直接相加</span></span><br><span class="line">string s4 = (<span class="string">&quot;hello&quot;</span> + <span class="string">&quot;, &quot;</span>) + s2;	<span class="comment">//按照加法运算符的工作机理，上一条语句与这条语句等价</span></span><br><span class="line">string s5 = s1 + <span class="string">&quot;, &quot;</span> + <span class="string">&quot;world&quot;</span>;	<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<p><em>由于历史原因，也为了与C兼容，C++中字符串字面值并不是string对象，它们是不同的类型</em></p>
<hr>
<p><em>练习3.5</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string total, s_in;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; s_in) &#123;</span><br><span class="line">		total = total + <span class="string">&quot; &quot;</span> + s_in;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="处理string对象中的字符"><a href="#处理string对象中的字符" class="headerlink" title="处理string对象中的字符"></a>处理string对象中的字符</h3><p>C++11新标准：范围for语句(range for)：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : <span class="string">&quot;some string&quot;</span>)		<span class="comment">//每次迭代，都把&quot;&quot;中的下一个字符拷贝给c</span></span><br><span class="line">	cout &lt;&lt; c &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>统计string中的标点符号数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello World!!!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(s.<span class="built_in">size</span>()) punct_cnt = <span class="number">0</span>;	<span class="comment">//定义punct_cnt为size_type类型</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : s)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ispunct</span>(c))					<span class="comment">//ispunct()函数在&lt;cctype&gt;中，&lt;string&gt;已经包含了&lt;cctype&gt;</span></span><br><span class="line">        ++punct_cnt;</span><br><span class="line">cout &lt;&lt; punct_cnt &lt;&lt; <span class="string">&quot; punctuation characters in &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>改变string中字符的值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello World!!!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : s)					<span class="comment">//c是对s中某个字符的引用</span></span><br><span class="line">    c = <span class="built_in">toupper</span>(c);					<span class="comment">//通过c来将s中的字符改为大写，toupper()是&lt;ctype.h&gt;中函数，&lt;cctype&gt;中已经包含了&lt;ctype.h&gt;</span></span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>利用下标运算符处理string的部分字符：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;some string&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!s1.<span class="built_in">empty</span>())&#123;					<span class="comment">//下标取值范围是[0, s1.size()-1]，超出此范围会读出未知结果</span></span><br><span class="line">    s1[<span class="number">0</span>] = <span class="built_in">toupper</span>(s1[<span class="number">0</span>]);			<span class="comment">//将s1的第一个字符赋值为大写</span></span><br><span class="line">    cout &lt;&lt; s1[<span class="number">0</span>] &lt;&lt; endl;			<span class="comment">//输出s1的第一个字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种处理部分字符的方式是使用迭代器，暂不介绍。</p>
<p>使用下标执行迭代：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello World&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(s.<span class="built_in">size</span>()) index = <span class="number">0</span>; index != s.<span class="built_in">size</span>() &amp;&amp; !<span class="built_in">isspace</span>(s[index]); ++index)</span><br><span class="line">    s[index] = <span class="built_in">toupper</span>(s[index]);</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;					<span class="comment">//输出结果为HELLO World</span></span><br></pre></td></tr></table></figure>

<p>注意，C++中<code>&amp;&amp;</code> 运算符只有在左侧运算对象为真时，才会检查右侧的运算对象，上述写法中保证了下标取值合理时才访问<code>s[index]</code>。</p>
<p>使用下标执行随机访问：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> string hexdigits = <span class="string">&quot;0123456789ABCDEF&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Enter a series of numbers between 0 and 15&quot;</span> &lt;&lt; endl;</span><br><span class="line">string result;						<span class="comment">//初始化为空string</span></span><br><span class="line">string::size_type n;				<span class="comment">//定义n为size_type类型，但注意此处并没有初始化</span></span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; n)</span><br><span class="line">    <span class="keyword">if</span> (n &lt; hexdigits.<span class="built_in">size</span>())</span><br><span class="line">        result += hexdigits[n];		<span class="comment">//根据输入来拼接result</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Your hex number is: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<hr>
<p><em>练习3.6</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>					<span class="comment">//&lt;string&gt;里面已经包含了&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string str;</span><br><span class="line">	cin &gt;&gt; str;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : str)</span><br><span class="line">		c = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; str;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>练习3.9</em></p>
<p>不合法，s为空字符串，第一个元素是未知的，虽然vs2022中会输出一个空字符，但是不同机器上得到的结果可能会不同。</p>
<p><em>练习3.10</em></p>
<p>但是好像并不能识别中文的标点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string str, result;</span><br><span class="line">	cin &gt;&gt; str;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> c : str)</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">ispunct</span>(c))</span><br><span class="line">			result += c;</span><br><span class="line">	cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>练习3.11</em></p>
<p><code>c</code>是<code>const char&amp;</code>类型的值，<code>for</code>语句块中不给c赋值的话就合法，否则不合法。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++笔记（六）——标准库类型vector</title>
    <url>/2022/04/29/cpp/cpp-note-6/</url>
    <content><![CDATA[<h2 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h2><p>vector表示对象的集合，其中所有的对象类型都相同。集合中每个对象都有一个与之对应的索引，索引用于访问对象。因为vector“容纳着”其他对象，所以它也被称为**容器(container)**。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>					<span class="comment">//一定要包含vector头文件</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br></pre></td></tr></table></figure>

<p>C++语音既有类模板(class template)，也有函数模板，其中<code>vector</code>是一个类模板。模板本身不是类或函数，可以将模板看做编译器生成类或函数编写的一份说明。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vector是模板而非类型，由vector生成的类型必须包含vector中元素的类型</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;					<span class="comment">//ivec保存int类型对象，初始化为空vector</span></span><br><span class="line">vector&lt;Sales_item&gt; Sales_vec;		<span class="comment">//保存Sales_item类型对象</span></span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; file;		<span class="comment">//该向量的元素是vector对象，该语句为C++11的定义形式</span></span><br><span class="line">vector&lt;vector&lt;string&gt; &gt; file;		<span class="comment">//老式定义形式，多一个空格，即vector&lt;vector&lt;string&gt;(空格)&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意，<u><strong>引用本身不是对象，所以不可以称为vector的元素</strong></u>。</p>
<h3 id="定义和初始化vector对象"><a href="#定义和初始化vector对象" class="headerlink" title="定义和初始化vector对象"></a>定义和初始化vector对象</h3><p>除了与string对象类似的几种初始化方式外，vector还有列表初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; v1&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span>&#125;;	<span class="comment">//必须使用花括号</span></span><br></pre></td></tr></table></figure>

<p>注意：区分列表初始化使用的<u><strong>花括号</strong></u>和直接初始化使用的<u><strong>圆括号</strong></u>。</p>
<p>值初始化(value-initialized)，即只声明vector对象容纳的元素数量，由库创建元素初值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初值根据元素的类型来决定</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>)</span></span>;				<span class="comment">//10个元素，全部初始化为0</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec</span><span class="params">(<span class="number">10</span>)</span></span>;			<span class="comment">//10个元素，全部初始化为空string</span></span><br></pre></td></tr></table></figure>

<p>当花括号中元素不能列表初始化vector时，编译器会尝试用默认值初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; v2&#123;<span class="number">10</span>&#125;;			<span class="comment">//10是int，不能初始化string元素，结果：等价于vector&lt;string&gt; v2(10)</span></span><br><span class="line">vector&lt;string&gt; v2&#123;<span class="number">10</span>, <span class="string">&quot;hi&quot;</span>&#125;;	<span class="comment">//同理，等价于vector&lt;string&gt; v2(10, &quot;hi&quot;)</span></span><br></pre></td></tr></table></figure>

<h3 id="向vector中添加元素"><a href="#向vector中添加元素" class="headerlink" title="向vector中添加元素"></a>向vector中添加元素</h3><p>利用vector的成员函数push_back向其中添加元素：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string word;</span><br><span class="line">vector&lt;string&gt; text;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word) &#123;		<span class="comment">//输入为string对象时执行&#123;&#125;内语句</span></span><br><span class="line">	text.<span class="built_in">push_back</span>(word);	<span class="comment">//将word添加到text中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<strong>vector对象能高效增长</strong>，因此在定义vector对象时设定其大小没有什么必要，事实上如果这么做性能可能更差。同时，高效便捷地向vector中添加元素，要求编写程序时确保所写的循环正确无误，**<u>尤其是可能改变vector对象容量的循环</u>**，如：for语句体内不应该改变其所遍历序列的大小，范围for循环内不能像vector添加元素。如果容器的容量不确定，则不能说遍历。</p>
<h3 id="其他vector操作"><a href="#其他vector操作" class="headerlink" title="其他vector操作"></a>其他vector操作</h3><p>v.empty()：若v中不含任何元素，返回真；否则返回假</p>
<p>v.size()：返回v中元素个数</p>
<p>下标：</p>
<ol>
<li>使用下标的时候必须验证其是否在合理范围内。</li>
<li>不能用下标形式添加元素</li>
</ol>
<hr>
<p><em>练习3.17</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;string&gt; svec;</span><br><span class="line">	string word;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; word) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!word.<span class="built_in">empty</span>())</span><br><span class="line">			svec.<span class="built_in">push_back</span>(word);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">decltype</span>(svec.<span class="built_in">size</span>()) i = <span class="number">0</span>; i != svec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">auto</span>&amp; temp = svec[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">decltype</span>(temp.<span class="built_in">size</span>())j = <span class="number">0</span>; j != temp.<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">			<span class="keyword">auto</span>&amp; temp2 = temp[j];</span><br><span class="line">			temp2 = <span class="built_in">toupper</span>(temp2);</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; svec[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	vector&lt;string&gt; My_vector;</span><br><span class="line">	string istring;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; istring)</span><br><span class="line">	&#123;</span><br><span class="line">		My_vector.<span class="built_in">push_back</span>(istring);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; My_vector.<span class="built_in">size</span>();i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; My_vector[i].<span class="built_in">length</span>();j++)	<span class="comment">//length()函数也能得到string的长度</span></span><br><span class="line">		&#123;</span><br><span class="line">			My_vector[i][j] = <span class="built_in">toupper</span>(My_vector[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; My_vector.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;My_vector[i]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>练习3.20</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一问</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; ivec;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; i) &#123;</span><br><span class="line">		ivec.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ivec.<span class="built_in">size</span>() - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">		cout &lt;&lt; ivec[j] + ivec[j + <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二问</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; ivec;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; i) &#123;</span><br><span class="line">		ivec.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ivec.<span class="built_in">size</span>() % <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (ivec.<span class="built_in">size</span>() - <span class="number">1</span>) / <span class="number">2</span>; ++j)</span><br><span class="line">			cout &lt;&lt; ivec[j] + ivec[ivec.<span class="built_in">size</span>() - <span class="number">1</span> - j] &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; ivec[(ivec.<span class="built_in">size</span>() - <span class="number">1</span>) / <span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ivec.<span class="built_in">size</span>() / <span class="number">2</span>; ++j)</span><br><span class="line">			cout &lt;&lt; ivec[j] + ivec[ivec.<span class="built_in">size</span>() - <span class="number">1</span> - j] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; arr;			<span class="comment">//创立一个对象为整数的vector</span></span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; num)			<span class="comment">//循环给vector赋值，当输入0时退出循环</span></span><br><span class="line">	&#123;</span><br><span class="line">		arr.<span class="built_in">push_back</span>(num);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> sum;<span class="comment">//用于统计两个相邻整数的和</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = arr.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; j; i++, j--)&#123;	<span class="comment">//循环计算首尾依次相加</span></span><br><span class="line">		sum = arr[i] + arr[j];								<span class="comment">//原来for还可以这么用</span></span><br><span class="line">		cout &lt;&lt; sum &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (arr.<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">1</span>)			<span class="comment">//如果数量为奇的话，则最后输出中间值</span></span><br><span class="line">		cout &lt;&lt; arr[(arr.<span class="built_in">size</span>() - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++笔记（七）——迭代器介绍</title>
    <url>/2022/05/01/cpp/cpp-note-7/</url>
    <content><![CDATA[<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>下标运算符可以用于访问string对象的字符或vector对象的元素，迭代器(iterator)可以达到同样的目的。<strong>所有标准器件库容器都可以使用迭代器</strong>（更通用），但只有少数几种才同时支持下标运算符。</p>
<p>迭代器类似于指针，提供了对对象的间接访问，也分为有效和无效（有效迭代器指向某个元素或者容器中尾元素的下一个位置；其他情况均无效）。</p>
<h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><p>与指针不同，获取迭代器不是使用取地址符（&amp;）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//v是一个非空的vector，拥有迭代器的类同时拥有返回迭代器的成员，如begin()和end()</span></span><br><span class="line"><span class="keyword">auto</span> b = v.<span class="built_in">begin</span>(), e = v.<span class="built_in">end</span>();	<span class="comment">//b表示v的第一个元素，e表示v尾元素的下一位置</span></span><br></pre></td></tr></table></figure>

<p>与指针类似，可以通过解引用符（*）来获取它所指的元素：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用迭代器将s的首字母替换为大写</span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;some string&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">begin</span>() != s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> it = s.<span class="built_in">begin</span>();</span><br><span class="line">    *it = <span class="built_in">toupper</span>(*it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器使用递增（++）运算符来移动到下一个元素：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用迭代器将s的所有字母替换为大写</span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;some string&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    *it = <span class="built_in">toupper</span>(*it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="关键概念：泛型编程-Generic-Programming"><a href="#关键概念：泛型编程-Generic-Programming" class="headerlink" title="关键概念：泛型编程(Generic Programming)"></a>关键概念：泛型编程(Generic Programming)</h4><p>如上段代码所示，for()中的条件部分使用了!&#x3D;而非&lt;，这是因为所有标准库容器的迭代器都定义了&#x3D;&#x3D;和!&#x3D;，而大多数没有定义&lt;运算符。因此，养成使用迭代器和!&#x3D;的习惯，就可以不用纠结容器类型。</p>
<p>泛型编程提出是为了发明一种语言机制，能够帮助实现一个通用的标准容器库。这样便于编写完全一般化且可重复使用的算法，实现算法和数据结构分离。</p>
</blockquote>
<p>迭代器类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it1;		<span class="comment">//it是能读写vector&lt;int&gt;对象中的字符的迭代器</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator cit;<span class="comment">//类似于指向常量的指针，即迭代器可以递增，但是不可通过它修改其所指对象</span></span><br><span class="line"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt;::iterator it2;<span class="comment">//类似于常量指针，迭代器不可递增，但可通过它</span></span><br></pre></td></tr></table></figure>

<p><u>begin和end返回的具体类型由对象是否是常量决定，若对象是常量，则返回<code>const_iterator</code>；反之，返回<code>iterator</code>。</u></p>
<p>使用<code>cbegin</code>和<code>cend</code>则可以返回<code>const_iterator</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt; cv;</span><br><span class="line"><span class="keyword">auto</span> it1 = v.<span class="built_in">begin</span>();			<span class="comment">//it1的类型是iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = cv.<span class="built_in">begin</span>();			<span class="comment">//it2的类型是const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it3 = v.<span class="built_in">cbegin</span>();			<span class="comment">//it3的类型是const_iterator</span></span><br></pre></td></tr></table></figure>

<p>通过解引用符获得迭代器所指对象后，若该对象恰好是类，就可以进一步利用点运算符访问其成员：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; sv;</span><br><span class="line"><span class="keyword">auto</span> it = sv.<span class="built_in">begin</span>();</span><br><span class="line">cout&lt;&lt;(*it).<span class="built_in">empty</span>();			<span class="comment">//第一个括号必不可少，必须先进行解引用操作</span></span><br></pre></td></tr></table></figure>

<p>使用C++的箭头表达式（-&gt;）可以达到同样的效果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">it-&gt;<span class="built_in">empty</span>();					<span class="comment">//等价于(*it).empty();</span></span><br></pre></td></tr></table></figure>

<p><strong><u>注意：任何一个可能改变vector对象容量的操作都会使该vector对象的迭代器失效，故千万不要在使用了迭代器的循环体中向迭代器所属的容器添加元素。</u></strong></p>
<hr>
<p><em>练习3.22</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;string&gt; vs;</span><br><span class="line">	<span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; s) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">			vs.<span class="built_in">push_back</span>(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = vs.<span class="built_in">begin</span>(); it != vs.<span class="built_in">end</span>() &amp;&amp; !it-&gt;<span class="built_in">empty</span>(); ++it) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> c = it-&gt;<span class="built_in">begin</span>(); c != it-&gt;<span class="built_in">end</span>(); ++c) &#123;</span><br><span class="line">			<span class="keyword">if</span> (*c != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">				*c = <span class="built_in">toupper</span>(*c);</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="迭代器运算"><a href="#迭代器运算" class="headerlink" title="迭代器运算"></a>迭代器运算</h3><p>迭代器加、减任何一个整数仍得到一个迭代器，迭代器指示的新位置与原来相比向前、向后移动了若干个元素（不能溢出）；</p>
<p>两个迭代器相减得到它们之间的距离，其结果的类型是difference_type，参与运算的两个迭代器必须指向同一个容器中的元素（没有相加操作）；</p>
<p>迭代器的关系运算（&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D;），如果某迭代器指向的容器位置在另一个迭代器所指位置之前，则前者小于后者；</p>
<blockquote>
<h4 id="经典算法：二分搜索"><a href="#经典算法：二分搜索" class="headerlink" title="经典算法：二分搜索"></a>经典算法：二分搜索</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//text必须是有序的</span></span><br><span class="line"><span class="comment">//beg和end表示我们搜索的范围</span></span><br><span class="line"><span class="keyword">auto</span> beg = text.<span class="built_in">begin</span>(), end = text.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">auto</span> mid = text.<span class="built_in">begin</span>() + (end - beg) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">//当还有元素尚未检查并且我们还没有找到sought时执行循环</span></span><br><span class="line"><span class="keyword">while</span> (mid != end &amp;&amp; *mid != sought) &#123;</span><br><span class="line">	<span class="keyword">if</span> (sought &lt; *mid)		<span class="comment">//判断sought是否在前半部分</span></span><br><span class="line">		end = mid;			<span class="comment">//如果是，调整搜索范围忽略后半部分</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		beg = mid + <span class="number">1</span>;		<span class="comment">//如果不是，忽略前半部分</span></span><br><span class="line">	mid = beg + (end - beg) / <span class="number">2</span>;	<span class="comment">//新的中间点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<p><em>练习3.24</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; i) &#123;</span><br><span class="line">		vi.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> c = vi.<span class="built_in">begin</span>(); c != vi.<span class="built_in">begin</span>() + vi.<span class="built_in">size</span>() / <span class="number">2</span>; c++) &#123;</span><br><span class="line">		cout &lt;&lt; *c + *(vi.<span class="built_in">begin</span>() + (vi.<span class="built_in">end</span>() - c) - <span class="number">1</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (vi.<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">		cout &lt;&lt; *(vi.<span class="built_in">begin</span>() + vi.<span class="built_in">size</span>()/<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>练习3.25</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">scores</span><span class="params">(<span class="number">11</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="type">int</span> grade;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; grade) &#123;</span><br><span class="line">		<span class="keyword">if</span> (grade &lt;= <span class="number">100</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			++ *(scores.<span class="built_in">begin</span>() + grade/<span class="number">10</span>);	<span class="comment">//注意不要忘了括号前的 *</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> c = scores.<span class="built_in">begin</span>(); c != scores.<span class="built_in">end</span>(); ++c) &#123;</span><br><span class="line">		cout &lt;&lt; *c &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++笔记（八）——数组</title>
    <url>/2022/05/05/cpp/cpp-note-8/</url>
    <content><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一种类似于vector的数据结构，但其大小是固定的，不能随意增加。</p>
<h3 id="定义和初始化内置数组"><a href="#定义和初始化内置数组" class="headerlink" title="定义和初始化内置数组"></a>定义和初始化内置数组</h3><p>对于数组a[d]，a是数组名，d是数组维度，**数组的最后一个元素是a[d-1]**。编译的时候维度应该是已知的，故d必须是一个常量表达式。</p>
<p>列表初始化时，如果数组维度大于所给的初始值数量，剩下的元素被初始化为默认值；列表初始化时，允许忽略数组维度，编译器会根据初始值推测维度：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">unsigned</span> sz = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> al[sz] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> a2[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;				<span class="comment">//维度是3</span></span><br><span class="line"><span class="type">int</span> a3[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;				<span class="comment">//维度是5，等价于int a3[] = &#123;0, 1, 2, 0, 0&#125;;</span></span><br><span class="line">string a4[<span class="number">3</span>] = &#123;<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;bye&quot;</span>, <span class="string">&quot;&quot;</span>&#125;;	<span class="comment">//等价于 string a4[] = &#123;&quot;hi&quot;, &quot;bye&quot;, &quot;&quot;&#125;;</span></span><br><span class="line"><span class="type">int</span> a5[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;				<span class="comment">//错误：初始值过多</span></span><br></pre></td></tr></table></figure>

<p>对于字符数组，可以用字符串字面值对其进行初始化，但需要注意字符串结尾有一个空字符：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a1[] = &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;+&#x27;</span>&#125;;		<span class="comment">//维度为3，不含空字符</span></span><br><span class="line"><span class="type">char</span> a1[] = &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;	<span class="comment">//维度为4，含有显式空字符</span></span><br><span class="line"><span class="type">char</span> a1[] = <span class="string">&quot;C++&quot;</span>;					<span class="comment">//维度为4，含有隐式空字符</span></span><br></pre></td></tr></table></figure>

<p>不允许拷贝和赋值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> a2[] = a;						<span class="comment">//错误：不能用一个数组初始化另一个数组</span></span><br><span class="line"><span class="type">int</span> a3[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">a3 = a;								<span class="comment">//错误：不能把一个数组直接赋值给另一个数组</span></span><br></pre></td></tr></table></figure>

<p>指针和引用（先由内向外，再从右到左）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *ptrs[<span class="number">10</span>];						<span class="comment">//ptrs是含有10个整型指针的数组</span></span><br><span class="line"><span class="type">int</span> &amp;refs[<span class="number">10</span>];						<span class="comment">//错误：引用不是对象，不存在引用的数组</span></span><br><span class="line"><span class="built_in">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr;			<span class="comment">//Parray指向一个含有10个整数的数组</span></span><br><span class="line"><span class="built_in">int</span> (&amp;arrRef)[<span class="number">10</span>] = arr;			<span class="comment">//arrRef引用一个含有10个整数的数组</span></span><br></pre></td></tr></table></figure>

<h3 id="数组和指针"><a href="#数组和指针" class="headerlink" title="数组和指针"></a>数组和指针</h3><p>在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s[] = &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;;</span><br><span class="line">string *p = s;						<span class="comment">//等价于string *p = &amp;s[0];</span></span><br><span class="line"><span class="keyword">auto</span> s1 = s;						<span class="comment">//s1是一个指针，指向s的第一个元素，等价于 auto c = &amp;s[0];</span></span><br></pre></td></tr></table></figure>

<p>但decltype关键字有所不同：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//s2是一个含有3个string的数组</span></span><br><span class="line"><span class="keyword">decltype</span>(s) s2 = &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>指向数组的指针支持迭代器所支持的所有运算：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = arr;						<span class="comment">//p指向arr的第一个元素，即arr[0]</span></span><br><span class="line">++p;								<span class="comment">//p指向arr[1]</span></span><br></pre></td></tr></table></figure>

<p>C++中可以设法获取数组尾元素后的那个并不存在的元素的地址：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *e = &amp;arr[<span class="number">10</span>];					<span class="comment">//e指向arr尾元素的下一个位置</span></span><br></pre></td></tr></table></figure>

<p>这时，我们可以对数组进行遍历操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> *b = arr; b != e; ++b)</span><br><span class="line">    cout &lt;&lt; *b &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>C++11新标准中引入了begin和end函数来获取指向数组第一个元素的指针和指向数组尾元素下一位置的指针（<strong>注意，这两个函数的返回值都是指针</strong>）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a1[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> *beg = <span class="built_in">begin</span>(a1);</span><br><span class="line"><span class="type">int</span> *last = <span class="built_in">end</span>(a2);				<span class="comment">//指向a1尾元素的下一位置</span></span><br></pre></td></tr></table></figure>

<p><strong><u>特别注意，尾后指针与尾后迭代器类似，不能执行解引用和递增操作。</u></strong></p>
<p>与迭代器相同，两个指针相减得到它们之间的距离，其结果类型为ptrdiff_t，可以为负值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> n = <span class="built_in">end</span>(a1) - <span class="built_in">begin</span>(a1);		<span class="comment">//n的值是10，也就是a1中元素的数量</span></span><br></pre></td></tr></table></figure>

<p>只要指针指向的是数组中的元素，我们就可以对其进行下标运算：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = &amp;a1[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> j = p[<span class="number">1</span>];						<span class="comment">//结果为j = a1[3]，等价于 int j = *(p + 1);</span></span><br></pre></td></tr></table></figure>

<p>注意，标准库类型的下标运算必须是无符号类型，但内置的下标运算可以处理负值，比如此处可以令<code>j = p[-1];</code>，结果即是j &#x3D; a1[1] 。</p>
<hr>
<p><em>练习3.39</em></p>
<details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//比较两个string</span></span><br><span class="line">	string s1, s2;</span><br><span class="line">	cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">	<span class="keyword">if</span> (s1 == s2)</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;equal&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (s1 &gt; s2)</span><br><span class="line">		cout &lt;&lt; s1 &lt;&lt; <span class="string">&quot; &gt; &quot;</span> &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; s1 &lt;&lt; <span class="string">&quot; &lt; &quot;</span> &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//比较两个C风格字符串，利用for循环遍历</span></span><br><span class="line">	<span class="type">char</span> ca1[] = &#123; <span class="string">&quot;A string example&quot;</span> &#125;;</span><br><span class="line">	<span class="type">char</span> ca2[] = &#123; <span class="string">&quot;A string example&quot;</span> &#125;;</span><br><span class="line">	<span class="type">unsigned</span> len1 = <span class="built_in">sizeof</span>(ca1);</span><br><span class="line">	<span class="type">unsigned</span> len2 = <span class="built_in">sizeof</span>(ca2);</span><br><span class="line">	<span class="keyword">if</span> (len1 == len2) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != len1; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ca1[i] &gt; ca1[i]) &#123;</span><br><span class="line">				cout &lt;&lt; ca1 &lt;&lt; <span class="string">&quot; &gt; &quot;</span> &lt;&lt; ca2 &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (ca1[i] &lt; ca1[i]) &#123;</span><br><span class="line">				cout &lt;&lt; ca1 &lt;&lt; <span class="string">&quot; &lt; &quot;</span> &lt;&lt; ca2 &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ca1 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; ca2 &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (len1 &gt; len2)</span><br><span class="line">		cout &lt;&lt; ca1 &lt;&lt; <span class="string">&quot; &gt; &quot;</span> &lt;&lt; ca2 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; ca1 &lt;&lt; <span class="string">&quot; &lt; &quot;</span> &lt;&lt; ca2 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//比较两个C风格字符串，调用strcmp()函数</span></span><br><span class="line">	<span class="type">char</span> ca3[] = &#123; <span class="string">&quot;A string example&quot;</span> &#125;;</span><br><span class="line">	<span class="type">char</span> ca4[] = &#123; <span class="string">&quot;A string example&quot;</span> &#125;;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(ca3, ca4) == <span class="number">0</span>)</span><br><span class="line">		cout &lt;&lt; ca3 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; ca4 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(ca3, ca4) &gt; <span class="number">0</span>)</span><br><span class="line">		cout &lt;&lt; ca3 &lt;&lt; <span class="string">&quot; &gt; &quot;</span> &lt;&lt; ca4 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		cout &lt;&lt; ca3 &lt;&lt; <span class="string">&quot; &lt; &quot;</span> &lt;&lt; ca4 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p><em>练习3.40</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> a[<span class="number">100</span>] = &#123; <span class="string">&quot;How are &quot;</span> &#125;, b[<span class="number">100</span>] = &#123; <span class="string">&quot;you ?&quot;</span> &#125;;</span><br><span class="line">	<span class="type">char</span> c[<span class="number">100</span>] = &#123;&#125;;</span><br><span class="line">	<span class="built_in">strcpy_s</span>(c, a);		<span class="comment">//等价于strcpy函数</span></span><br><span class="line">	<span class="built_in">strcat_s</span>(c, b);		<span class="comment">//等价于strcat函数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : c)</span><br><span class="line">		cout &lt;&lt; i;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于strcpy和strcat函数没有内部检查，微软担心可能造成栈溢出，在新版本的VS中改写了这些函数，并在名字后面加上_s来作为区分。</p>
<hr>
<h3 id="与旧代码的接口"><a href="#与旧代码的接口" class="headerlink" title="与旧代码的接口"></a>与旧代码的接口</h3><p>允许用C风格字符串（即已空字符结束的字符数组）来为string对象赋值，反之不可；</p>
<p>允许在string对象的加法运算中使用C风格字符串作为其中一个运算对象（不能两个都是）；</p>
<p>可以通过c_str()函数来为C风格字符串赋值（其返回值是一个指向const C风格字符串的指针），如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello world&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">char</span> *str = s;					<span class="comment">//错误：不能用string对象初始化char*</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *str = s.<span class="built_in">c_str</span>();	<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<p>注意，如果后续操作改变了s的值，s.c_str()可能会发生变化<strong>（指针存放的地址发生改变）</strong>，而str不会跟着变化<strong>（指针存放的地址未改变，但原本的对象不再存放在该地址，str成了野指针）</strong>，这样之前返回的数组就失去了效用。</p>
<p>允许使用数组来初始化vector，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> int_arr[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec1</span><span class="params">(begin(int_arr), end(int_arr))</span></span>;	<span class="comment">//指明拷贝区域的地址范围</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec2</span><span class="params">(int_arr + <span class="number">1</span>, int_arr + <span class="number">4</span>)</span></span>;		<span class="comment">//ivec2只包含int_arr中下标为1，2，3的三个元素</span></span><br></pre></td></tr></table></figure>

<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>严格来说，C++语言中没有多维数组，通常所说的多位数组其实是数组的数组。</p>
<hr>
<p><em>练习3.43</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</span><br><span class="line">		&#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="comment">//利用范围for循环(不使用auto)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> (&amp;d1)[<span class="number">4</span>] : ia) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span>&amp; d2 : d1)</span><br><span class="line">			cout &lt;&lt; d2 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//使用auto</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; d1 : ia) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; d2 : d1)</span><br><span class="line">			cout &lt;&lt; d2 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//利用下标运算符</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != <span class="number">3</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j != <span class="number">4</span>; ++j) &#123;</span><br><span class="line">			cout &lt;&lt; ia[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//利用指针（不使用auto）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span>(*p1)[<span class="number">4</span>] = ia; p1 != ia + <span class="number">3</span>; ++p1) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span>* p2 = *p1; p2 != *p1 + <span class="number">4</span>; ++(p2)) &#123;</span><br><span class="line">			cout &lt;&lt; *p2 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//使用auto</span></span><br><span class="line">    <span class="comment">//这里的p1是int (*p1)[4]类型，其所指对象为一个含有4个元素的整型数组（该数组是数组的数组的首元素）</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> p1 = ia; p1 != ia + <span class="number">3</span>; ++p1) &#123;	</span><br><span class="line">        <span class="comment">//这里的p2是 int *p2类型，其所指对象为一个整数（该整数是整型数组的首元素）</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> p2 = *p1; p2 != *p1 + <span class="number">4</span>; ++(p2)) &#123;</span><br><span class="line">			cout &lt;&lt; *p2 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>练习3.44</em></p>
<p>利用类型别名</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</span><br><span class="line">    &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> int_arr1 = <span class="type">int</span>[<span class="number">4</span>];	<span class="comment">//C++11新标准</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int_arr2[<span class="number">4</span>];	<span class="comment">//注意与上一条语句的区别，其中int_arr1和int_arr2类型相同</span></span><br><span class="line"><span class="keyword">for</span> (int_arr2 &amp;d1 : ia) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; d2 : d1)</span><br><span class="line">        cout &lt;&lt; d2 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != <span class="number">3</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j != <span class="number">4</span>; ++j) &#123;</span><br><span class="line">        cout &lt;&lt; ia[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (int_arr1 * p1 = ia; p1 != ia + <span class="number">3</span>; ++p1) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>* p2 = *p1; p2 != *p1 + <span class="number">4</span>; ++(p2)) &#123;</span><br><span class="line">        cout &lt;&lt; *p2 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++笔记（九）——表达式</title>
    <url>/2022/05/06/cpp/cpp-note-9/</url>
    <content><![CDATA[<h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><p>C++提供了一套丰富的运算符，并定义了这些运算符作用域内置类型的运算对象时所执行的操作。同时，当运算对象是类类型时，C++也允许用户自定义上述运算符的含义。</p>
<h2 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h2><p>当一个对象被用作右值的时候，用的是对象的<strong>值（内容）</strong>；当对象被用作左值的时候，用的是对象的<strong>身份（在内存中的位置）</strong>。</p>
<p>对于关键字<code>decltype()</code>，如果()中是表达式（不是变量），且表达式的结果是一个左值，比如<code>*p</code>（*是解引用运算符，p是一个指针，它们组合起来构成一个表达式，表达式的结果是p所指对象i），decltype将得到一个引用类型。</p>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><h3 id="关于布尔值"><a href="#关于布尔值" class="headerlink" title="关于布尔值"></a>关于布尔值</h3><p>布尔值不应该参与运算的原因：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="type">bool</span> b2 = -b;	<span class="comment">//b2是true！</span></span><br></pre></td></tr></table></figure>

<p>当 - 运算符作用于布尔类型的对象时，<strong>先把它提升为int类型</strong>（大多数运算符都是这样）。b的值为真，参与运算时将被提升为整数1，求负后结果为-1。而-1不等于0，转换回布尔值后应该为1。</p>
<h3 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h3><p>在C++11新标准中，整型除法的商一律向0取整（即直接切除小数部分）；取余运算符的运算对象必须是整型，m%n的结果符号只取决于被除数m，与n无关。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">21</span> % <span class="number">-5</span>;	<span class="comment">/*结果是1*/</span>		<span class="number">21</span> / <span class="number">-5</span>;	<span class="comment">/*结果是-4*/</span></span><br><span class="line"><span class="number">-21</span> % <span class="number">-5</span>;	<span class="comment">/*结果是-1*/</span>		<span class="number">-21</span> / <span class="number">-5</span>;	<span class="comment">/*结果是4*/</span></span><br><span class="line"><span class="number">-21</span> % <span class="number">5</span>;	<span class="comment">/*结果是-1*/</span>		<span class="number">-21</span> / <span class="number">5</span>;	<span class="comment">/*结果是-4*/</span></span><br></pre></td></tr></table></figure>

<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算符满足<strong>右结合律</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ival, jval;</span><br><span class="line">ival = jval = <span class="number">0</span>;	<span class="comment">//正确：ival和jval都被赋值为0</span></span><br><span class="line"><span class="type">int</span>* pval;</span><br><span class="line">ival = pval = <span class="number">0</span>;	<span class="comment">//错误：虽然可以把0赋值给pval，但是int*类型无法转换为int，即pval无法赋值给ival</span></span><br></pre></td></tr></table></figure>

<h2 id="递增递减运算符"><a href="#递增递减运算符" class="headerlink" title="递增递减运算符"></a>递增递减运算符</h2><p>只能用于左值运算对象，有前置和后置两种版本，前值版本将对象本身作为左值返回，后置版本将对象原始值的副本作为右值返回。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">j = ++i;			<span class="comment">//此时j = 1, i = 1：前置版本得到递增之后的值</span></span><br><span class="line">j = i++;			<span class="comment">//此时j = 1, j = 2：后置版本得到递增之前的值</span></span><br></pre></td></tr></table></figure>

<p><u><strong>建议：除非必须，否则不用递增递减运算符的后置版本</strong></u>，前置版本不需要存储原始值，节省了资源。</p>
<p>在这种情况下，常用后置版本以保证简洁：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; *iter++ &lt;&lt;endl;		<span class="comment">//等价于*(iter++)，由于后置版本返回值为原始值，故这条语句将指针向前移动一个位置，并输出iter之前指向的那个元素</span></span><br></pre></td></tr></table></figure>

<p>运算对象可按任意顺序求值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(beg != s.<span class="built_in">end</span>() &amp;&amp; !<span class="built_in">isspace</span>(*beg))</span><br><span class="line">    *beg = <span class="built_in">toupper</span>(*beg++);		<span class="comment">//错误：该赋值语句未定义</span></span><br></pre></td></tr></table></figure>

<p>在赋值运算符左右的运算对象都用到了beg，并且右侧还改变了beg的值，无法确定左侧的beg是递增前的beg还是beg + 1（都有可能发生，由编译器决定）</p>
<p><u><strong>注意：C++中只有4中运算符明确规定了运算对象的求值顺序，分别是逻辑与（&amp;&amp;）、逻辑或（||）、条件（? :）、逗号（,）</strong></u></p>
<h2 id="成员访问函数"><a href="#成员访问函数" class="headerlink" title="成员访问函数"></a>成员访问函数</h2><p>点运算符（.）和箭头运算符（-&gt;）都可用于访问成员：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;a string&quot;</span>, *p = &amp;s1;</span><br><span class="line"><span class="keyword">auto</span> n = s1.<span class="built_in">size</span>();</span><br><span class="line">n = (*p).<span class="built_in">size</span>();</span><br><span class="line">n = p -&gt; <span class="built_in">size</span>();			<span class="comment">//等价于 n = (*p).size();</span></span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>可以大致分为隐式转换和显式转换</p>
<h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>以算术转换为主，还包括数组转换成指针、指针转换成布尔类型、指针转换成常量、类类型定义的转换（如cin转换成布尔值）等</p>
<h3 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h3><p>一个命名的强制类型转换具有如下形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cast-<span class="built_in">name</span>&lt;type&gt;(expression);</span><br></pre></td></tr></table></figure>

<p>其中cast-name是static_cast、dynamic_cast、const_cast、reinterpret_cast中的一种，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">5</span>, j = <span class="number">2</span>;</span><br><span class="line"><span class="type">double</span> slope = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(j) / i;</span><br></pre></td></tr></table></figure>

<h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h4><p>可以用于找回存在于void*指针中的值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">void</span>* p_void = &amp;i;</span><br><span class="line">cout &lt;&lt; *(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(p_void)) &lt;&lt; endl;		<span class="comment">//输出结果为42</span></span><br></pre></td></tr></table></figure>

<h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h4><p>const_cast只能改变运算对象的const属性（去掉const），不能改变表达式类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> k = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* pk = &amp;k;</span><br><span class="line"><span class="type">int</span>* pk2 = pk;							<span class="comment">//错误：const int*类型不能用于初始化int*类型</span></span><br><span class="line"><span class="type">int</span>* pk3 = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(pk);		<span class="comment">//正确</span></span><br><span class="line"><span class="type">double</span>* pk4 = <span class="built_in">const_cast</span>&lt;<span class="type">double</span>*&gt;(pk);	<span class="comment">//错误：const_cast不能改变表达式类型</span></span><br></pre></td></tr></table></figure>

<p><strong><u>注意：如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为；但如果对象是一个常量，再使用const_cast执行写操作会产生未定义（由编译器决定，不同编译器结果不一样）的后果。</u></strong></p>
<h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h4><p>reinterpret_cast通常为运算对象的位模式提供了较低层次上的重新解释，使用它非常危险（尽量不要用）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *ip;</span><br><span class="line"><span class="type">char</span> *pc = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(ip);	<span class="comment">//pc所指的真实对象是一个int而非字符，编译器通过重新解释ip而把ip赋值给了pc</span></span><br></pre></td></tr></table></figure>

<hr>
<p><em>练习4.37</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i; <span class="type">double</span> d; <span class="type">const</span> string* ps; <span class="type">char</span>* pc; <span class="type">void</span>* pv;</span><br><span class="line">pv = <span class="built_in">const_cast</span>&lt;string*&gt;(ps);</span><br><span class="line">i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(*pc);</span><br><span class="line">pv = <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;d);</span><br><span class="line">pc = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(pv);</span><br></pre></td></tr></table></figure>









]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++问题笔记</title>
    <url>/2022/04/24/cpp/cpp-note/</url>
    <content><![CDATA[<h3 id="启用括号包围"><a href="#启用括号包围" class="headerlink" title="启用括号包围"></a>启用括号包围</h3><p>在visual studio中，工具—&gt;选项—&gt;高级，可以启用括号包围，</p>
<img src="/2022/04/24/cpp/cpp-note/1651199369386.png" class="" width="1651199369386">

<h3 id="不要在头文件中类外定义任何非内联函数"><a href="#不要在头文件中类外定义任何非内联函数" class="headerlink" title="不要在头文件中类外定义任何非内联函数"></a>不要在头文件中类外定义任何非内联函数</h3><p>这种操作会造成重复定义，A类的源文件(A.cpp)中会包含一次头文件(A.h)，需要用到A类的文件又会包含一次头文件(A.h)，这导致在A类的源文件和需要用到A类的文件中出现了对同一函数的两次相同定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">A</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::<span class="built_in">A</span>()&#123; <span class="comment">/* constructor body */</span> &#125;			<span class="comment">//错误：在类的头文件中定义非内联构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">A::A</span><span class="params">()</span></span>&#123; <span class="comment">/* constructor body */</span> &#125;		<span class="comment">//正确：定义了一个内联构造函数，类内的A()声明默认为内联</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****另一种情况*****/</span></span><br><span class="line"><span class="comment">//A.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">inline</span> <span class="title">A</span><span class="params">()</span></span>&#123; <span class="comment">/* constructor body */</span> &#125;<span class="comment">//正确：定义了一个内联构造函数</span></span><br><span class="line">    	<span class="built_in">A</span>()&#123; <span class="comment">/* constructor body */</span> &#125;		<span class="comment">//正确：类内定义的函数默认为内联，与上一条等价</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****另一种情况*****/</span></span><br><span class="line"><span class="comment">//A.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">inline</span> <span class="title">A</span><span class="params">()</span></span>;							<span class="comment">//正确：声明了一个内联构造函数</span></span><br><span class="line">    	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">A::A</span><span class="params">()</span></span>&#123; <span class="comment">/* constructor body */</span> &#125;		<span class="comment">//正确</span></span><br><span class="line">A::<span class="built_in">A</span>()&#123; <span class="comment">/* constructor body */</span> &#125;			<span class="comment">//正确：类内已经声明了此函数为内联函数</span></span><br></pre></td></tr></table></figure>

<h3 id="使用预处理注释"><a href="#使用预处理注释" class="headerlink" title="使用预处理注释"></a>使用预处理注释</h3><p>对于比较大型的项目，预处理注释因其可注释多行、可嵌套，将更有利于代码的调试：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 0		<span class="comment">//if后为0时，语句1被注释掉，执行语句2；if后为1时，执行语句1，语句2被注释掉</span></span></span><br><span class="line">语句<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">语句<span class="number">2</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0		<span class="comment">//可嵌套，#if与#endif有就近匹配原则</span></span></span><br><span class="line">语句<span class="number">3</span>;</span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">	语句<span class="number">4</span>;</span><br><span class="line">	<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	语句<span class="number">5</span>;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>如果使用<code>/* */</code>进行嵌套，可能会引发错误：</p>
<img src="/2022/04/24/cpp/cpp-note/1652527799598.png" class="" width="1652527799598">



<h3 id="C语言结构体中不可含有成员函数，但可含有指向函数的指针"><a href="#C语言结构体中不可含有成员函数，但可含有指向函数的指针" class="headerlink" title="C语言结构体中不可含有成员函数，但可含有指向函数的指针"></a>C语言结构体中不可含有成员函数，但可含有指向函数的指针</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> (*display)(<span class="type">int</span> i);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">	<span class="type">int</span> (*sum)(<span class="type">int</span> i, <span class="type">int</span> j);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="type">int</span> (*sum)(MyStruct a);			<span class="comment">//错误：此时MyStruct属于未定义的状态</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;MyStruct;							<span class="comment">//利用typedef将一个未命名的结构体绑定在MyStruct上</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i + j);</span><br><span class="line">	<span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(MyStruct a)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a.i + a.j);</span><br><span class="line">	<span class="keyword">return</span> a.i + a.j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	MyStruct ob1 = &#123;<span class="number">1</span> ,<span class="number">2</span> , display, sum&#125;;	<span class="comment">//一定要在初始化时绑定函数</span></span><br><span class="line">	ob1.display(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ob1.sum(ob1.i, ob1.j));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode（一）</title>
    <url>/2022/05/17/leetcode/leetcode-1-V2/</url>
    <content><![CDATA[<h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h3><div class="tabs" id="tab-v2"><ul class="nav-tabs"><li class="tab"><a href="#tab-v2-1">初见</a></li><li class="tab"><a href="#tab-v2-2">优化</a></li><li class="tab"><a href="#tab-v2-3">折叠表格</a></li></ul><div class="tab-content"><div class="tab-pane" id="tab-v2-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* sum;	<span class="comment">//sum是指向头结点的指针，sum-&gt;next是头指针，故函数的返回值应为sum-&gt;next</span></span><br><span class="line">        ListNode* p, * s;</span><br><span class="line">        p = <span class="keyword">new</span> ListNode;</span><br><span class="line">        sum = p;</span><br><span class="line">        <span class="type">int</span> Ci = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//循环至l1或l2其中一个为空（即到达尾段）</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            s = <span class="keyword">new</span> ListNode;		<span class="comment">//先为s分配一块新的内存区域</span></span><br><span class="line">            s-&gt;val = (l1-&gt;val + l2-&gt;val + Ci) % <span class="number">10</span>;  <span class="comment">//计算两者之和（加上进位）</span></span><br><span class="line">            Ci = (l1-&gt;val + l2-&gt;val + Ci) / <span class="number">10</span>;      <span class="comment">//计算进位</span></span><br><span class="line">            p-&gt;next = s;			<span class="comment">//将新的s连接至sum的尾端</span></span><br><span class="line"></span><br><span class="line">            p = s;					<span class="comment">//p存储此时的s</span></span><br><span class="line">            l1 = l1-&gt;next;			<span class="comment">//将l1，l2移动到下一个位置</span></span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//l2和l1一样长时</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span> &amp;&amp; l2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Ci)&#123;		<span class="comment">//产生进位时，sum需要再延长一个结点</span></span><br><span class="line">                s = <span class="keyword">new</span> ListNode;</span><br><span class="line">                s-&gt;val = Ci;</span><br><span class="line">                p-&gt;next = s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//l1比l2更长时</span></span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="literal">nullptr</span> &amp;&amp; l2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                s = <span class="keyword">new</span> ListNode;</span><br><span class="line">                s-&gt;val = (l1-&gt;val + Ci) % <span class="number">10</span>;  <span class="comment">//录入数据</span></span><br><span class="line">                Ci = (l1-&gt;val + Ci) / <span class="number">10</span>;      <span class="comment">//进位</span></span><br><span class="line">                p-&gt;next = s;</span><br><span class="line"></span><br><span class="line">                p = s;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Ci)&#123;				<span class="comment">//产生进位时，sum需要再延长一个结点</span></span><br><span class="line">                s = <span class="keyword">new</span> ListNode;</span><br><span class="line">                s-&gt;val = Ci;</span><br><span class="line">                p-&gt;next = s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//l2比l1更长时</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                s = <span class="keyword">new</span> ListNode;</span><br><span class="line">                s-&gt;val = (l2-&gt;val + Ci) % <span class="number">10</span>;</span><br><span class="line">                Ci = (l2-&gt;val + Ci) / <span class="number">10</span>;		<span class="comment">//计算进位</span></span><br><span class="line">                p-&gt;next = s;</span><br><span class="line"></span><br><span class="line">                p = s;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Ci)&#123;				<span class="comment">//产生进位时，sum需要再延长一个结点</span></span><br><span class="line">                s = <span class="keyword">new</span> ListNode;</span><br><span class="line">                s-&gt;val = Ci;</span><br><span class="line">                p-&gt;next = s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-v2-2"><p>参考了孙哥的题解后，优化代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> ListNode;</span><br><span class="line">        ListNode* pre = dummyHead;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span> || l2 != <span class="literal">nullptr</span> || t != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                t += l1-&gt;val;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                t += l2-&gt;val;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t%<span class="number">10</span>);</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-v2-3"></div></div></div>

<h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h3><div class="tabs" id="tab-v3"><ul class="nav-tabs"><li class="tab"><a href="#tab-v3-1">初见</a></li><li class="tab"><a href="#tab-v3-2">优化</a></li><li class="tab"><a href="#tab-v3-3">参考</a></li><li class="tab"><a href="#tab-v3-4">折叠表格</a></li></ul><div class="tab-content"><div class="tab-pane" id="tab-v3-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string result, temp;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = s.<span class="built_in">begin</span>(); i != s.<span class="built_in">end</span>(); ++i) &#123;       <span class="comment">//母字符串移位</span></span><br><span class="line">        	<span class="comment">//先寻找是否出现与子字符串重复的字符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i_temp = temp.<span class="built_in">begin</span>(); i_temp != temp.<span class="built_in">end</span>(); ++i_temp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (*i == *i_temp) &#123;	<span class="comment">//用于判断是否出现，并记录下位置</span></span><br><span class="line">                    flag = i_temp - temp.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;     		<span class="comment">//没有出现，把这一位放到temp的尾部</span></span><br><span class="line">                temp += *i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;                  	<span class="comment">//出现重复字符时</span></span><br><span class="line">                temp.<span class="built_in">erase</span>(<span class="number">0</span>, flag);    <span class="comment">//擦除重复部分</span></span><br><span class="line">                flag = <span class="number">0</span>;           	<span class="comment">//重置flag</span></span><br><span class="line">                temp += *i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.<span class="built_in">size</span>() &gt; result.<span class="built_in">size</span>()) </span><br><span class="line">                result = temp;  		<span class="comment">//当temp比result长的时候，把temp拷贝给result</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-v3-2"><p>可以少用一个字符串，因为题目只需要返回最长字符串的长度值，而不是最长字符串，故直接用一个int来记录就好：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxStr = <span class="number">0</span>;</span><br><span class="line">        string temp;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = s.<span class="built_in">begin</span>(); i != s.<span class="built_in">end</span>(); ++i) &#123;       <span class="comment">//母字符串移位</span></span><br><span class="line">        	<span class="comment">//先寻找是否出现与子字符串重复的字符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i_temp = temp.<span class="built_in">begin</span>(); i_temp != temp.<span class="built_in">end</span>(); ++i_temp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (*i == *i_temp) &#123;	<span class="comment">//用于判断是否出现重复字符，并用flag记录下位置</span></span><br><span class="line">                    flag = i_temp - temp.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (flag != <span class="number">0</span>) &#123;            <span class="comment">//出现重复字符时</span></span><br><span class="line">                temp.<span class="built_in">erase</span>(<span class="number">0</span>, flag);    <span class="comment">//擦除重复部分</span></span><br><span class="line">                flag = <span class="number">0</span>;           	<span class="comment">//重置flag</span></span><br><span class="line">            &#125;</span><br><span class="line">            temp += *i;</span><br><span class="line">            maxStr = (temp.<span class="built_in">size</span>() &gt; maxStr) ? temp.<span class="built_in">size</span>() : maxStr; 	<span class="comment">//当temp比result长的时候，把temp拷贝给result</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-v3-3"><p>抄的评论区中张旭的代码，map作为字符表，记录子字符串中出现过的字符（对于字符c，如果<code>map[static_cast&lt;int&gt;(c)] == 1</code>则说明子字符串中已经含有了c），start和end记录了子字符串（从s[start]到s[end]即是此时的子字符串），end - start即是子字符串的长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxStr = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> map[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">begin</span>() + end != s.<span class="built_in">end</span>())&#123;	<span class="comment">//确保不会溢出</span></span><br><span class="line">            <span class="keyword">while</span>(map[<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(s[end])] == <span class="number">1</span>)&#123;		<span class="comment">//强制类型转换将字符转为ASCII码</span></span><br><span class="line">                map[<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(s[start])] = <span class="number">0</span>;</span><br><span class="line">                ++start;	<span class="comment">//移动子字符串直到子字符串中不含有与待输入的字符相同的字符为止</span></span><br><span class="line">            &#125;</span><br><span class="line">            map[<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(s[end])] = <span class="number">1</span>;	<span class="comment">//将待输入的字符输入到子字符串中</span></span><br><span class="line">            ++end;			<span class="comment">//移动到下一个待输入字符</span></span><br><span class="line">            <span class="comment">//end = start时，子字符串实际上包含一个字符（即s[start]），故此时的end - start就是子字符串的长度</span></span><br><span class="line">            maxStr = maxStr &gt; (end - start) ? maxStr : (end - start);	</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-v3-4"></div></div></div>

<h3 id="4-寻找两个正序数组的中位数（待复习）"><a href="#4-寻找两个正序数组的中位数（待复习）" class="headerlink" title="4. 寻找两个正序数组的中位数（待复习）"></a>4. 寻找两个正序数组的中位数（待复习）</h3><p>没做出，放个题解方便复习：</p>
<details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1.<span class="built_in">size</span>() &gt; nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findMedianSortedArrays</span>(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = m;</span><br><span class="line">        <span class="comment">// median1：前一部分的最大值</span></span><br><span class="line">        <span class="comment">// median2：后一部分的最小值</span></span><br><span class="line">        <span class="type">int</span> median1 = <span class="number">0</span>, median2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 前一部分包含 nums1[0 .. i-1] 和 nums2[0 .. j-1]</span></span><br><span class="line">            <span class="comment">// 后一部分包含 nums1[i .. m-1] 和 nums2[j .. n-1]</span></span><br><span class="line">            <span class="type">int</span> i = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> j = (m + n + <span class="number">1</span>) / <span class="number">2</span> - i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// nums_im1, nums_i, nums_jm1, nums_j 分别表示 nums1[i-1], nums1[i], nums2[j-1], nums2[j]</span></span><br><span class="line">            <span class="type">int</span> nums_im1 = (i == <span class="number">0</span> ? INT_MIN : nums1[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="type">int</span> nums_i = (i == m ? INT_MAX : nums1[i]);</span><br><span class="line">            <span class="type">int</span> nums_jm1 = (j == <span class="number">0</span> ? INT_MIN : nums2[j - <span class="number">1</span>]);</span><br><span class="line">            <span class="type">int</span> nums_j = (j == n ? INT_MAX : nums2[j]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums_im1 &lt;= nums_j) &#123;</span><br><span class="line">                median1 = <span class="built_in">max</span>(nums_im1, nums_jm1);</span><br><span class="line">                median2 = <span class="built_in">min</span>(nums_i, nums_j);</span><br><span class="line">                left = i + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = i - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (m + n) % <span class="number">2</span> == <span class="number">0</span> ? (median1 + median2) / <span class="number">2.0</span> : median1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</details>

<h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h3><div class="tabs" id="tab-v5"><ul class="nav-tabs"><li class="tab"><a href="#tab-v5-1">初见</a></li><li class="tab"><a href="#tab-v5-2">折叠表格</a></li></ul><div class="tab-content"><div class="tab-pane" id="tab-v5-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">         string result;</span><br><span class="line">        <span class="type">int</span> lengthOfResult = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> length = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != length; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> j = i;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; length &amp;&amp; s[j] == s[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> k = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; k &lt; length &amp;&amp; s[j] == s[k]) &#123;</span><br><span class="line">                    --j;</span><br><span class="line">                    ++k;</span><br><span class="line">                &#125;</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">                k -= <span class="number">1</span>;</span><br><span class="line">                result = (lengthOfResult &gt; k - j + <span class="number">1</span>) ? result : s.<span class="built_in">substr</span>(j, k - j + <span class="number">1</span>);</span><br><span class="line">                lengthOfResult = (lengthOfResult &gt; k - j + <span class="number">1</span>) ? lengthOfResult : k - j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j = i;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">2</span> &lt; length &amp;&amp; s[j] == s[j + <span class="number">2</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> k = j + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; k &lt; length &amp;&amp; s[j] == s[k]) &#123;</span><br><span class="line">                    --j;</span><br><span class="line">                    ++k;</span><br><span class="line">                &#125;</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">                k -= <span class="number">1</span>;</span><br><span class="line">                result = (lengthOfResult &gt; k - j + <span class="number">1</span>) ? result : s.<span class="built_in">substr</span>(j, k - j + <span class="number">1</span>);</span><br><span class="line">                lengthOfResult = (lengthOfResult &gt; k - j + <span class="number">1</span>) ? lengthOfResult : k - j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(result.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            result += s[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-v5-2"></div></div></div>

]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网Verilog刷题笔记1</title>
    <url>/2022/04/26/nowcoder/nowcoder1-verilog24/</url>
    <content><![CDATA[<h3 id="VL24-边沿检测"><a href="#VL24-边沿检测" class="headerlink" title="VL24 边沿检测"></a>VL24 边沿检测</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> edge_detect(</span><br><span class="line">	<span class="keyword">input</span> clk,</span><br><span class="line">	<span class="keyword">input</span> rst_n,</span><br><span class="line">	<span class="keyword">input</span> a,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> rise,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> down</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">reg</span> past;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            past &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            past &lt;= a;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            rise &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            down &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            rise &lt;= ((~past &amp; a) === <span class="number">1&#x27;b1</span>)? <span class="number">1</span> : <span class="number">0</span>;		<span class="comment">//使用全等于，避免未知态带来的影响</span></span><br><span class="line">            down &lt;= ((past &amp; ~a) === <span class="number">1&#x27;b1</span>)? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h2 id="进阶挑战"><a href="#进阶挑战" class="headerlink" title="进阶挑战"></a>进阶挑战</h2><h3 id="VL2-含有无关项的序列检测"><a href="#VL2-含有无关项的序列检测" class="headerlink" title="VL2 含有无关项的序列检测"></a>VL2 含有无关项的序列检测</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> sequence_detect(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> rst_n,</span><br><span class="line">    <span class="keyword">input</span> a,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> match</span><br><span class="line">    );</span><br><span class="line">	<span class="comment">//因为存在三位无关项，用状态机需要用到太多状态了，实现起来较为困难</span></span><br><span class="line">	<span class="comment">//故使用9位移位寄存器实现</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">8</span>:<span class="number">0</span>] data;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (~rst_n)</span><br><span class="line">            data &lt;= <span class="number">9&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            data &lt;=&#123;data[<span class="number">7</span>:<span class="number">0</span>], a&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (~rst_n)</span><br><span class="line">            match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((data[<span class="number">8</span>:<span class="number">6</span>]==<span class="number">3&#x27;b011</span>)&amp;(data[<span class="number">2</span>:<span class="number">0</span>]==<span class="number">3&#x27;b110</span>))	<span class="comment">//中间三项为无关项</span></span><br><span class="line">            match &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL3-不重叠序列检测"><a href="#VL3-不重叠序列检测" class="headerlink" title="VL3 不重叠序列检测"></a>VL3 不重叠序列检测</h3><h4 id="移位寄存器方法"><a href="#移位寄存器方法" class="headerlink" title="移位寄存器方法"></a>移位寄存器方法</h4><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> sequence_detect(</span><br><span class="line">	<span class="keyword">input</span> clk,</span><br><span class="line">	<span class="keyword">input</span> rst_n,</span><br><span class="line">	<span class="keyword">input</span> data,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> match,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> not_match</span><br><span class="line">	);</span><br><span class="line">    <span class="comment">//counter</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            cnt &lt;= <span class="number">3&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">3&#x27;d6</span>)</span><br><span class="line">            cnt &lt;= <span class="number">3&#x27;d1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//shifting register</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">5</span>:<span class="number">0</span>] data_in;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_in &lt;= <span class="number">6&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            data_in &lt;= &#123;data_in[<span class="number">4</span>:<span class="number">0</span>], data&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">3&#x27;d6</span>)</span><br><span class="line">            <span class="keyword">case</span>(data_in)</span><br><span class="line">                <span class="number">6&#x27;b011100</span>: <span class="keyword">begin</span></span><br><span class="line">                    match &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                    not_match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                    match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    not_match &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            not_match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h4 id="状态机方法"><a href="#状态机方法" class="headerlink" title="状态机方法"></a>状态机方法</h4><details class="note info no-icon"><summary><p>code</p>
</summary>
<p>用状态机方法还是会用到计数器，个人感觉移位寄存器方法要更简单一点，以下是状态机方法：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> sequence_detect(</span><br><span class="line">	<span class="keyword">input</span> clk,</span><br><span class="line">	<span class="keyword">input</span> rst_n,</span><br><span class="line">	<span class="keyword">input</span> data,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> match,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> not_match</span><br><span class="line">	);</span><br><span class="line">    <span class="comment">//state machine</span></span><br><span class="line">    <span class="comment">//counter</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            cnt &lt;= <span class="number">3&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">3&#x27;d6</span>)</span><br><span class="line">            cnt &lt;= <span class="number">3&#x27;d1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//set state</span></span><br><span class="line">    <span class="keyword">localparam</span> IDLE = <span class="number">0</span>, S0 = <span class="number">1</span>, S01 = <span class="number">2</span>, S011 = <span class="number">3</span>, S0111 = <span class="number">4</span>, S01110 = <span class="number">5</span>, S011100 = <span class="number">6</span>, SErro = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] state , next;</span><br><span class="line">    <span class="comment">//state transition</span></span><br><span class="line">    <span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(state)</span><br><span class="line">            IDLE   : next = data ? SErro : S0;</span><br><span class="line">            SErro  : <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(cnt == <span class="number">3&#x27;d6</span>) </span><br><span class="line">                    next = data ? SErro : S0;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    next = SErro;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S0     : next = data ? S01  : SErro;</span><br><span class="line">            S01    : next = data ? S011 : SErro;</span><br><span class="line">            S011   : next = data ? S0111: SErro;</span><br><span class="line">            S0111  : next = data ? SErro: S01110;</span><br><span class="line">            S01110 : next = data ? SErro: S011100;</span><br><span class="line">            S011100: next = data ? SErro: S0;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//state flip-flops</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            state &lt;= IDLE;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            state &lt;= next;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            not_match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(state == S011100) <span class="keyword">begin</span></span><br><span class="line">            match &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            not_match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((state == SErro)&amp;(cnt == <span class="number">3&#x27;d6</span>)) <span class="keyword">begin</span></span><br><span class="line">            match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            not_match &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            not_match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL4-输入序列不连续的序列检测"><a href="#VL4-输入序列不连续的序列检测" class="headerlink" title="VL4 输入序列不连续的序列检测"></a>VL4 输入序列不连续的序列检测</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> sequence_detect(</span><br><span class="line">	<span class="keyword">input</span> clk,</span><br><span class="line">	<span class="keyword">input</span> rst_n,</span><br><span class="line">	<span class="keyword">input</span> data,</span><br><span class="line">	<span class="keyword">input</span> data_valid,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> match</span><br><span class="line">	);</span><br><span class="line">    <span class="comment">//state machine</span></span><br><span class="line">    <span class="comment">//set state</span></span><br><span class="line">    <span class="keyword">localparam</span> IDLE = <span class="number">0</span>, S0 = <span class="number">1</span>, S01 = <span class="number">2</span>, S011 = <span class="number">3</span>, S0110 = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] state, next;</span><br><span class="line">    <span class="comment">//state transition</span></span><br><span class="line">    <span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(state)</span><br><span class="line">            IDLE: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(data_valid)</span><br><span class="line">                    next = data ? IDLE : S0;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    next = IDLE;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S0: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(data_valid)</span><br><span class="line">                    next = data ? S01 : S0;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    next = IDLE;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S01: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(data_valid)</span><br><span class="line">                    next = data ? S011 : S0;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    next = IDLE;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S011: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(data_valid)</span><br><span class="line">                    next = data ? IDLE : S0110;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    next = IDLE;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S0110: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(data_valid)</span><br><span class="line">                    next = data ? S01 : S0;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    next = IDLE;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//state flip-flops</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            state &lt;= IDLE;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            state &lt;= next;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">case</span>(next)</span><br><span class="line">            S0110: match &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">default</span>: match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL5-信号发生器-（这道题蛮难的）"><a href="#VL5-信号发生器-（这道题蛮难的）" class="headerlink" title="VL5 信号发生器 （这道题蛮难的）"></a>VL5 信号发生器 （这道题蛮难的）</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> signal_generator(</span><br><span class="line">	<span class="keyword">input</span> clk,</span><br><span class="line">	<span class="keyword">input</span> rst_n,</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] wave_choise,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>]wave</span><br><span class="line">	);</span><br><span class="line">    <span class="comment">//counter (only for retangular wave)</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n | (wave_choise != <span class="number">2&#x27;b00</span>)) </span><br><span class="line">            cnt &lt;= <span class="number">5&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">5&#x27;d19</span>)</span><br><span class="line">            cnt &lt;= <span class="number">5&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//delta wave flag (only for delta wave)</span></span><br><span class="line">    <span class="keyword">reg</span> flag;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n | (wave_choise != <span class="number">2&#x27;b10</span>)) </span><br><span class="line">            flag &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(wave == <span class="number">5&#x27;d1</span>)</span><br><span class="line">            flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(wave == <span class="number">5&#x27;d19</span>)</span><br><span class="line">            flag &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            wave &lt;= <span class="number">5&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">case</span>(wave_choise)</span><br><span class="line">            <span class="number">2&#x27;b00</span>: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(cnt == <span class="number">5&#x27;d19</span>)</span><br><span class="line">                    wave &lt;= <span class="number">5&#x27;d0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">5&#x27;d9</span>)</span><br><span class="line">                    wave &lt;= <span class="number">5&#x27;d20</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">2&#x27;b01</span>: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(wave == <span class="number">5&#x27;d20</span>)</span><br><span class="line">                    wave &lt;= <span class="number">5&#x27;d0</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    wave &lt;= wave + <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">2&#x27;b10</span>: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(wave == <span class="number">5&#x27;d20</span>)				<span class="comment">//考虑到刚好在wave=20以及wave=0时发生波形变化</span></span><br><span class="line">                    wave &lt;= wave - <span class="number">1&#x27;b1</span>;		<span class="comment">//</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(wave == <span class="number">5&#x27;d0</span>)			<span class="comment">//</span></span><br><span class="line">                    wave &lt;= wave + <span class="number">1&#x27;b1</span>;		<span class="comment">//</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(flag)</span><br><span class="line">                    wave &lt;= wave - <span class="number">1&#x27;b1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    wave &lt;= wave + <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span>: wave &lt;= <span class="number">5&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL6-数据串转并电路"><a href="#VL6-数据串转并电路" class="headerlink" title="VL6 数据串转并电路"></a>VL6 数据串转并电路</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> s_to_p(</span><br><span class="line">	<span class="keyword">input</span> 				clk 		,   </span><br><span class="line">	<span class="keyword">input</span> 				rst_n		,</span><br><span class="line">	<span class="keyword">input</span>				valid_a		,</span><br><span class="line">	<span class="keyword">input</span>	 			data_a		,</span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">output</span>	<span class="keyword">reg</span> 		ready_a		,</span><br><span class="line"> 	<span class="keyword">output</span>	<span class="keyword">reg</span>			valid_b		,</span><br><span class="line">	<span class="keyword">output</span>  <span class="keyword">reg</span> [<span class="number">5</span>:<span class="number">0</span>] 	data_b</span><br><span class="line">);</span><br><span class="line">    <span class="comment">//根据题意，一直拉高ready_a</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) </span><br><span class="line">            ready_a &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ready_a &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//counter</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) </span><br><span class="line">            cnt &lt;= <span class="number">3&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_a &amp; ready_a) <span class="keyword">begin</span>        <span class="comment">//输入数据有效时，counter才开始计数</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">3&#x27;d5</span>)</span><br><span class="line">                cnt &lt;= <span class="number">3&#x27;d0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cnt &lt;= cnt;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//6-bit shifting register</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">5</span>:<span class="number">0</span>] data_temp;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_temp &lt;= <span class="number">6&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_a &amp; ready_a)</span><br><span class="line">            data_temp &lt;= &#123;data_a, data_temp[<span class="number">5</span>:<span class="number">1</span>]&#125;;    <span class="comment">//最新的输入数据存放在最高位</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            valid_b &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            data_b &lt;= <span class="number">6&#x27;b000000</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">3&#x27;d5</span>) <span class="keyword">begin</span></span><br><span class="line">            valid_b &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            data_b &lt;= &#123;data_a, data_temp[<span class="number">5</span>:<span class="number">1</span>]&#125;;        <span class="comment">//此时的输出应当是最新的1位输入和计数时暂存的5位拼接而成</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            valid_b &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            data_b &lt;= data_b;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL7-数据累加输出-（抄的答案，这题还需加深理解）"><a href="#VL7-数据累加输出-（抄的答案，这题还需加深理解）" class="headerlink" title="VL7 数据累加输出 （抄的答案，这题还需加深理解）"></a>VL7 数据累加输出 （抄的答案，这题还需加深理解）</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> valid_ready(</span><br><span class="line">	<span class="keyword">input</span> 				clk 		,   </span><br><span class="line">	<span class="keyword">input</span> 				rst_n		,</span><br><span class="line">	<span class="keyword">input</span>		[<span class="number">7</span>:<span class="number">0</span>]	data_in		,</span><br><span class="line">	<span class="keyword">input</span>				valid_a		,</span><br><span class="line">	<span class="keyword">input</span>	 			ready_b		,</span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">output</span>		 		ready_a		,</span><br><span class="line"> 	<span class="keyword">output</span>	<span class="keyword">reg</span>			valid_b		,</span><br><span class="line">	<span class="keyword">output</span>  <span class="keyword">reg</span> [<span class="number">9</span>:<span class="number">0</span>] 	data_out</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] data_cnt;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">assign</span> ready_a = ~valid_b | ready_b;	<span class="comment">//表示下游准备好接受本模块的输出或者本模块还没有产生有效输出时，本模块可以接受上游的输出。如此保证不会产生数据丢失，且保持本模块保持满速。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n ) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) </span><br><span class="line">            data_cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_a &amp;&amp; ready_a)</span><br><span class="line">            data_cnt &lt;= (data_cnt == <span class="number">2&#x27;d3</span>) ? <span class="number">&#x27;d0</span> : (data_cnt + <span class="number">1&#x27;d1</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n ) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) </span><br><span class="line">            valid_b &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data_cnt == <span class="number">2&#x27;d3</span> &amp;&amp; valid_a &amp;&amp; ready_a)</span><br><span class="line">            valid_b &lt;= <span class="number">1&#x27;d1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_b &amp;&amp; ready_b)</span><br><span class="line">            valid_b &lt;= <span class="number">1&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n ) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) </span><br><span class="line">            data_out &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ready_b &amp;&amp; valid_a &amp;&amp; ready_a &amp;&amp; (data_cnt == <span class="number">2&#x27;d0</span>))</span><br><span class="line">            data_out &lt;= data_in;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_a &amp;&amp; ready_a)</span><br><span class="line">            data_out &lt;= data_out + data_in;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL8-非整数倍数据位宽转换24to128-（看懂了VL7，这题就感觉蛮简单了）"><a href="#VL8-非整数倍数据位宽转换24to128-（看懂了VL7，这题就感觉蛮简单了）" class="headerlink" title="VL8 非整数倍数据位宽转换24to128 （看懂了VL7，这题就感觉蛮简单了）"></a>VL8 非整数倍数据位宽转换24to128 （看懂了VL7，这题就感觉蛮简单了）</h3><div class="tabs" id="tab-vl8"><ul class="nav-tabs"><li class="tab"><a href="#tab-vl8-1">Solution 1</a></li><li class="tab"><a href="#tab-vl8-2">Solution2</a></li><li class="tab"><a href="#tab-vl8-3">折叠表格</a></li></ul><div class="tab-content"><div class="tab-pane" id="tab-vl8-1"><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> width_24to128(</span><br><span class="line">	<span class="keyword">input</span> 				clk 		,   </span><br><span class="line">	<span class="keyword">input</span> 				rst_n		,</span><br><span class="line">	<span class="keyword">input</span>				valid_in	,</span><br><span class="line">	<span class="keyword">input</span>	[<span class="number">23</span>:<span class="number">0</span>]		data_in		,</span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">output</span>	<span class="keyword">reg</span>			valid_out	,</span><br><span class="line">	<span class="keyword">output</span>  <span class="keyword">reg</span> [<span class="number">127</span>:<span class="number">0</span>]	data_out</span><br><span class="line">);</span><br><span class="line">    <span class="comment">//16-counter</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            cnt &lt;= <span class="number">4&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in)</span><br><span class="line">            cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output valid_out</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((cnt == <span class="number">4&#x27;d5</span>)|(cnt == <span class="number">4&#x27;d10</span>)|(cnt == <span class="number">4&#x27;d15</span>))</span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output data</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">23</span>:<span class="number">0</span>] data_temp1;			<span class="comment">//设置data_temp1用以缓存一个data_in</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_temp1 &lt;= <span class="number">24&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in)</span><br><span class="line">            data_temp1 &lt;= data_in;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">128</span>:<span class="number">0</span>] data_temp2;			<span class="comment">//设置data_temp2只是为了迎合牛客网的tb，它的tb要求在输出无效时，输出必须为0，故用data_temp2作为移位寄存器</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_temp2 &lt;= <span class="number">128&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">4&#x27;d5</span>)</span><br><span class="line">                data_temp2 &lt;= &#123;data_temp2[<span class="number">119</span>:<span class="number">0</span>], data_in[<span class="number">23</span>:<span class="number">16</span>]&#125;;	<span class="comment">//5*24 + 8 = 128</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">4&#x27;d6</span>)</span><br><span class="line">                data_temp2 &lt;= &#123;data_temp2[<span class="number">87</span>:<span class="number">0</span>], data_temp1[<span class="number">15</span>:<span class="number">0</span>], data_in&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">4&#x27;d10</span>)</span><br><span class="line">                data_temp2 &lt;= &#123;data_temp2[<span class="number">111</span>:<span class="number">0</span>], data_in[<span class="number">23</span>:<span class="number">8</span>]&#125;;	<span class="comment">//16 + 24*4 + 16 = 128</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">4&#x27;d11</span>)</span><br><span class="line">                data_temp2 &lt;= &#123;data_temp2[<span class="number">95</span>:<span class="number">0</span>], data_temp1[<span class="number">7</span>:<span class="number">0</span>], data_in&#125;;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                data_temp2 &lt;= &#123;data_temp2[<span class="number">103</span>:<span class="number">0</span>], data_in&#125;;			<span class="comment">//8 + 24*5 = 128</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_out &lt;= <span class="number">128&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">4&#x27;d5</span>)</span><br><span class="line">                data_out &lt;= &#123;data_temp2[<span class="number">119</span>:<span class="number">0</span>], data_in[<span class="number">23</span>:<span class="number">16</span>]&#125;;	<span class="comment">//5*24 + 8 = 128</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">4&#x27;d10</span>)</span><br><span class="line">                data_out &lt;= &#123;data_temp2[<span class="number">111</span>:<span class="number">0</span>], data_in[<span class="number">23</span>:<span class="number">8</span>]&#125;;		<span class="comment">//16 + 24*4 + 16 = 128</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">4&#x27;d15</span>)</span><br><span class="line">                data_out &lt;= &#123;data_temp2[<span class="number">103</span>:<span class="number">0</span>], data_in&#125;;			<span class="comment">//8 + 24*5 = 128</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-vl8-2"><p>修改后占用资源更少：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> width_24to128(</span><br><span class="line">	<span class="keyword">input</span> 				clk 		,   </span><br><span class="line">	<span class="keyword">input</span> 				rst_n		,</span><br><span class="line">	<span class="keyword">input</span>				valid_in	,</span><br><span class="line">	<span class="keyword">input</span>	[<span class="number">23</span>:<span class="number">0</span>]		data_in		,</span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">output</span>	<span class="keyword">reg</span>			valid_out	,</span><br><span class="line">	<span class="keyword">output</span>  <span class="keyword">reg</span> [<span class="number">127</span>:<span class="number">0</span>]	data_out</span><br><span class="line">);</span><br><span class="line">    <span class="comment">//16-counter</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            cnt &lt;= <span class="number">4&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in)</span><br><span class="line">            cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output valid_out</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((cnt == <span class="number">4&#x27;d5</span>)|(cnt == <span class="number">4&#x27;d10</span>)|(cnt == <span class="number">4&#x27;d15</span>)&amp;valid_in)</span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output data</span></span><br><span class="line">    <span class="comment">//cnt==5时，data_temp的值为&#123;data_in_0[7:0],data_in_1,data_in_2,data_in_3,data_in_4,data_in_5&#125;；</span></span><br><span class="line">    <span class="comment">//cnt==9时，data_temp的值为&#123;data_in_4[7:0],data_in_5,data_in_6,data_in_7,data_in_8,data_in_9&#125;；</span></span><br><span class="line">    <span class="comment">//cnt==14时，data_temp的值为&#123;data_in_9[7:0],data_in_10,data_in_11,data_in_12,data_in_13,data_in_14&#125;</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">128</span>:<span class="number">0</span>] data_temp;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_temp &lt;= <span class="number">128&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in) </span><br><span class="line">            data_temp &lt;= &#123;data_temp[<span class="number">103</span>:<span class="number">0</span>], data_in&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_out &lt;= <span class="number">128&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">4&#x27;d5</span>)</span><br><span class="line">                data_out &lt;= &#123;data_temp[<span class="number">119</span>:<span class="number">0</span>], data_in[<span class="number">23</span>:<span class="number">16</span>]&#125;;	<span class="comment">//5*24 + 8 = 128</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">4&#x27;d10</span>)</span><br><span class="line">                data_out &lt;= &#123;data_temp[<span class="number">111</span>:<span class="number">0</span>], data_in[<span class="number">23</span>:<span class="number">8</span>]&#125;;	<span class="comment">//16 + 24*4 + 16 = 128</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">4&#x27;d15</span>)</span><br><span class="line">                data_out &lt;= &#123;data_temp[<span class="number">103</span>:<span class="number">0</span>], data_in&#125;;		<span class="comment">//8 + 24*5 = 128</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-vl8-3"></div></div></div>

<h3 id="VL9-非整数倍数据位宽转换8to12"><a href="#VL9-非整数倍数据位宽转换8to12" class="headerlink" title="VL9 非整数倍数据位宽转换8to12"></a>VL9 非整数倍数据位宽转换8to12</h3><div class="tabs" id="tab-vl9"><ul class="nav-tabs"><li class="tab"><a href="#tab-vl9-1">Solution 1</a></li><li class="tab"><a href="#tab-vl9-2">Solution2</a></li><li class="tab"><a href="#tab-vl9-3">折叠表格</a></li></ul><div class="tab-content"><div class="tab-pane" id="tab-vl9-1"><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> width_8to12(</span><br><span class="line">	<span class="keyword">input</span> 				   clk 		,   </span><br><span class="line">	<span class="keyword">input</span> 			      rst_n		,</span><br><span class="line">	<span class="keyword">input</span>				      valid_in	,</span><br><span class="line">	<span class="keyword">input</span>	[<span class="number">7</span>:<span class="number">0</span>]			   data_in	,</span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">output</span>  <span class="keyword">reg</span>			   valid_out,</span><br><span class="line">	<span class="keyword">output</span>  <span class="keyword">reg</span> [<span class="number">11</span>:<span class="number">0</span>]   data_out</span><br><span class="line">);</span><br><span class="line">    <span class="comment">//counter</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            cnt &lt;= <span class="number">2&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">2&#x27;b10</span>)</span><br><span class="line">                cnt &lt;= <span class="number">2&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output valid_out</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(((cnt == <span class="number">2&#x27;b01</span>) | (cnt == <span class="number">2&#x27;b10</span>)) &amp; valid_in)</span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//shifting register</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] data_temp1;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">11</span>:<span class="number">0</span>] data_temp2;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_temp1 &lt;= <span class="number">8&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in)</span><br><span class="line">            data_temp1 &lt;= data_in;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_temp2 &lt;= <span class="number">8&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">2&#x27;b01</span>)</span><br><span class="line">                data_temp2 &lt;= &#123;data_temp2[<span class="number">7</span>:<span class="number">0</span>], data_in[<span class="number">7</span>:<span class="number">4</span>]&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">2&#x27;b10</span>)</span><br><span class="line">                data_temp2 &lt;= &#123;data_temp1[<span class="number">3</span>:<span class="number">0</span>], data_in&#125;;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                data_temp2 &lt;= &#123;data_temp2[<span class="number">3</span>:<span class="number">0</span>], data_in&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_out &lt;= <span class="number">12&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">2&#x27;b01</span>)</span><br><span class="line">                data_out &lt;= &#123;data_temp2[<span class="number">7</span>:<span class="number">0</span>], data_in[<span class="number">7</span>:<span class="number">4</span>]&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">2&#x27;b10</span>)</span><br><span class="line">                data_out &lt;= &#123;data_temp1[<span class="number">3</span>:<span class="number">0</span>], data_in&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-vl9-2"><p>修改后资源占用更少：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> test(</span><br><span class="line">	<span class="keyword">input</span> 				   clk 		,   </span><br><span class="line">	<span class="keyword">input</span> 			      rst_n		,</span><br><span class="line">	<span class="keyword">input</span>				      valid_in	,</span><br><span class="line">	<span class="keyword">input</span>	[<span class="number">7</span>:<span class="number">0</span>]			   data_in	,</span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">output</span>  <span class="keyword">reg</span>			   valid_out,</span><br><span class="line">	<span class="keyword">output</span>  <span class="keyword">reg</span> [<span class="number">11</span>:<span class="number">0</span>]   data_out</span><br><span class="line">);</span><br><span class="line">    <span class="comment">//counter</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            cnt &lt;= <span class="number">2&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">2&#x27;b10</span>)</span><br><span class="line">                cnt &lt;= <span class="number">2&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output valid_out</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(((cnt == <span class="number">2&#x27;b01</span>) | (cnt == <span class="number">2&#x27;b10</span>)) &amp; valid_in)</span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//shifting register</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">11</span>:<span class="number">0</span>] data_temp;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_temp &lt;= <span class="number">12&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in)</span><br><span class="line">            data_temp &lt;= &#123;data_temp[<span class="number">3</span>:<span class="number">0</span>], data_in&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_out &lt;= <span class="number">12&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">2&#x27;b01</span>)</span><br><span class="line">                data_out &lt;= &#123;data_temp[<span class="number">7</span>:<span class="number">0</span>], data_in[<span class="number">7</span>:<span class="number">4</span>]&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">2&#x27;b10</span>)</span><br><span class="line">                data_out &lt;= &#123;data_temp[<span class="number">3</span>:<span class="number">0</span>], data_in&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-vl9-3"></div></div></div>

<h3 id="VL10-整数倍数据位宽转换8to16"><a href="#VL10-整数倍数据位宽转换8to16" class="headerlink" title="VL10 整数倍数据位宽转换8to16"></a>VL10 整数倍数据位宽转换8to16</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> width_8to16(</span><br><span class="line">	<span class="keyword">input</span> clk,   </span><br><span class="line">	<span class="keyword">input</span> rst_n,</span><br><span class="line">	<span class="keyword">input</span> valid_in,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] data_in,</span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">output</span> <span class="keyword">reg</span> valid_out,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] data_out</span><br><span class="line">);</span><br><span class="line">    <span class="comment">//counter</span></span><br><span class="line">    <span class="keyword">reg</span> cnt;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            cnt &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in)</span><br><span class="line">            cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output valid_out</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((cnt == <span class="number">1&#x27;b1</span>) &amp; valid_in)</span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//shifting register</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] data_temp;							<span class="comment">//整数倍转换只需要一个寄存器</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_temp &lt;= <span class="number">8&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(valid_in)</span><br><span class="line">            data_temp &lt;= data_in;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_out &lt;= <span class="number">16&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((cnt== <span class="number">1&#x27;b1</span>) &amp; valid_in)</span><br><span class="line">            data_out &lt;= &#123;data_temp, data_in&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL11-状态机-非重叠的序列检测"><a href="#VL11-状态机-非重叠的序列检测" class="headerlink" title="VL11 状态机-非重叠的序列检测"></a>VL11 状态机-非重叠的序列检测</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<p>用了一个很常规的三段式状态机：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> sequence_test1(</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> clk  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> rst  ,				<span class="comment">//这里的rst其实是低电平有效，但是题目给的名字时rst</span></span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> data ,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> flag</span><br><span class="line">);</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">    <span class="comment">//set state</span></span><br><span class="line">    <span class="keyword">localparam</span> IDLE = <span class="number">0</span>, S1 = <span class="number">1</span>, S10 = <span class="number">2</span>, S101 = <span class="number">3</span>, S1011 = <span class="number">4</span>, S10111 = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] state, next;</span><br><span class="line">    <span class="comment">//state transition</span></span><br><span class="line">    <span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(state)</span><br><span class="line">            IDLE:   next = data ? S1	: IDLE	;</span><br><span class="line">            S1:		next = data ? S1	: S10	;</span><br><span class="line">			S10:	next = data ? S101	: IDLE	;</span><br><span class="line">			S101:	next = data ? S1011	: S10	;</span><br><span class="line">			S1011:	next = data ? S10111: S10	;</span><br><span class="line">			S10111:	next = data ? S1	: IDLE	;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">	 <span class="comment">//state flip-flops</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~rst)</span><br><span class="line">			state &lt;= IDLE;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			state &lt;= next;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">//output</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~rst)</span><br><span class="line">			flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">case</span>(next)</span><br><span class="line">			S10111:	flag &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">			<span class="keyword">default</span>: flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL12-状态机-重叠序列检测"><a href="#VL12-状态机-重叠序列检测" class="headerlink" title="VL12 状态机-重叠序列检测"></a>VL12 状态机-重叠序列检测</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> sequence_test2(</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> clk  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> rst  ,				<span class="comment">//这里的rst其实是低电平有效，但是题目给的名字时rst</span></span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> data ,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> flag</span><br><span class="line">);</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">	<span class="comment">//set state</span></span><br><span class="line">	<span class="keyword">localparam</span> IDLE = <span class="number">0</span>, S1 = <span class="number">1</span>, S10 = <span class="number">2</span>, S101 = <span class="number">3</span>, S1011 = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] state, next;</span><br><span class="line">	<span class="comment">//state transition</span></span><br><span class="line">	<span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">case</span>(state)</span><br><span class="line">			IDLE:   next = data ? S1	: IDLE	;</span><br><span class="line">			S1:		next = data ? S1	: S10	;</span><br><span class="line">			S10:	next = data ? S101	: IDLE	;</span><br><span class="line">			S101:	next = data ? S1011	: S10	;</span><br><span class="line">			S1011:	next = data ? S1	: S10	;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">	 <span class="comment">//state flip-flops</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~rst)</span><br><span class="line">			state &lt;= IDLE;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			state &lt;= next;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">//output</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~rst)</span><br><span class="line">			flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">case</span>(state)</span><br><span class="line">			S1011:	flag &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">			<span class="keyword">default</span>: flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL13-时钟分频（偶数）"><a href="#VL13-时钟分频（偶数）" class="headerlink" title="VL13 时钟分频（偶数）"></a>VL13 时钟分频（偶数）</h3><div class="tabs" id="tab-vl13"><ul class="nav-tabs"><li class="tab"><a href="#tab-vl13-1">有计数器</a></li><li class="tab"><a href="#tab-vl13-2">无计数器</a></li><li class="tab"><a href="#tab-vl13-3">折叠表格</a></li></ul><div class="tab-content"><div class="tab-pane" id="tab-vl13-1"><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> even_div</span><br><span class="line">    (</span><br><span class="line">    <span class="keyword">input</span>     <span class="keyword">wire</span> rst ,			<span class="comment">//这里的rst其实是低电平有效，但是题目给的名字时rst</span></span><br><span class="line">    <span class="keyword">input</span>     <span class="keyword">wire</span> clk_in,</span><br><span class="line">    <span class="keyword">output</span>    <span class="keyword">reg</span> clk_out2,</span><br><span class="line">    <span class="keyword">output</span>    <span class="keyword">reg</span> clk_out4,</span><br><span class="line">    <span class="keyword">output</span>    <span class="keyword">reg</span> clk_out8</span><br><span class="line">    );</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">    <span class="comment">//counter</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) </span><br><span class="line">            cnt &lt;= <span class="number">3&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//clk_out2</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) </span><br><span class="line">            clk_out2 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            clk_out2 &lt;= ~clk_out2;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//clk_out4</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) </span><br><span class="line">            clk_out4 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((cnt == <span class="number">2&#x27;d0</span>) | (cnt == <span class="number">2&#x27;d2</span>))</span><br><span class="line">            clk_out4 &lt;= ~clk_out4;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//clk_out8</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) </span><br><span class="line">            clk_out8 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">2&#x27;d0</span>)</span><br><span class="line">            clk_out8 &lt;= ~clk_out8;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-vl13-2"><p>不含计数器的做法，实际使用时不推荐：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> even_div</span><br><span class="line">    (</span><br><span class="line">    <span class="keyword">input</span>	<span class="keyword">wire</span> rst ,				<span class="comment">//这里的rst其实是低电平有效，但是题目给的名字时rst</span></span><br><span class="line">    <span class="keyword">input</span>	<span class="keyword">wire</span> clk_in,				</span><br><span class="line">    <span class="keyword">output</span>	<span class="keyword">reg</span> clk_out2,</span><br><span class="line">    <span class="keyword">output</span>	<span class="keyword">reg</span> clk_out4,</span><br><span class="line">    <span class="keyword">output</span>	<span class="keyword">reg</span> clk_out8</span><br><span class="line">    );</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">    <span class="comment">//clk_out2</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) </span><br><span class="line">            clk_out2 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            clk_out2 &lt;= ~clk_out2;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//clk_out4</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_out2 <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) </span><br><span class="line">            clk_out4 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            clk_out4 &lt;= ~clk_out4;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//clk_out8</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_out4 <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) </span><br><span class="line">            clk_out8 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            clk_out8 &lt;= ~clk_out8;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p> 此方法在<u>低频信号中可以使用，但是在高频时钟下会出现失误</u>， 在FPGA中所有的时钟都要连接到<strong>全局时钟网络</strong>中去，又叫全局时钟数，其目的是为了保证时钟信号到达每一个器件的时间都尽可能相同，<u>而这种方法并没有连接到全局时钟网络中</u> 。</p>
<p>想要改进，可以使用脉冲标志信号，即在每个所需周期末尾输出一个clk_flag脉冲信号，利用<code>always@(posedge clk or negedge rst_n) </code>和<code>if(clk_flag = 1&#39;b1)</code>达到分频的目的。</p></div><div class="tab-pane" id="tab-vl13-3"></div></div></div>

<h3 id="VL14-自动贩售机1"><a href="#VL14-自动贩售机1" class="headerlink" title="VL14 自动贩售机1"></a>VL14 自动贩售机1</h3><div class="tabs" id="tab-vl14"><ul class="nav-tabs"><li class="tab"><a href="#tab-vl14-1">状态机方法</a></li><li class="tab"><a href="#tab-vl14-2">非状态机方法</a></li><li class="tab"><a href="#tab-vl14-3">折叠表格</a></li></ul><div class="tab-content"><div class="tab-pane" id="tab-vl14-1"><p>因为题目中的d1，d2，d3只输入半个周期高电平，所以需要增加3个寄存器来存放输入，写出来的代码有点笨重：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> seller1(</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> clk  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> rst  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> d1 ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> d2 ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> d3 ,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> out1,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>]out2</span><br><span class="line">);</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">    <span class="comment">//state machine</span></span><br><span class="line">    <span class="comment">//set state</span></span><br><span class="line">    <span class="keyword">localparam</span> IDLE = <span class="number">0</span>, S05 = <span class="number">1</span>, S10 = <span class="number">2</span>, S15 = <span class="number">3</span>, S20 = <span class="number">4</span>, S25 = <span class="number">5</span>, S30 = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] state, next;</span><br><span class="line">    <span class="comment">//state transition</span></span><br><span class="line">    <span class="keyword">reg</span> rg1, rg2, rg3;        <span class="comment">//save d1, d2, d3</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            rg1 &lt;= <span class="number">0</span>;</span><br><span class="line">            rg2 &lt;= <span class="number">0</span>;</span><br><span class="line">            rg3 &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            rg1 &lt;= d1;</span><br><span class="line">            rg2 &lt;= d2;</span><br><span class="line">            rg3 &lt;= d3;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(state)</span><br><span class="line">            IDLE: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(rg3)</span><br><span class="line">                    next = S20;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rg2)</span><br><span class="line">                    next = S10;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rg1)</span><br><span class="line">                    next = S05;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    next = IDLE;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S05: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(rg3)</span><br><span class="line">                    next = S25;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rg2)</span><br><span class="line">                    next = S15;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rg1)</span><br><span class="line">                    next = S10;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    next = S05;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S10: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(rg3)</span><br><span class="line">                    next = S30;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rg2)</span><br><span class="line">                    next = S20;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rg1)</span><br><span class="line">                    next = S15;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    next = S10;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S15: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(rg3)</span><br><span class="line">                    next = S20;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rg2)</span><br><span class="line">                    next = S10;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rg1)</span><br><span class="line">                    next = S05;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    next = IDLE;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S20: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(rg3)</span><br><span class="line">                    next = S20;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rg2)</span><br><span class="line">                    next = S10;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rg1)</span><br><span class="line">                    next = S05;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    next = IDLE;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S25: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(rg3)</span><br><span class="line">                    next = S20;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rg2)</span><br><span class="line">                    next = S10;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rg1)</span><br><span class="line">                    next = S05;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    next = IDLE;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S30: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(rg3)</span><br><span class="line">                    next = S20;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rg2)</span><br><span class="line">                    next = S10;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rg1)</span><br><span class="line">                    next = S05;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    next = IDLE;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//state flip-flps</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst)</span><br><span class="line">            state &lt;= IDLE;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            state &lt;= next;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            out1 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            out2 &lt;= <span class="number">2&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">case</span>(next)</span><br><span class="line">            S15: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                out2 &lt;= <span class="number">2&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S20: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                out2 &lt;= <span class="number">2&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S25: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                out2 &lt;= <span class="number">2&#x27;d2</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S30: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                out2 &lt;= <span class="number">2&#x27;d3</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                out2 &lt;= <span class="number">2&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-vl14-2"><p>从代码量来看都能看出比状态机方法简单一些</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> seller1(</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> clk  ,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> rst  ,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> d1 ,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> d2 ,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> d3 ,</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> out1,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>]out2</span><br><span class="line">);</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] money05;</span><br><span class="line">    <span class="comment">//accumulating money</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst)</span><br><span class="line">            money05 &lt;= <span class="number">3&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((money05[<span class="number">2</span>]==<span class="number">1</span>) | (money05[<span class="number">1</span>:<span class="number">0</span>]==<span class="number">2&#x27;b11</span>))	<span class="comment">//此时累积金钱大于3 * 0.5元</span></span><br><span class="line">            money05 &lt;= <span class="number">3&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">case</span>(&#123;d3, d2, d1&#125;)</span><br><span class="line">            <span class="number">3&#x27;b001</span>: money05 &lt;= money05 + <span class="number">1&#x27;d1</span>;</span><br><span class="line">            <span class="number">3&#x27;b010</span>: money05 &lt;= money05 + <span class="number">2&#x27;d2</span>;</span><br><span class="line">            <span class="number">3&#x27;b100</span>: money05 &lt;= money05 + <span class="number">3&#x27;d4</span>;</span><br><span class="line">            <span class="keyword">default</span>: money05 &lt;= money05;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">	<span class="comment">//output</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            out1 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            out2 &lt;= <span class="number">2&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">case</span>(money05)				<span class="comment">//根据累积金钱来判断输出</span></span><br><span class="line">            <span class="number">3&#x27;d3</span>: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                out2 &lt;= <span class="number">2&#x27;d0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;d4</span>: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                out2 &lt;= <span class="number">2&#x27;d1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;d5</span>: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                out2 &lt;= <span class="number">2&#x27;d2</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;d6</span>: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                out2 &lt;= <span class="number">2&#x27;d3</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                out2 &lt;= <span class="number">2&#x27;d0</span>;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-vl14-3"></div></div></div>

<h3 id="VL15-自动贩售机2"><a href="#VL15-自动贩售机2" class="headerlink" title="VL15 自动贩售机2"></a>VL15 自动贩售机2</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> seller2(</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> clk  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> rst  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> d1 ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> d2 ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> sel ,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> out1,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> out2,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> out3</span><br><span class="line">);</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] money05;</span><br><span class="line">    <span class="comment">//accumulating money</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst)</span><br><span class="line">            money05 &lt;= <span class="number">3&#x27;d0</span>;</span><br><span class="line">        <span class="comment">//判断是否满足出饮料的条件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(((money05[<span class="number">2</span>] | (money05[<span class="number">1</span>] &amp; money05[<span class="number">0</span>])) &amp; ~sel) | (money05[<span class="number">2</span>] &amp; (money05[<span class="number">1</span>] | money05[<span class="number">0</span>]) &amp; sel))</span><br><span class="line">            money05 &lt;= <span class="number">3&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">case</span>(&#123;d2, d1&#125;)</span><br><span class="line">            <span class="number">2&#x27;b01</span>: money05 &lt;= money05 + <span class="number">1&#x27;d1</span>;</span><br><span class="line">            <span class="number">2&#x27;b10</span>: money05 &lt;= money05 + <span class="number">2&#x27;d2</span>;</span><br><span class="line">            <span class="keyword">default</span>: money05 &lt;= money05;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">	<span class="comment">//output    </span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            out1 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            out2 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            out3 &lt;= <span class="number">2&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">case</span>(money05)				<span class="comment">//根据累积金钱来判断输出</span></span><br><span class="line">            <span class="number">3&#x27;d3</span>: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= sel ? <span class="number">1&#x27;b0</span> : <span class="number">1&#x27;b1</span>;</span><br><span class="line">                out2 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                out3 &lt;= <span class="number">2&#x27;d0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;d4</span>: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= sel ? <span class="number">1&#x27;b0</span> : <span class="number">1&#x27;b1</span>;</span><br><span class="line">                out2 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                out3 &lt;= sel ? <span class="number">2&#x27;d0</span> : <span class="number">2&#x27;d1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;d5</span>: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= sel ? <span class="number">1&#x27;b0</span> : <span class="number">1&#x27;b1</span>;</span><br><span class="line">                out2 &lt;= sel ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line">                out3 &lt;= sel ? <span class="number">2&#x27;d0</span> : <span class="number">2&#x27;d2</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;d6</span>: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= sel ? <span class="number">1&#x27;b0</span> : <span class="number">1&#x27;b1</span>;</span><br><span class="line">                out2 &lt;= sel ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line">                out3 &lt;= sel ? <span class="number">2&#x27;d1</span> : <span class="number">2&#x27;d3</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                out2 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                out3 &lt;= <span class="number">2&#x27;d0</span>;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL16-占空比50-的奇数分频-（有待复习，这题是重点！！）"><a href="#VL16-占空比50-的奇数分频-（有待复习，这题是重点！！）" class="headerlink" title="VL16 占空比50%的奇数分频 （有待复习，这题是重点！！）"></a>VL16 占空比50%的奇数分频 （有待复习，这题是重点！！）</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> odo_div_or</span><br><span class="line">	(</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>	rst,</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>	clk_in,</span><br><span class="line">	<span class="keyword">output</span>	<span class="keyword">wire</span>	clk_out7</span><br><span class="line">);</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">	<span class="keyword">localparam</span> N = <span class="number">7</span>;</span><br><span class="line">	<span class="comment">//counter_p</span></span><br><span class="line">    <span class="keyword">reg</span> [$clog(N)-<span class="number">1</span>:<span class="number">0</span>] cnt_p;</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~rst)</span><br><span class="line">			cnt_p &lt;= <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(cnt_p == N-<span class="number">1</span>)</span><br><span class="line">			cnt_p &lt;= <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			cnt_p &lt;= cnt_p + <span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">//clk_p</span></span><br><span class="line">	<span class="keyword">reg</span> clk_p;</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~rst)</span><br><span class="line">			clk_p &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((cnt_p == (N-<span class="number">1</span>)/<span class="number">2</span>) | (cnt_p == N-<span class="number">1</span>))	<span class="comment">//这里的除法可以换成移位，即cnt_p&gt;&gt;1</span></span><br><span class="line">			clk_p &lt;= ~clk_p;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">//counter_n</span></span><br><span class="line">	<span class="keyword">reg</span> [$clog(N)-<span class="number">1</span>:<span class="number">0</span>] cnt_n;</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">negedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~rst)</span><br><span class="line">			cnt_n &lt;= <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(cnt_n == N-<span class="number">1</span>)</span><br><span class="line">			cnt_n &lt;= <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			cnt_n &lt;= cnt_n + <span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">//clk_n</span></span><br><span class="line">	<span class="keyword">reg</span> clk_n;</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">negedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~rst)</span><br><span class="line">			clk_n &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((cnt_n == (N-<span class="number">1</span>)/<span class="number">2</span>) | (cnt_n == N-<span class="number">1</span>))	<span class="comment">//这里的除法可以换成移位，即cnt_n&gt;&gt;1</span></span><br><span class="line">			clk_n &lt;= ~clk_n;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">//output</span></span><br><span class="line">	<span class="keyword">assign</span> clk_out7 = clk_p | clk_n;</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <tags>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网Verilog刷题笔记2</title>
    <url>/2022/04/29/nowcoder/nowcoder2-verilog17/</url>
    <content><![CDATA[<h3 id="VL17-任意小数分频"><a href="#VL17-任意小数分频" class="headerlink" title="VL17 任意小数分频"></a>VL17 任意小数分频</h3><p>核心思想是让10个clk_out周期是clk_in周期的87倍，无法让clk_out的每个周期都相等，但可以让其尽量接近，所以把87拆分成3 * 8 + 7 * 9，即3个8分频和7个9分频。</p>
<p>本题答案对9分频部分的占空比没有要求，不过利用V16的方法可以使得9分频的占空比为50%</p>
<details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> div_M_N(</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span> clk_in,</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span> rst,</span><br><span class="line">	<span class="keyword">output</span>	<span class="keyword">reg</span> clk_out</span><br><span class="line">);</span><br><span class="line"><span class="keyword">parameter</span> M_N = <span class="number">8&#x27;d87</span>; </span><br><span class="line"><span class="keyword">parameter</span> c89 = <span class="number">8&#x27;d24</span>; <span class="comment">// 8/9时钟切换点</span></span><br><span class="line"><span class="keyword">parameter</span> div_e = <span class="number">5&#x27;d8</span>; <span class="comment">//偶数周期</span></span><br><span class="line"><span class="keyword">parameter</span> div_o = <span class="number">5&#x27;d9</span>; <span class="comment">//奇数周期</span></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="comment">//考虑10个clk_out时钟周期是1个clk_in时钟周期的87倍</span></span><br><span class="line">	<span class="comment">//counter</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">6</span>:<span class="number">0</span>] cnt;		<span class="comment">//总计数器</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~rst)</span><br><span class="line">			cnt &lt;= <span class="number">6&#x27;d0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(cnt == (M_N - <span class="number">1&#x27;b1</span>))</span><br><span class="line">			cnt &lt;= <span class="number">6&#x27;d0</span>;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">reg</span> state;			<span class="comment">//state为0时8分频，为1时9分频</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~rst)</span><br><span class="line">			state &lt;= <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>((cnt == (c89 - <span class="number">1&#x27;b1</span>)) | (cnt == (M_N - <span class="number">1&#x27;b1</span>)))</span><br><span class="line">			state &lt;= ~state;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_d;	<span class="comment">//分频计数器</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~rst)</span><br><span class="line">			cnt_d &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(state == <span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">			<span class="keyword">if</span>(cnt_d == div_e - <span class="number">1&#x27;b1</span>)</span><br><span class="line">				cnt_d &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				cnt_d &lt;= cnt_d + <span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(state == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt_d == div_o - <span class="number">1&#x27;b1</span>)</span><br><span class="line">				cnt_d &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				cnt_d &lt;= cnt_d + <span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">//div</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~rst)</span><br><span class="line">			clk_out &lt;= <span class="number">1&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">case</span>(state)</span><br><span class="line">			<span class="number">1&#x27;b0</span>: <span class="keyword">begin</span></span><br><span class="line">				<span class="keyword">if</span>((cnt_d == div_e/<span class="number">2</span>) | (cnt_d == <span class="number">4&#x27;d0</span>)) </span><br><span class="line">					clk_out &lt;= ~clk_out;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">1&#x27;b1</span>: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>((cnt_d == (div_o - <span class="number">1&#x27;b1</span>)/<span class="number">2</span>) | (cnt_d == <span class="number">4&#x27;d0</span>)) </span><br><span class="line">                    clk_out &lt;= ~clk_out;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL18-无占空比要求的奇数分频"><a href="#VL18-无占空比要求的奇数分频" class="headerlink" title="VL18 无占空比要求的奇数分频"></a>VL18 无占空比要求的奇数分频</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> odd_div (    </span><br><span class="line">    <span class="keyword">input</span>     <span class="keyword">wire</span> rst ,</span><br><span class="line">    <span class="keyword">input</span>     <span class="keyword">wire</span> clk_in,</span><br><span class="line">    <span class="keyword">output</span>    <span class="keyword">wire</span> clk_out5</span><br><span class="line">);</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">    <span class="keyword">localparam</span> N = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">localparam</span> SIZE = <span class="number">2</span>;</span><br><span class="line">	<span class="comment">//counter</span></span><br><span class="line">    <span class="keyword">reg</span> [SIZE:<span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst)</span><br><span class="line">            cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt == N - <span class="number">1</span>)</span><br><span class="line">            cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//div</span></span><br><span class="line">    <span class="keyword">reg</span> clk_out;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst)</span><br><span class="line">            clk_out &lt;= <span class="number">1&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((cnt == (N - <span class="number">1</span>)/<span class="number">2</span>) | (cnt == <span class="number">0</span>))</span><br><span class="line">            clk_out &lt;= ~clk_out;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">assign</span> clk_out5 = clk_out;</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL19-根据状态转移写状态机-三段式"><a href="#VL19-根据状态转移写状态机-三段式" class="headerlink" title="VL19 根据状态转移写状态机-三段式"></a>VL19 根据状态转移写状态机-三段式</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> fsm1(</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> clk  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> rst  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> data ,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> flag</span><br><span class="line">);</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">    <span class="comment">//set state</span></span><br><span class="line">    <span class="keyword">localparam</span> S0 = <span class="number">0</span>, S1 = <span class="number">1</span>, S2 = <span class="number">2</span>, S3 = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] state, next;</span><br><span class="line">    <span class="comment">//state transition</span></span><br><span class="line">    <span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(state)</span><br><span class="line">            S0: next = data ? S1 : S0;</span><br><span class="line">            S1: next = data ? S2 : S1;</span><br><span class="line">            S2: next = data ? S3 : S2;</span><br><span class="line">            S3: next = data ? S0 : S3;</span><br><span class="line">            <span class="keyword">default</span>: next = S0;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//state flip-flops</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst)</span><br><span class="line">            state &lt;= S0;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            state &lt;= next;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output  三段式输出用时序逻辑  可以防止出现毛刺</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst)</span><br><span class="line">            flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">case</span>(state)</span><br><span class="line">            S3: flag &lt;= data;</span><br><span class="line">            <span class="keyword">default</span>: flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL20-根据状态转移写状态机-二段式"><a href="#VL20-根据状态转移写状态机-二段式" class="headerlink" title="VL20 根据状态转移写状态机-二段式"></a>VL20 根据状态转移写状态机-二段式</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> fsm2(</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> clk  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> rst  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> data ,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> flag</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">    <span class="comment">//set state</span></span><br><span class="line">    <span class="keyword">localparam</span> S0 = <span class="number">0</span>, S1 = <span class="number">1</span>, S2 = <span class="number">2</span>, S3 = <span class="number">3</span>, S4 = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] state, next;</span><br><span class="line">    <span class="comment">//state transition</span></span><br><span class="line">    <span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(state)</span><br><span class="line">            S0: next = data ? S1 : S0;</span><br><span class="line">            S1: next = data ? S2 : S1;</span><br><span class="line">            S2: next = data ? S3 : S2;</span><br><span class="line">            S3: next = data ? S4 : S3;</span><br><span class="line">            S4: next = S0;</span><br><span class="line">            <span class="keyword">default</span>: next = S0;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//state flip-flops</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst)</span><br><span class="line">            state &lt;= S0;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            state &lt;= next;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output  二段式输出用组合逻辑</span></span><br><span class="line">    <span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">        flag = (state == S4);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL21-异步FIFO-（有待复习，重点！！！）"><a href="#VL21-异步FIFO-（有待复习，重点！！！）" class="headerlink" title="VL21 异步FIFO （有待复习，重点！！！）"></a>VL21 异步FIFO （有待复习，重点！！！）</h3><p> FIFO指First Input First Output，即先进先出。FIFO存储器一般作为系统的缓冲环节，作用</p>
<ol>
<li>对连续的数据流进行缓存，防止在进机和存储操作时丢失数据；</li>
<li>数据集中起来进行进栈和存储，可避免频繁的总线操作，减轻CPU的负担；</li>
<li>允许系统进行DMA操作，提高数据的传输速度。这是至关重要的一点，如果不采用DMA操作，数据传输将达不到传输要求，而且大大增加CPU的负担，无法同时完成数据的存储工作。</li>
</ol>
<details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************RAM*****************************************/</span></span><br><span class="line"><span class="comment">// #()中定义的是 “可以提供给外部调用” 的常数参数</span></span><br><span class="line"><span class="keyword">module</span> dual_port_RAM #(<span class="keyword">parameter</span> DEPTH = <span class="number">16</span>, <span class="keyword">parameter</span> WIDTH = <span class="number">8</span>)(</span><br><span class="line">	<span class="keyword">input</span> wclk,</span><br><span class="line">	<span class="keyword">input</span> wenc,</span><br><span class="line">    <span class="keyword">input</span> [<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>] waddr,	<span class="comment">//$clog2()是对2取对数函数，深度对2取对数，得到地址的位宽</span></span><br><span class="line">    <span class="keyword">input</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] wdata,			<span class="comment">//数据写入</span></span><br><span class="line">	<span class="keyword">input</span> rclk,</span><br><span class="line">	<span class="keyword">input</span> renc,</span><br><span class="line">	<span class="keyword">input</span> [<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>] raddr,	<span class="comment">//深度对2取对数，得到地址的位宽</span></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] rdata		<span class="comment">//数据输出</span></span><br><span class="line">);</span><br><span class="line">	<span class="keyword">reg</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] RAM_MEM [<span class="number">0</span>:DEPTH-<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> wclk) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(wenc)</span><br><span class="line">			RAM_MEM[waddr] &lt;= wdata;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> rclk) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(renc)</span><br><span class="line">			rdata &lt;= RAM_MEM[raddr];</span><br><span class="line">	<span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endmodule</span>  </span><br><span class="line"><span class="comment">/***************************************AFIFO*****************************************/</span></span><br><span class="line"><span class="keyword">module</span> asyn_fifo#(</span><br><span class="line">	<span class="keyword">parameter</span>	WIDTH = <span class="number">8</span>,</span><br><span class="line">	<span class="keyword">parameter</span> 	DEPTH = <span class="number">16</span></span><br><span class="line">)(</span><br><span class="line">	<span class="keyword">input</span> 					wclk	, </span><br><span class="line">	<span class="keyword">input</span> 					rclk	,   </span><br><span class="line">	<span class="keyword">input</span> 					wrstn	,</span><br><span class="line">	<span class="keyword">input</span>					rrstn	,</span><br><span class="line">	<span class="keyword">input</span> 					winc	,</span><br><span class="line">	<span class="keyword">input</span> 			 		rinc	,</span><br><span class="line">	<span class="keyword">input</span> 		[WIDTH-<span class="number">1</span>:<span class="number">0</span>]	wdata	,</span><br><span class="line"></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span>				wfull	,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span>				rempty	,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>]	rdata</span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL22-同步FIFO"><a href="#VL22-同步FIFO" class="headerlink" title="VL22 同步FIFO"></a>VL22 同步FIFO</h3><div class="tabs" id="tab-vl22"><ul class="nav-tabs"><li class="tab"><a href="#tab-vl22-1">单纯做题</a></li><li class="tab"><a href="#tab-vl22-2">实现功能</a></li><li class="tab"><a href="#tab-vl22-3">折叠表格</a></li></ul><div class="tab-content"><div class="tab-pane" id="tab-vl22-1"><p>虽然通过了，但我的代码实际上是有问题的，答案给的波形也是有点问题的，<a href="https://blog.nowcoder.net/n/d5411484475d4c5c84ce711a6d668f7d">参考</a>。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="comment">/**********************************RAM************************************/</span></span><br><span class="line"><span class="keyword">module</span> dual_port_RAM #(<span class="keyword">parameter</span> DEPTH = <span class="number">16</span>,</span><br><span class="line">					   <span class="keyword">parameter</span> WIDTH = <span class="number">8</span>)(</span><br><span class="line">	 <span class="keyword">input</span> wclk</span><br><span class="line">	,<span class="keyword">input</span> wenc</span><br><span class="line">	,<span class="keyword">input</span> [<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>] waddr	<span class="comment">//深度对2取对数，得到地址的位宽。</span></span><br><span class="line">	,<span class="keyword">input</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] wdata			<span class="comment">//数据写入</span></span><br><span class="line">	,<span class="keyword">input</span> rclk</span><br><span class="line">	,<span class="keyword">input</span> renc</span><br><span class="line">	,<span class="keyword">input</span> [<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>] raddr	<span class="comment">//深度对2取对数，得到地址的位宽。</span></span><br><span class="line">	,<span class="keyword">output</span> <span class="keyword">reg</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] rdata		<span class="comment">//数据输出</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">reg</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] RAM_MEM [<span class="number">0</span>:DEPTH-<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> wclk) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(wenc)</span><br><span class="line">		RAM_MEM[waddr] &lt;= wdata;</span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line">    </span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> rclk) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(renc)</span><br><span class="line">		rdata &lt;= RAM_MEM[raddr];</span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endmodule</span>  </span><br><span class="line"><span class="comment">/**********************************SFIFO************************************/</span></span><br><span class="line"><span class="keyword">module</span> sfifo#(</span><br><span class="line">	<span class="keyword">parameter</span>	WIDTH = <span class="number">8</span>,</span><br><span class="line">	<span class="keyword">parameter</span> 	DEPTH = <span class="number">16</span></span><br><span class="line">)(</span><br><span class="line">	<span class="keyword">input</span> 					clk		, </span><br><span class="line">	<span class="keyword">input</span> 					rst_n	,</span><br><span class="line">	<span class="keyword">input</span> 					winc	,</span><br><span class="line">	<span class="keyword">input</span> 			 		rinc	,</span><br><span class="line">	<span class="keyword">input</span> 		[WIDTH-<span class="number">1</span>:<span class="number">0</span>]	wdata	,</span><br><span class="line"></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span>				wfull	,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span>				rempty	,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>]	rdata</span><br><span class="line">);</span><br><span class="line">    <span class="comment">//set enable signal</span></span><br><span class="line">    <span class="keyword">wire</span> wenc, renc;</span><br><span class="line">    <span class="keyword">assign</span> wenc = winc &amp; ~wfull;</span><br><span class="line">    <span class="keyword">assign</span> renc = rinc &amp; ~rempty;</span><br><span class="line">    <span class="comment">//address</span></span><br><span class="line">    <span class="comment">//这里的地址移动方式只有在DEPTH为2的整数次幂时才能正常工作</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="built_in">$clog2</span>(DEPTH):<span class="number">0</span>] waddr, raddr;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span>		<span class="comment">//waddr，when wfull == 1, keep waddr</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            waddr &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(winc) <span class="keyword">begin</span>							<span class="comment">//这部分可以简化，改成以下代码</span></span><br><span class="line">            <span class="keyword">if</span>((waddr[<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>] == raddr[<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>]) &amp; (waddr[<span class="built_in">$clog2</span>(DEPTH)] != raddr[<span class="built_in">$clog2</span>(DEPTH)]))</span><br><span class="line">                waddr &lt;= waddr;						<span class="comment">//else if(wenc)</span></span><br><span class="line">            <span class="keyword">else</span>									<span class="comment">//    waddr &lt;= waddr + 1&#x27;b1;</span></span><br><span class="line">                waddr &lt;= waddr + <span class="number">1&#x27;b1</span>;				<span class="comment">// </span></span><br><span class="line">        <span class="keyword">end</span>											<span class="comment">//</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span>		<span class="comment">//raddr，when rempty == 1, keep raddr</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            raddr &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rinc) <span class="keyword">begin</span>							<span class="comment">//同理可简化为以下</span></span><br><span class="line">            <span class="keyword">if</span>((waddr[<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>] == raddr[<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>]) &amp; (waddr[<span class="built_in">$clog2</span>(DEPTH)] == raddr[<span class="built_in">$clog2</span>(DEPTH)]))</span><br><span class="line">                raddr &lt;= raddr;						<span class="comment">//else if(renc)</span></span><br><span class="line">            <span class="keyword">else</span>									<span class="comment">//    raddr &lt;= raddr + 1&#x27;b1;</span></span><br><span class="line">                raddr &lt;= raddr + <span class="number">1&#x27;b1</span>;				<span class="comment">//</span></span><br><span class="line">        <span class="keyword">end</span>											<span class="comment">//</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//flag output</span></span><br><span class="line">    <span class="comment">//当读地址和写地址[$clog2(DEPTH)-1:0]位相同时，且最高位不同时，表明写地址超了读地址一圈，即写满了</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            wfull &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((waddr[<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>] == raddr[<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>]) &amp; (waddr[<span class="built_in">$clog2</span>(DEPTH)] != raddr[<span class="built_in">$clog2</span>(DEPTH)]))</span><br><span class="line">            wfull &lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            wfull &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//当读地址和写地址[$clog2(DEPTH)-1:0]位相同时，且最高位相同时，表明写地址与读地址相同，即读空了</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            rempty &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((waddr[<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>] == raddr[<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>]) &amp; (waddr[<span class="built_in">$clog2</span>(DEPTH)] == raddr[<span class="built_in">$clog2</span>(DEPTH)]))</span><br><span class="line">            rempty &lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rempty &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//RAM</span></span><br><span class="line">    dual_port_RAM  RAM1(</span><br><span class="line">        <span class="variable">.wclk</span>(clk),</span><br><span class="line">        <span class="variable">.wenc</span>(wenc),</span><br><span class="line">        <span class="variable">.waddr</span>(waddr[<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>]),			<span class="comment">//深度对2取对数，得到地址的位宽。</span></span><br><span class="line">        <span class="variable">.wdata</span>(wdata),		<span class="comment">//数据写入</span></span><br><span class="line">        <span class="variable">.rclk</span>(clk),</span><br><span class="line">        <span class="variable">.renc</span>(renc),</span><br><span class="line">        <span class="variable">.raddr</span>(raddr[<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>]),			<span class="comment">//深度对2取对数，得到地址的位宽。</span></span><br><span class="line">        <span class="variable">.rdata</span>(rdata)		<span class="comment">//数据输出</span></span><br><span class="line">    );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>波形如下，分析时序可以发现，在输入为19的那个时钟上升沿时，<code>waddr</code>已经变成了10，且<code>raddr</code>为00，即此时已经“写满”，但<code>wfull</code>信号要在下一个上升沿到来时才会跳变为·，这导致<code>waddr</code>多走了一位，从而引发后续一系列的错误。（这居然能通过，只能说牛客网这道题的testbench不是很理想）</p>
<img src="/2022/04/29/nowcoder/nowcoder2-verilog17/1651304204137.png" class="" width="1651304204137"></div><div class="tab-pane" id="tab-vl22-2"><p>将输出<code>wfull</code>和<code>rempty</code>部分改为组合逻辑后能够得到正常的波形，不过实际使用时组合逻辑很容易产生毛刺。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="comment">/**********************************RAM************************************/</span></span><br><span class="line"><span class="keyword">module</span> dual_port_RAM #(<span class="keyword">parameter</span> DEPTH = <span class="number">16</span>,</span><br><span class="line">					   <span class="keyword">parameter</span> WIDTH = <span class="number">8</span>)(</span><br><span class="line">	 <span class="keyword">input</span> wclk</span><br><span class="line">	,<span class="keyword">input</span> wenc</span><br><span class="line">	,<span class="keyword">input</span> [<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>] waddr  <span class="comment">//深度对2取对数，得到地址的位宽。</span></span><br><span class="line">	,<span class="keyword">input</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] wdata      	<span class="comment">//数据写入</span></span><br><span class="line">	,<span class="keyword">input</span> rclk</span><br><span class="line">	,<span class="keyword">input</span> renc</span><br><span class="line">	,<span class="keyword">input</span> [<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>] raddr  <span class="comment">//深度对2取对数，得到地址的位宽。</span></span><br><span class="line">	,<span class="keyword">output</span> <span class="keyword">reg</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] rdata 		<span class="comment">//数据输出</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] RAM_MEM [<span class="number">0</span>:DEPTH-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> wclk) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(wenc)</span><br><span class="line">		RAM_MEM[waddr] &lt;= wdata;</span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> rclk) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(renc)</span><br><span class="line">		rdata &lt;= RAM_MEM[raddr];</span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span>  </span><br><span class="line"><span class="comment">/**********************************SFIFO************************************/</span></span><br><span class="line"><span class="keyword">module</span> sfifo#(</span><br><span class="line">	<span class="keyword">parameter</span>	WIDTH = <span class="number">8</span>,</span><br><span class="line">	<span class="keyword">parameter</span> 	DEPTH = <span class="number">16</span></span><br><span class="line">)(</span><br><span class="line">	<span class="keyword">input</span> 					clk		, </span><br><span class="line">	<span class="keyword">input</span> 					rst_n	,</span><br><span class="line">	<span class="keyword">input</span> 					winc	,</span><br><span class="line">	<span class="keyword">input</span> 			 		rinc	,</span><br><span class="line">	<span class="keyword">input</span> 		[WIDTH-<span class="number">1</span>:<span class="number">0</span>]	wdata	,</span><br><span class="line"></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span>				wfull	,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span>				rempty	,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>]	rdata</span><br><span class="line">);</span><br><span class="line">    <span class="comment">//set enable signal</span></span><br><span class="line">    <span class="keyword">wire</span> wenc, renc;</span><br><span class="line">    <span class="keyword">assign</span> wenc = winc &amp; ~wfull;</span><br><span class="line">    <span class="keyword">assign</span> renc = rinc &amp; ~rempty;</span><br><span class="line">    <span class="comment">//address</span></span><br><span class="line">    <span class="comment">//这里的地址移动方式只有在DEPTH为2的整数次幂时才能正常工作</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="built_in">$clog2</span>(DEPTH):<span class="number">0</span>] waddr, raddr;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span>    <span class="comment">//waddr，when wfull == 1, keep waddr</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            waddr &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(wenc)</span><br><span class="line">            waddr &lt;= waddr + <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span>    <span class="comment">//raddr，when rempty == 1, keep raddr</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            raddr &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(renc) </span><br><span class="line">            raddr &lt;= raddr + <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="comment">//当读地址和写地址[$clog2(DEPTH)-1:0]位相同时，且最高位不同时，表明写地址超了读地址一圈，即写满了</span></span><br><span class="line">    <span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            wfull = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((waddr[<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>] == raddr[<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>]) &amp; (waddr[<span class="built_in">$clog2</span>(DEPTH)] != raddr[<span class="built_in">$clog2</span>(DEPTH)]))</span><br><span class="line">            wfull = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            wfull = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//当读地址和写地址[$clog2(DEPTH)-1:0]位相同时，且最高位相同时，表明写地址与读地址相同，即读空了</span></span><br><span class="line">    <span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            rempty = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((waddr[<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>] == raddr[<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>]) &amp; (waddr[<span class="built_in">$clog2</span>(DEPTH)] == raddr[<span class="built_in">$clog2</span>(DEPTH)]))</span><br><span class="line">            rempty = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rempty = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">	 <span class="comment">//RAM</span></span><br><span class="line">    dual_port_RAM  RAM1(</span><br><span class="line">        <span class="variable">.wclk</span>(clk),</span><br><span class="line">        <span class="variable">.wenc</span>(wenc),</span><br><span class="line">        <span class="variable">.waddr</span>(waddr[<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>]),        <span class="comment">//深度对2取对数，得到地址的位宽。</span></span><br><span class="line">        <span class="variable">.wdata</span>(wdata),        <span class="comment">//数据写入</span></span><br><span class="line">        <span class="variable">.rclk</span>(clk),</span><br><span class="line">        <span class="variable">.renc</span>(renc),</span><br><span class="line">        <span class="variable">.raddr</span>(raddr[<span class="built_in">$clog2</span>(DEPTH)-<span class="number">1</span>:<span class="number">0</span>]),        <span class="comment">//深度对2取对数，得到地址的位宽。</span></span><br><span class="line">        <span class="variable">.rdata</span>(rdata)        <span class="comment">//数据输出</span></span><br><span class="line">    );</span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>

<p>下图中可以看到，在输入为19的那个时钟上升沿时，<code>wfull</code>就已经跳变为1，系统不再记录后续的数据。从后续波形可以看出，没有发生数据覆盖。</p>
<img src="/2022/04/29/nowcoder/nowcoder2-verilog17/1651305030724.png" class="" width="1651305030724"></div><div class="tab-pane" id="tab-vl22-3"></div></div></div>

<h3 id="VL23-格雷码计数器"><a href="#VL23-格雷码计数器" class="headerlink" title="VL23 格雷码计数器"></a>VL23 格雷码计数器</h3><p>如果用二进制计数，再译码为格雷码输出，本质上还是二进制计数器，没有体现出格雷码计数时只改变一位的优势，所以采用状态机实现。各个状态直接用格雷码表示，状态转换时只会有一位发生改变。</p>
<details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> gray_counter(</span><br><span class="line">   <span class="keyword">input</span>   clk,</span><br><span class="line">   <span class="keyword">input</span>   rst_n,</span><br><span class="line"></span><br><span class="line">   <span class="keyword">output</span>  [<span class="number">3</span>:<span class="number">0</span>] gray_out</span><br><span class="line">);</span><br><span class="line">    <span class="comment">//二分频（很喜欢讨论区的一句话，什么逆天计数器）</span></span><br><span class="line">    <span class="keyword">reg</span> cnt;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            cnt &lt;= <span class="number">1&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cnt &lt;= cnt +<span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//set state (gray code)</span></span><br><span class="line">    <span class="keyword">localparam</span> S0 = <span class="number">4&#x27;b0000</span>, </span><br><span class="line">                S1 = <span class="number">4&#x27;b0001</span>, </span><br><span class="line">                S2 = <span class="number">4&#x27;b0011</span>, </span><br><span class="line">                S3 = <span class="number">4&#x27;b0010</span>, </span><br><span class="line">                S4 = <span class="number">4&#x27;b0110</span>, </span><br><span class="line">                S5 = <span class="number">4&#x27;b0111</span>, </span><br><span class="line">                S6 = <span class="number">4&#x27;b0101</span>, </span><br><span class="line">                S7 = <span class="number">4&#x27;b0100</span>, </span><br><span class="line">                S8 = <span class="number">4&#x27;b1100</span>, </span><br><span class="line">                S9 = <span class="number">4&#x27;b1101</span>, </span><br><span class="line">                S10 = <span class="number">4&#x27;b1111</span>, </span><br><span class="line">                S11 = <span class="number">4&#x27;b1110</span>, </span><br><span class="line">                S12 = <span class="number">4&#x27;b1010</span>, </span><br><span class="line">                S13 = <span class="number">4&#x27;b1011</span>, </span><br><span class="line">                S14 = <span class="number">4&#x27;b1001</span>, </span><br><span class="line">                S15 = <span class="number">4&#x27;b1000</span>;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] state, next;</span><br><span class="line">    <span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(state)</span><br><span class="line">            S0: next = S1;</span><br><span class="line">            S1: next = S2;</span><br><span class="line">            S2: next = S3;</span><br><span class="line">            S3: next = S4;</span><br><span class="line">            S4: next = S5;</span><br><span class="line">            S5: next = S6;</span><br><span class="line">            S6: next = S7;</span><br><span class="line">            S7: next = S8;</span><br><span class="line">            S8: next = S9;</span><br><span class="line">            S9: next = S10;</span><br><span class="line">            S10: next = S11;</span><br><span class="line">            S11: next = S12;</span><br><span class="line">            S12: next = S13;</span><br><span class="line">            S13: next = S14;</span><br><span class="line">            S14: next = S15;</span><br><span class="line">            S15: next = S0;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//state flip-flops</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            state &lt;= S0;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt)</span><br><span class="line">            state &lt;= next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            state &lt;= state;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">   <span class="keyword">assign</span> gray_out = state;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL24-多bit-MUX同步器"><a href="#VL24-多bit-MUX同步器" class="headerlink" title="VL24 多bit MUX同步器"></a>VL24 多bit MUX同步器</h3><div class="tabs" id="tab-vl24"><ul class="nav-tabs"><li class="tab"><a href="#tab-vl24-1">Solution 1</a></li><li class="tab"><a href="#tab-vl24-2">Solution 2</a></li><li class="tab"><a href="#tab-vl24-3">折叠表格</a></li></ul><div class="tab-content"><div class="tab-pane" id="tab-vl24-1"><p>这种做法用的寄存器资源较多，看了题解，发现让使能信号<code>data_en</code>“打两拍”可以达到同样的效果，而且节省资源。（题目说了data_in变化很慢，至少间隔10个B时钟周期，而且data_en为1至少保持3个B时钟周期）</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> mux(</span><br><span class="line">	<span class="keyword">input</span> 				clk_a	, </span><br><span class="line">	<span class="keyword">input</span> 				clk_b	,   </span><br><span class="line">	<span class="keyword">input</span> 				arstn	,</span><br><span class="line">	<span class="keyword">input</span>				brstn   ,</span><br><span class="line">	<span class="keyword">input</span>		[<span class="number">3</span>:<span class="number">0</span>]	data_in	,</span><br><span class="line">	<span class="keyword">input</span>               data_en ,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>  [<span class="number">3</span>:<span class="number">0</span>] 	dataout</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] data_temp1, data_temp2, data_temp3;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_a <span class="keyword">or</span> <span class="keyword">negedge</span> arstn) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!arstn) </span><br><span class="line">            data_temp1 &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data_en) </span><br><span class="line">            data_temp1 &lt;= data_in;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//对异步信号进行同步处理时，一般采用多级D触发器级联，这样做的好处是，当第一级寄存器产生亚稳态后，第二级寄存器稳定输出概率为90%，第三级为99%</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_b <span class="keyword">or</span> <span class="keyword">negedge</span> brstn) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!brstn) <span class="keyword">begin</span></span><br><span class="line">            data_temp2 &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line">            data_temp3 &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data_en) <span class="keyword">begin</span></span><br><span class="line">            data_temp2 &lt;= data_temp1;</span><br><span class="line">            data_temp3 &lt;= data_temp2;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_b <span class="keyword">or</span> <span class="keyword">negedge</span> brstn) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!brstn)</span><br><span class="line">            dataout &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data_en)</span><br><span class="line">            dataout &lt;= data_temp3;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-vl24-2"><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> mux(</span><br><span class="line">	<span class="keyword">input</span> 				clk_a	, </span><br><span class="line">	<span class="keyword">input</span> 				clk_b	,   </span><br><span class="line">	<span class="keyword">input</span> 				arstn	,</span><br><span class="line">	<span class="keyword">input</span>				brstn   ,</span><br><span class="line">	<span class="keyword">input</span>		[<span class="number">3</span>:<span class="number">0</span>]	data_in	,</span><br><span class="line">	<span class="keyword">input</span>               data_en ,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>  [<span class="number">3</span>:<span class="number">0</span>] 	dataout</span><br><span class="line">);</span><br><span class="line">    <span class="comment">//data_in变化很慢才能这样做，否则当使能信号同步到B端时，data_temp1已经发生变化了</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] data_temp1;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_a <span class="keyword">or</span> <span class="keyword">negedge</span> arstn) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!arstn)</span><br><span class="line">            data_temp1 &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            data_temp1 &lt;= data_in;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">reg</span> data_en_a;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_a <span class="keyword">or</span> <span class="keyword">negedge</span> arstn) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!arstn)</span><br><span class="line">            data_en_a &lt;= <span class="number">1&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            data_en_a &lt;= data_en;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//同步使能信号</span></span><br><span class="line">    <span class="keyword">reg</span> data_en_b1, data_en_b2;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_b <span class="keyword">or</span> <span class="keyword">negedge</span> brstn) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!brstn) <span class="keyword">begin</span></span><br><span class="line">            data_en_b1 &lt;= <span class="number">1&#x27;d0</span>;</span><br><span class="line">            data_en_b2 &lt;= <span class="number">1&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            data_en_b1 &lt;= data_en_a;</span><br><span class="line">            data_en_b2 &lt;= data_en_b1;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_b <span class="keyword">or</span> <span class="keyword">negedge</span> brstn) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!brstn)</span><br><span class="line">            dataout &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data_en_b2)</span><br><span class="line">            dataout &lt;= data_temp1;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            dataout &lt;= dataout;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-vl24-3"></div></div></div>

<h3 id="VL25-脉冲同步电路"><a href="#VL25-脉冲同步电路" class="headerlink" title="VL25 脉冲同步电路"></a>VL25 脉冲同步电路</h3><p>题目告知了A时域两个脉冲之间的间隔很大，故不用考虑两个脉冲间隔小于<code>clk_slow</code>的情况</p>
<details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> pulse_detect(</span><br><span class="line">	<span class="keyword">input</span> 				clk_fast	, </span><br><span class="line">	<span class="keyword">input</span> 				clk_slow	,   </span><br><span class="line">	<span class="keyword">input</span> 				rst_n		,</span><br><span class="line">	<span class="keyword">input</span>				data_in		,</span><br><span class="line"></span><br><span class="line">	<span class="keyword">output</span>	<span class="keyword">reg</span> 	 	dataout</span><br><span class="line">);</span><br><span class="line">    <span class="comment">//记录A时域(clk_fast)的脉冲，每产生一次脉冲会让data_fast_temp中电平翻转一次</span></span><br><span class="line">    <span class="keyword">reg</span> data_fast_temp;		<span class="comment">//相当于一个扩展信号，把A时域的脉冲展宽至两个相邻脉冲的间隔</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_fast <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_fast_temp &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            data_fast_temp &lt;= data_in? ~data_fast_temp : data_fast_temp;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//将data_fast_temp同步到B时域(clk_slow)</span></span><br><span class="line">    <span class="keyword">reg</span> data_slow_temp1, data_slow_temp2;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_slow <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            data_slow_temp1 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            data_slow_temp2 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            data_slow_temp1 &lt;= data_fast_temp;</span><br><span class="line">            data_slow_temp2 &lt;= data_slow_temp1;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//捕捉data_fast_temp的电平翻转，即是脉冲</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_slow <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            dataout &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            dataout &lt;= data_slow_temp1 ^ data_slow_temp2;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>

</details>

<p>自用test bench：</p>
<details class="note info no-icon"><summary><p>test bench</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1 ps/ 1 ps</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> clk_period 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> test_vlg_tst();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">reg</span> clk_fast, clk_slow, rst_n, data_in;</span><br><span class="line">    <span class="keyword">wire</span> dataout;</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clk_fast = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">forever</span> <span class="variable">#(`clk_period/2)</span> clk_fast = ~clk_fast;  <span class="comment">// Create clock with period=2</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clk_slow = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">forever</span> <span class="variable">#(`clk_period*10/2)</span> clk_slow = ~clk_slow;  <span class="comment">// Create clock with period=20</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">// A testbench</span></span><br><span class="line">    test u1(</span><br><span class="line">        <span class="variable">.clk_fast</span>(clk_fast) ,</span><br><span class="line">        <span class="variable">.clk_slow</span>(clk_slow),</span><br><span class="line">        <span class="variable">.rst_n</span>(rst_n),</span><br><span class="line">        <span class="variable">.data_in</span>(data_in),</span><br><span class="line">        <span class="variable">.dataout</span>(dataout)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">initial</span> rst_n = <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">initial</span> <span class="variable">#(`clk_period/2)</span> rst_n = <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        data_in = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">repeat</span>(<span class="number">30</span>) <span class="keyword">begin</span></span><br><span class="line">			  <span class="variable">#(`clk_period*200)</span> data_in = <span class="number">1</span>;</span><br><span class="line">			  <span class="variable">#(`clk_period*1)</span>	data_in = <span class="number">0</span>;</span><br><span class="line">			  </span><br><span class="line">			  <span class="variable">#(`clk_period*500)</span> data_in = <span class="number">1</span>;</span><br><span class="line">			  <span class="variable">#(`clk_period*1)</span>	data_in = <span class="number">0</span>;</span><br><span class="line">			  </span><br><span class="line">			  <span class="variable">#(`clk_period*300)</span> data_in = <span class="number">1</span>;</span><br><span class="line">			  <span class="variable">#(`clk_period*1)</span>	data_in = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		  <span class="variable">#(`clk_period*2000)</span> <span class="built_in">$stop</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>波形图：</p>
<img src="/2022/04/29/nowcoder/nowcoder2-verilog17/1651396044343.png" class="" width="1651396044343">

</details>

<h3 id="VL27-可置位计数器"><a href="#VL27-可置位计数器" class="headerlink" title="VL27 可置位计数器"></a>VL27 可置位计数器</h3><p>题目波形可以看出，一定要打一拍，也就是延迟一个时钟信号输出number。</p>
<details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> count_module(</span><br><span class="line">	<span class="keyword">input</span> clk,</span><br><span class="line">	<span class="keyword">input</span> rst_n,</span><br><span class="line">	<span class="keyword">input</span> set,</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] set_num,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]number,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> zero</span><br><span class="line">	);</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] num;</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">negedge</span> rst_n <span class="keyword">or</span> <span class="keyword">posedge</span> clk)<span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            num &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(set)</span><br><span class="line">            num &lt;= set_num;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">15</span>)</span><br><span class="line">            num &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            num &lt;= num + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">negedge</span> rst_n <span class="keyword">or</span> <span class="keyword">posedge</span> clk)<span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            zero &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">0</span>)</span><br><span class="line">            zero &lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            zero &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">negedge</span> rst_n <span class="keyword">or</span> <span class="keyword">posedge</span> clk)<span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            number &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            number &lt;= num;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL28-加减计数器"><a href="#VL28-加减计数器" class="headerlink" title="VL28 加减计数器"></a>VL28 加减计数器</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> count_module(</span><br><span class="line">	<span class="keyword">input</span> clk,</span><br><span class="line">	<span class="keyword">input</span> rst_n,</span><br><span class="line">	<span class="keyword">input</span> mode,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]number,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> zero</span><br><span class="line">	);</span><br><span class="line">     <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] num;</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">negedge</span> rst_n <span class="keyword">or</span> <span class="keyword">posedge</span> clk)<span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            num &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">case</span>(mode)</span><br><span class="line">            <span class="number">1&#x27;b0</span>: <span class="keyword">begin</span>		<span class="comment">//减法mode</span></span><br><span class="line">                <span class="keyword">if</span>(num==<span class="number">0</span>)</span><br><span class="line">                    num &lt;= <span class="number">9</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    num &lt;= num - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">1&#x27;b1</span>: <span class="keyword">begin</span>		<span class="comment">//加法mode</span></span><br><span class="line">                <span class="keyword">if</span>(num==<span class="number">9</span>)</span><br><span class="line">                    num &lt;= <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    num &lt;= num + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">negedge</span> rst_n <span class="keyword">or</span> <span class="keyword">posedge</span> clk)<span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            zero &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">0</span>)</span><br><span class="line">            zero &lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            zero &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">negedge</span> rst_n <span class="keyword">or</span> <span class="keyword">posedge</span> clk)<span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            number &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            number &lt;= num;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL29-单端口RAM"><a href="#VL29-单端口RAM" class="headerlink" title="VL29 单端口RAM"></a>VL29 单端口RAM</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> RAM_1port(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> rst,</span><br><span class="line">    <span class="keyword">input</span> enb,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">6</span>:<span class="number">0</span>]addr,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>]w_data,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>]r_data</span><br><span class="line">);</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] RAM_MEM [<span class="number">127</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">integer</span> i;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">127</span>;i=i+<span class="number">1</span>)</span><br><span class="line">                RAM_MEM[i] &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(enb)</span><br><span class="line">            RAM_MEM[addr] &lt;= w_data;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">assign</span> r_data = enb? <span class="number">0</span> : RAM_MEM[addr];</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL30-RAM的简单实现"><a href="#VL30-RAM的简单实现" class="headerlink" title="VL30 RAM的简单实现"></a>VL30 RAM的简单实现</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> ram_mod(</span><br><span class="line">	<span class="keyword">input</span> clk,</span><br><span class="line">	<span class="keyword">input</span> rst_n,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">input</span> write_en,</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>]write_addr,</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>]write_data,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">input</span> read_en,</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>]read_addr,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]read_data</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] RAM_MEM [<span class="number">255</span>:<span class="number">0</span>];    <span class="comment">//2^8 = 256</span></span><br><span class="line">    <span class="keyword">integer</span> i;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) </span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">255</span>; i = i + <span class="number">1</span>)</span><br><span class="line">                RAM_MEM[i] &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(write_en)</span><br><span class="line">            RAM_MEM[write_addr] &lt;= write_data;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            read_data = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(read_en)</span><br><span class="line">            read_data = read_en? RAM_MEM[read_addr] : read_data;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL31-Johnson-Counter-（扭环形计数器）"><a href="#VL31-Johnson-Counter-（扭环形计数器）" class="headerlink" title="VL31 Johnson Counter （扭环形计数器）"></a>VL31 Johnson Counter （扭环形计数器）</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> JC_counter(</span><br><span class="line">   <span class="keyword">input</span>                clk ,</span><br><span class="line">   <span class="keyword">input</span>                rst_n,</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]     Q  </span><br><span class="line">);</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">        	Q = <span class="number">4&#x27;b0000</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            Q = &#123;~Q[<span class="number">0</span>], Q[<span class="number">3</span>:<span class="number">1</span>]&#125;;	<span class="comment">//在无效态时，不可自启动</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL32-流水线乘法器-（待补充）"><a href="#VL32-流水线乘法器-（待补充）" class="headerlink" title="VL32 流水线乘法器 （待补充）"></a>VL32 流水线乘法器 （待补充）</h3><p>把二进制乘法拆解为每一位相乘，即4’b1010 * 4’b0101 &#x3D;( ‘b0 + ‘b10 + ‘b000 + ‘b1000) *  4’b0101；而二进制数乘以2^N就相当于左移N位，即( ‘b0 + ‘b10 + ‘b000 + ‘b1000) *  4’b0101 &#x3D; ‘b0 + ‘b0101&lt;&lt;1 + ‘b0 + ‘b0101&lt;&lt;3。</p>
<details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//未完成</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL33-交通灯"><a href="#VL33-交通灯" class="headerlink" title="VL33 交通灯"></a>VL33 交通灯</h3><p>暂存</p>
<details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> triffic_light</span><br><span class="line">    (</span><br><span class="line">		<span class="keyword">input</span> rst_n, <span class="comment">//异位复位信号，低电平有效</span></span><br><span class="line">        <span class="keyword">input</span> clk, <span class="comment">//时钟信号</span></span><br><span class="line">        <span class="keyword">input</span> pass_request,</span><br><span class="line">		<span class="keyword">output</span> <span class="keyword">wire</span>[<span class="number">7</span>:<span class="number">0</span>]clock,</span><br><span class="line">        <span class="keyword">output</span> <span class="keyword">reg</span> red,</span><br><span class="line">		<span class="keyword">output</span> <span class="keyword">reg</span> yellow,</span><br><span class="line">		<span class="keyword">output</span> <span class="keyword">reg</span> green</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//state machine</span></span><br><span class="line">    <span class="keyword">localparam</span> RED = <span class="number">0</span>, YELLOW = <span class="number">1</span>, GREEN = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] state, next;</span><br><span class="line">    <span class="comment">//set counter</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_red, cnt_yellow, cnt_green_l, cnt_green_h;</span><br><span class="line">    <span class="comment">//red counter 倒计时</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            cnt_red &lt;= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(next == RED) <span class="keyword">begin</span>       <span class="comment">//红灯时计时</span></span><br><span class="line">            cnt_red &lt;= cnt_red - <span class="number">1&#x27;b1</span>;    <span class="comment">//到0后发生状态转换，不需要借位</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cnt_red &lt;= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//yellow counter 倒计时</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            cnt_yellow &lt;= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(next == YELLOW)                <span class="comment">//黄灯时计时</span></span><br><span class="line">            cnt_yellow &lt;= cnt_yellow - <span class="number">1&#x27;b1</span>;    <span class="comment">//到0后发生状态转换，不需要借位</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cnt_yellow &lt;= <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//green counter 倒计时</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            cnt_green_l &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(next == GREEN) <span class="keyword">begin</span>       <span class="comment">//绿灯时计时</span></span><br><span class="line">            <span class="keyword">if</span>((cnt_green_h != <span class="number">0</span>) &amp;&amp; pass_request)</span><br><span class="line">                cnt_green_l &lt;= <span class="number">9</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt_green_l == <span class="number">0</span>)           <span class="comment">//减到0借位</span></span><br><span class="line">                cnt_green_l &lt;= <span class="number">9</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cnt_green_l &lt;= cnt_green_l - <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cnt_green_l &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            cnt_green_h &lt;= <span class="number">6</span>;                      <span class="comment">//从60开始倒计时</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(next == GREEN) <span class="keyword">begin</span>               <span class="comment">//绿灯时计时</span></span><br><span class="line">            <span class="keyword">if</span>((cnt_green_h != <span class="number">0</span>) &amp;&amp; pass_request)</span><br><span class="line">                cnt_green_h &lt;= <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt_green_l == <span class="number">0</span>)</span><br><span class="line">                cnt_green_h &lt;= cnt_green_h - <span class="number">1&#x27;b1</span>;    <span class="comment">//高位等于0后如果低位等于0会发生状态转换，故不需要借位</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cnt_green_h &lt;= <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//state transition</span></span><br><span class="line">    <span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(state)</span><br><span class="line">            RED: next = (cnt_red == <span class="number">0</span>) ? GREEN : RED;</span><br><span class="line">            GREEN: next = ((cnt_green_l==<span class="number">0</span>)&amp;(cnt_green_h==<span class="number">0</span>)) ? YELLOW : GREEN;</span><br><span class="line">            YELLOW: next = (cnt_yellow == <span class="number">0</span>) ? RED : YELLOW;</span><br><span class="line">            <span class="keyword">default</span>: next = RED;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//state flip-flops</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            state &lt;= RED;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            state &lt;= next;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            red &lt;= <span class="number">0</span>;</span><br><span class="line">            yellow &lt;= <span class="number">0</span>;</span><br><span class="line">            green &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">case</span>(next)</span><br><span class="line">            RED: <span class="keyword">begin</span></span><br><span class="line">                red &lt;= <span class="number">1</span>;</span><br><span class="line">                yellow &lt;= <span class="number">0</span>;</span><br><span class="line">                green &lt;= <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            YELLOW: <span class="keyword">begin</span></span><br><span class="line">                red &lt;= <span class="number">0</span>;</span><br><span class="line">                yellow &lt;= <span class="number">1</span>;</span><br><span class="line">                green &lt;= <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            GREEN: <span class="keyword">begin</span></span><br><span class="line">                red &lt;= <span class="number">0</span>;</span><br><span class="line">                yellow &lt;= <span class="number">0</span>;</span><br><span class="line">                green &lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">	<span class="comment">//outputclock</span></span><br><span class="line">	<span class="keyword">assign</span> clock = (state == RED) ? &#123;<span class="number">4&#x27;d0</span>, cnt_red&#125; :</span><br><span class="line">                  (state == YELLOW) ? &#123;<span class="number">4&#x27;d0</span>, cnt_yellow&#125; :</span><br><span class="line">                   (state == GREEN) ? &#123;cnt_green_h, cnt_green_l&#125; :</span><br><span class="line">                            <span class="number">8&#x27;d0</span>;</span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL34-游戏机计费程序"><a href="#VL34-游戏机计费程序" class="headerlink" title="VL34 游戏机计费程序"></a>VL34 游戏机计费程序</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<p>题目答案波形可以看出，加钱的时候不扣钱，这是否…</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> game_count</span><br><span class="line">    (</span><br><span class="line">		<span class="keyword">input</span> rst_n, <span class="comment">//异位复位信号，低电平有效</span></span><br><span class="line">        <span class="keyword">input</span> clk, 	<span class="comment">//时钟信号</span></span><br><span class="line">        <span class="keyword">input</span> [<span class="number">9</span>:<span class="number">0</span>]money,</span><br><span class="line">        <span class="keyword">input</span> set,</span><br><span class="line">		<span class="keyword">input</span> boost,</span><br><span class="line">		<span class="keyword">output</span> <span class="keyword">reg</span>[<span class="number">9</span>:<span class="number">0</span>]remain,</span><br><span class="line">		<span class="keyword">output</span> <span class="keyword">reg</span> yellow,</span><br><span class="line">		<span class="keyword">output</span> <span class="keyword">reg</span> red</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//每个时钟周期代表一分钟</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            remain &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">casex</span>(&#123;set, boost&#125;)</span><br><span class="line">            <span class="number">2&#x27;b1x</span>: remain &lt;= remain + money;</span><br><span class="line">            <span class="number">2&#x27;b01</span>: remain &lt;= remain - <span class="number">2</span>;</span><br><span class="line">            <span class="number">2&#x27;b00</span>: remain &lt;= remain - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">default</span>: ;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output yellow, red</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            yellow &lt;= <span class="number">0</span>;</span><br><span class="line">            red &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(remain == <span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">            yellow &lt;= <span class="number">0</span>;</span><br><span class="line">            red &lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(remain &lt; <span class="number">10</span>) <span class="keyword">begin</span></span><br><span class="line">            yellow &lt;= <span class="number">1</span>;</span><br><span class="line">            red &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            yellow &lt;= <span class="number">0</span>;</span><br><span class="line">            red &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>]]></content>
      <tags>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网Verilog刷题笔记3——企业真题</title>
    <url>/2022/05/02/nowcoder/nowcoder3-verilog2/</url>
    <content><![CDATA[<h3 id="VL2-使用握手信号实现跨时钟域数据传输-（有待复习）"><a href="#VL2-使用握手信号实现跨时钟域数据传输-（有待复习）" class="headerlink" title="VL2 使用握手信号实现跨时钟域数据传输 （有待复习）"></a>VL2 使用握手信号实现跨时钟域数据传输 （有待复习）</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> data_driver(</span><br><span class="line">	<span class="keyword">input</span> clk_a,</span><br><span class="line">	<span class="keyword">input</span> rst_n,</span><br><span class="line">	<span class="keyword">input</span> data_ack,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]data,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> data_req</span><br><span class="line">	);</span><br><span class="line">    <span class="comment">//counter </span></span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] cnt;</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_a <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~rst_n) </span><br><span class="line">			cnt &lt;= <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!data_req) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">4</span>)</span><br><span class="line">				cnt &lt;= <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			cnt &lt;= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output 0-7</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_a <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) </span><br><span class="line">            data &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data_ack_temp1 &amp; ~data_ack_temp2) <span class="keyword">begin</span></span><br><span class="line">			<span class="keyword">if</span>(data == <span class="number">7</span>)</span><br><span class="line">				data &lt;= <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				data &lt;= data + <span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//synchronize data_ack</span></span><br><span class="line">    <span class="keyword">reg</span> data_ack_temp1, data_ack_temp2;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_a <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            data_ack_temp1 &lt;= <span class="number">0</span>;</span><br><span class="line">            data_ack_temp2 &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            data_ack_temp1 &lt;= data_ack;</span><br><span class="line">            data_ack_temp2 &lt;= data_ack_temp1;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_a <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            data_ack_temp1 &lt;= <span class="number">0</span>;</span><br><span class="line">            data_ack_temp2 &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            data_ack_temp1 &lt;= data_ack;</span><br><span class="line">            data_ack_temp2 &lt;= data_ack_temp1;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output data_req</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_a <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) </span><br><span class="line">            data_req &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">4</span>)</span><br><span class="line">            data_req &lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data_ack_temp1 &amp; ~data_ack_temp2)</span><br><span class="line">            data_req &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> data_receiver(clk_b, rst_n, data, data_req, data_ack);</span><br><span class="line">    <span class="keyword">input</span> clk_b;</span><br><span class="line">    <span class="keyword">input</span> rst_n;</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] data;</span><br><span class="line">    <span class="keyword">input</span> data_req;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> data_ack;</span><br><span class="line">    <span class="comment">//synchronize data_ack</span></span><br><span class="line">    <span class="keyword">reg</span> data_req_temp1, data_req_temp2;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_b <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            data_req_temp1 &lt;= <span class="number">0</span>;</span><br><span class="line">            data_req_temp2 &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            data_req_temp1 &lt;= data_req;</span><br><span class="line">            data_req_temp2 &lt;= data_req_temp1;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output data_ack</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_b <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_ack &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data_req_temp1 &amp; ~data_req_temp2)</span><br><span class="line">            data_ack &lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            data_ack &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL3-自动售卖机"><a href="#VL3-自动售卖机" class="headerlink" title="VL3 自动售卖机"></a>VL3 自动售卖机</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<p>采用的是三段式Moore机</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> sale(</span><br><span class="line">   <span class="keyword">input</span>                clk   ,</span><br><span class="line">   <span class="keyword">input</span>                rst_n ,</span><br><span class="line">   <span class="keyword">input</span>                sel   ,<span class="comment">//sel=0,5$dranks,sel=1,10&amp;=$drinks</span></span><br><span class="line">   <span class="keyword">input</span>          [<span class="number">1</span>:<span class="number">0</span>] din   ,<span class="comment">//din=1,input 5$,din=2,input 10$</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">output</span>   <span class="keyword">reg</span>  [<span class="number">1</span>:<span class="number">0</span>] drinks_out,<span class="comment">//drinks_out=1,output 5$ drinks,drinks_out=2,output 10$ drinks</span></span><br><span class="line">   <span class="keyword">output</span>	<span class="keyword">reg</span>        change_out   </span><br><span class="line">);</span><br><span class="line">    <span class="comment">//state machine</span></span><br><span class="line">    <span class="comment">//set state</span></span><br><span class="line">    <span class="keyword">localparam</span> IDLE = <span class="number">0</span>, S005 = <span class="number">1</span>, S010 = <span class="number">2</span>, S105 = <span class="number">3</span>, S110 = <span class="number">4</span>, S115 = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] state, next;</span><br><span class="line">    <span class="comment">//state transition</span></span><br><span class="line">    <span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(state)</span><br><span class="line">            IDLE: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(sel)</span><br><span class="line">                    <span class="keyword">case</span>(din)</span><br><span class="line">                        <span class="number">2&#x27;d1</span>: next = S105;</span><br><span class="line">                        <span class="number">2&#x27;d2</span>: next = S110;</span><br><span class="line">                        <span class="keyword">default</span>: next = IDLE;</span><br><span class="line">                    <span class="keyword">endcase</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">case</span>(din)</span><br><span class="line">                        <span class="number">2&#x27;d1</span>: next = S005;</span><br><span class="line">                        <span class="number">2&#x27;d2</span>: next = S010;</span><br><span class="line">                        <span class="keyword">default</span>: next = IDLE;</span><br><span class="line">                    <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S105: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">case</span>(din)</span><br><span class="line">                    <span class="number">2&#x27;d1</span>: next = S110;</span><br><span class="line">                    <span class="number">2&#x27;d2</span>: next = S115;</span><br><span class="line">                    <span class="keyword">default</span>: next = S105;</span><br><span class="line">                <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">begin</span>	<span class="comment">//实现连续购买，即买完一次饮料后，不要回到IDLE态，而是继续响应下一次购买</span></span><br><span class="line">                <span class="keyword">if</span>(sel)</span><br><span class="line">                    <span class="keyword">case</span>(din)</span><br><span class="line">                        <span class="number">2&#x27;d1</span>: next = S105;</span><br><span class="line">                        <span class="number">2&#x27;d2</span>: next = S110;</span><br><span class="line">                        <span class="keyword">default</span>: next = IDLE;</span><br><span class="line">                    <span class="keyword">endcase</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">case</span>(din)</span><br><span class="line">                        <span class="number">2&#x27;d1</span>: next = S005;</span><br><span class="line">                        <span class="number">2&#x27;d2</span>: next = S010;</span><br><span class="line">                        <span class="keyword">default</span>: next = IDLE;</span><br><span class="line">                    <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//state flip-flops</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            state &lt;= IDLE;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            state &lt;= next;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            drinks_out &lt;= <span class="number">0</span>;</span><br><span class="line">            change_out &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">case</span>(next)</span><br><span class="line">            S005: <span class="keyword">begin</span></span><br><span class="line">                drinks_out &lt;= <span class="number">1</span>;</span><br><span class="line">                change_out &lt;= <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S010: <span class="keyword">begin</span></span><br><span class="line">                drinks_out &lt;= <span class="number">1</span>;</span><br><span class="line">                change_out &lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S110: <span class="keyword">begin</span></span><br><span class="line">                drinks_out &lt;= <span class="number">2</span>;</span><br><span class="line">                change_out &lt;= <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S115: <span class="keyword">begin</span></span><br><span class="line">                drinks_out &lt;= <span class="number">2</span>;</span><br><span class="line">                change_out &lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                drinks_out &lt;= <span class="number">0</span>;</span><br><span class="line">                change_out &lt;= <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL4-序列发生器"><a href="#VL4-序列发生器" class="headerlink" title="VL4 序列发生器"></a>VL4 序列发生器</h3><div class="tabs" id="tab-vl4"><ul class="nav-tabs"><li class="tab"><a href="#tab-vl4-1">计数器</a></li><li class="tab"><a href="#tab-vl4-2">移位寄存器</a></li><li class="tab"><a href="#tab-vl4-3">折叠表格</a></li></ul><div class="tab-content"><div class="tab-pane" id="tab-vl4-1"><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> sequence_generator(</span><br><span class="line">	<span class="keyword">input</span> clk,</span><br><span class="line">	<span class="keyword">input</span> rst_n,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> data</span><br><span class="line">	);</span><br><span class="line">    <span class="keyword">reg</span>  [<span class="number">2</span>:<span class="number">0</span>] cnt;    <span class="comment">//输出序列为6位，故6进制计数</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            cnt &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">5</span>)</span><br><span class="line">            cnt &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">case</span>(cnt)</span><br><span class="line">            <span class="number">3&#x27;d0</span>: data &lt;= <span class="number">0</span>;</span><br><span class="line">            <span class="number">3&#x27;d1</span>: data &lt;= <span class="number">0</span>;</span><br><span class="line">            <span class="number">3&#x27;d2</span>: data &lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="number">3&#x27;d3</span>: data &lt;= <span class="number">0</span>;</span><br><span class="line">            <span class="number">3&#x27;d4</span>: data &lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="number">3&#x27;d5</span>: data &lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">default</span>: data &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-vl4-2"><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> sequence_generator(</span><br><span class="line">	<span class="keyword">input</span> clk,</span><br><span class="line">	<span class="keyword">input</span> rst_n,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> data</span><br><span class="line">	);</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">5</span>:<span class="number">0</span>] data_reg;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data_reg &lt;= <span class="number">6&#x27;b001011</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            data_reg &lt;= &#123;data_reg[<span class="number">4</span>:<span class="number">0</span>], data_reg[<span class="number">5</span>]&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            data &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            data &lt;= data_reg[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-vl4-3"></div></div></div>

<h3 id="VL5-并串转换-（有待复习）"><a href="#VL5-并串转换-（有待复习）" class="headerlink" title="VL5 并串转换 （有待复习）"></a>VL5 并串转换 （有待复习）</h3><div class="tabs" id="tab-vl5"><ul class="nav-tabs"><li class="tab"><a href="#tab-vl5-1">状态机</a></li><li class="tab"><a href="#tab-vl5-2">移位思想</a></li><li class="tab"><a href="#tab-vl5-3">折叠表格</a></li></ul><div class="tab-content"><div class="tab-pane" id="tab-vl5-1"><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> huawei5(</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> clk  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> rst  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>]d ,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> valid_in ,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> dout</span><br><span class="line">	);</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">    <span class="comment">//state machine</span></span><br><span class="line">    <span class="comment">//set state</span></span><br><span class="line">    <span class="keyword">localparam</span> IDLE = <span class="number">0</span>, S1 = <span class="number">1</span>, SOut = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] state, next;</span><br><span class="line">    <span class="comment">//counter</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst)</span><br><span class="line">            cnt &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">3</span>)</span><br><span class="line">            cnt &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cnt &lt;= cnt + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//state transition</span></span><br><span class="line">    <span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(state)</span><br><span class="line">            IDLE: next = (cnt == <span class="number">3</span>) ? S1: IDLE;</span><br><span class="line">            S1: next = SOut;</span><br><span class="line">            SOut: next = (cnt == <span class="number">3</span>) ? S1: SOut;</span><br><span class="line">            <span class="keyword">default</span>: next = IDLE;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//data reg</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] d_temp;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst)</span><br><span class="line">            d_temp &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(next == S1)</span><br><span class="line">            d_temp &lt;= d;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//state flip-flops</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst)</span><br><span class="line">            state &lt;= IDLE;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            state &lt;= next;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            valid_in &lt;= <span class="number">0</span>;</span><br><span class="line">            dout &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">case</span>(next)</span><br><span class="line">            S1: <span class="keyword">begin</span></span><br><span class="line">                valid_in &lt;= <span class="number">1</span>;</span><br><span class="line">                dout &lt;= d[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            SOut: <span class="keyword">begin</span></span><br><span class="line">                valid_in &lt;= <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">case</span>(cnt)</span><br><span class="line">                    <span class="number">2&#x27;d0</span>: dout &lt;= d_temp[<span class="number">2</span>];</span><br><span class="line">                    <span class="number">2&#x27;d1</span>: dout &lt;= d_temp[<span class="number">1</span>];</span><br><span class="line">                    <span class="number">2&#x27;d2</span>: dout &lt;= d_temp[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">default</span>: dout &lt;= <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                valid_in &lt;= <span class="number">0</span>;</span><br><span class="line">                dout &lt;= <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-vl5-2"><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> huawei5(</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> clk  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> rst  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>]d ,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span> valid_in ,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span> dout</span><br><span class="line">	);</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">    <span class="comment">//counter</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst)</span><br><span class="line">            cnt &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">3</span>)</span><br><span class="line">            cnt &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cnt &lt;= cnt + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//data reg</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] d_temp;</span><br><span class="line">    <span class="keyword">reg</span> valid;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            d_temp &lt;= <span class="number">0</span>;</span><br><span class="line">            valid &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">3</span>) <span class="keyword">begin</span></span><br><span class="line">            d_temp &lt;= d[<span class="number">3</span>:<span class="number">0</span>];</span><br><span class="line">            valid &lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            d_temp &lt;= d_temp&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            valid &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">assign</span> dout = d_temp[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">assign</span> valid_in = valid;</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-vl5-3"></div></div></div>

<h3 id="VL6-时钟切换-（有待复习）"><a href="#VL6-时钟切换-（有待复习）" class="headerlink" title="VL6 时钟切换 （有待复习）"></a>VL6 时钟切换 （有待复习）</h3><blockquote>
<p> 题目中说了是两个同步的倍频时钟clk0 clk1,已知clk0是clk1的二倍频，属于相关时钟，避免切换时毛刺出现，只需要在组合逻辑的基础上添加下降沿触发的DFF 。</p>
</blockquote>
<details class="note info no-icon"><summary><p>code</p>
</summary>
<p>答案貌似有问题，代码后附上仿真图像</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> test_2(</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> clk0  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> clk1  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> rst  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> sel ,		<span class="comment">//sel==0时，输出为clk0；sel==1时，输出为clk1</span></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> clk_out</span><br><span class="line">);</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">	<span class="keyword">reg</span> q0, q1;		<span class="comment">//q0表示目前输出为clk0，q1表示目前输出为clk1</span></span><br><span class="line">	<span class="comment">//为了避免毛刺，当clk0和clk1都为低电平的时候切换</span></span><br><span class="line">	<span class="comment">//由clk0下降沿触发，确保q0跳变时clk0处于低电平</span></span><br><span class="line">    <span class="comment">//如果当前输出为clk0，sel变化后，直到clk0下降沿后q0才会跳变至0</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">negedge</span> clk0 <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~rst)</span><br><span class="line">			q0 &lt;= <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			q0 &lt;= ~sel &amp; ~q1;		<span class="comment">//sel为0并且输出不为clk1时，输出clk0</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">//由clk1下降沿触发，确保q1跳变时clk1处于低电平</span></span><br><span class="line">    <span class="comment">//如果当前输出为clk1，sel变化后，直到clk1下降沿后q1才会跳变至0</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">negedge</span> clk1 <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~rst)</span><br><span class="line">			q1 &lt;= <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			q1 &lt;= sel &amp; ~q0;		<span class="comment">//sel为1并且输出不为clk0时，输出clk1</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">		clk_out &lt;= (q0 &amp; clk0) | (q1 &amp; clk1);</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>

<p>testbench:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ps/1ps </span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> clk0_period 20</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> clk1_period 40</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> test_2_tb();</span><br><span class="line">	<span class="keyword">reg</span> clk0, clk1;</span><br><span class="line">	<span class="keyword">reg</span> rst;</span><br><span class="line">	<span class="keyword">reg</span> sel;</span><br><span class="line">	<span class="keyword">wire</span> clk_out;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">initial</span> clk0 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">always</span> <span class="variable">#(`clk0_period/2)</span> clk0 = ~clk0;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">initial</span> clk1 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">always</span> <span class="variable">#(`clk1_period/2)</span> clk1 = ~clk1;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] myRandom0, myRandom1;</span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		rst = <span class="number">0</span>;</span><br><span class="line">		sel = <span class="number">0</span>;</span><br><span class="line">		#<span class="number">5</span> rst = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">repeat</span>(<span class="number">50</span>) <span class="keyword">begin</span></span><br><span class="line">			myRandom0 = &#123;<span class="built_in">$random</span>&#125;%<span class="number">1000</span>;</span><br><span class="line">			myRandom1 = &#123;<span class="built_in">$random</span>&#125;%<span class="number">1000</span>;</span><br><span class="line">			sel = <span class="number">0</span>; #myRandom0;</span><br><span class="line">			sel = <span class="number">1</span>; #myRandom1;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		#<span class="number">200</span> <span class="built_in">$stop</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	test_2 u1(</span><br><span class="line">		<span class="variable">.clk0</span>(clk0), </span><br><span class="line">		<span class="variable">.clk1</span>(clk1), </span><br><span class="line">		<span class="variable">.rst</span>(rst), </span><br><span class="line">		<span class="variable">.sel</span>(sel), </span><br><span class="line">		<span class="variable">.clk_out</span>(clk_out)</span><br><span class="line">	);</span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>

<img src="/2022/05/02/nowcoder/nowcoder3-verilog2/1651485529249.png" class="" width="1651485529249">

</details>

<h3 id="VL7-状态机与时钟分频"><a href="#VL7-状态机与时钟分频" class="headerlink" title="VL7 状态机与时钟分频"></a>VL7 状态机与时钟分频</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> huawei7(</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> clk  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> rst  ,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> clk_out</span><br><span class="line">);</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">    <span class="comment">//set state</span></span><br><span class="line">    <span class="keyword">localparam</span> A = <span class="number">0</span>, B = <span class="number">1</span>, C = <span class="number">2</span>, D = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] state, next;</span><br><span class="line">    <span class="comment">//state transition</span></span><br><span class="line">    <span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(state)</span><br><span class="line">            A: next = B;</span><br><span class="line">            B: next = C;</span><br><span class="line">            C: next = D;</span><br><span class="line">            D: next = A;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//state flip-flops</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst)</span><br><span class="line">            state &lt;= A;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            state &lt;= next;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst)</span><br><span class="line">            clk_out &lt;= A;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">case</span>(next)</span><br><span class="line">            A: clk_out &lt;= <span class="number">0</span>;</span><br><span class="line">            B: clk_out &lt;= <span class="number">1</span>;</span><br><span class="line">            C: clk_out &lt;= <span class="number">0</span>;</span><br><span class="line">            D: clk_out &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL8-超前进位加法器"><a href="#VL8-超前进位加法器" class="headerlink" title="VL8 超前进位加法器"></a>VL8 超前进位加法器</h3> <img src="/2022/05/02/nowcoder/nowcoder3-verilog2/7DECCD52BCEE8E159E872D9DC158B9E8.png" class="" title="img"> 

<p>故可令<code>Gi = Ai &amp; Bi; Pi = Ai | Bi</code>，则<code>Ci+1 = Gi | Pi &amp; Ci</code></p>
<details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> huawei8<span class="comment">//四位超前进位加法器</span></span><br><span class="line">(</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>]A,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>]B,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span> [<span class="number">4</span>:<span class="number">0</span>]OUT</span><br><span class="line">);</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] P, G;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">4</span>:<span class="number">1</span>] Ci;</span><br><span class="line">    Add1 u0(<span class="variable">.a</span>(A[<span class="number">0</span>]), <span class="variable">.b</span>(B[<span class="number">0</span>]), <span class="variable">.C_in</span>(<span class="number">1&#x27;b0</span>), <span class="variable">.f</span>(OUT[<span class="number">0</span>]), <span class="variable">.p</span>(P[<span class="number">0</span>]), <span class="variable">.g</span>(G[<span class="number">0</span>]));</span><br><span class="line">    Add1 u1(<span class="variable">.a</span>(A[<span class="number">1</span>]), <span class="variable">.b</span>(B[<span class="number">1</span>]), <span class="variable">.C_in</span>(Ci[<span class="number">1</span>]), <span class="variable">.f</span>(OUT[<span class="number">1</span>]), <span class="variable">.p</span>(P[<span class="number">1</span>]), <span class="variable">.g</span>(G[<span class="number">1</span>]));</span><br><span class="line">    Add1 u2(<span class="variable">.a</span>(A[<span class="number">2</span>]), <span class="variable">.b</span>(B[<span class="number">2</span>]), <span class="variable">.C_in</span>(Ci[<span class="number">2</span>]), <span class="variable">.f</span>(OUT[<span class="number">2</span>]), <span class="variable">.p</span>(P[<span class="number">2</span>]), <span class="variable">.g</span>(G[<span class="number">2</span>]));</span><br><span class="line">    Add1 u3(<span class="variable">.a</span>(A[<span class="number">3</span>]), <span class="variable">.b</span>(B[<span class="number">3</span>]), <span class="variable">.C_in</span>(Ci[<span class="number">3</span>]), <span class="variable">.f</span>(OUT[<span class="number">3</span>]), <span class="variable">.p</span>(P[<span class="number">3</span>]), <span class="variable">.g</span>(G[<span class="number">3</span>]));</span><br><span class="line">    CLA_4 mod_0(<span class="variable">.P</span>(P), <span class="variable">.G</span>(G), <span class="variable">.C_in</span>(<span class="number">1&#x27;b0</span>), <span class="variable">.Ci</span>(Ci));</span><br><span class="line">    <span class="keyword">assign</span> OUT[<span class="number">4</span>] = Ci[<span class="number">4</span>];</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="comment">//////////////下面是两个子模块////////</span></span><br><span class="line"><span class="keyword">module</span> Add1</span><br><span class="line">(</span><br><span class="line">		<span class="keyword">input</span> a,</span><br><span class="line">		<span class="keyword">input</span> b,</span><br><span class="line">		<span class="keyword">input</span> C_in,</span><br><span class="line">		<span class="keyword">output</span> f,</span><br><span class="line">		<span class="keyword">output</span> g,</span><br><span class="line">		<span class="keyword">output</span> p</span><br><span class="line">		);</span><br><span class="line">    <span class="keyword">assign</span> g = a &amp; b;</span><br><span class="line">    <span class="keyword">assign</span> p = a | b;        </span><br><span class="line">    <span class="keyword">assign</span> f = a ^ b ^ C_in;    <span class="comment">//加法结果</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="comment">//超前进位</span></span><br><span class="line"><span class="keyword">module</span> CLA_4(</span><br><span class="line">		<span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>]P,</span><br><span class="line">		<span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>]G,</span><br><span class="line">		<span class="keyword">input</span> C_in,</span><br><span class="line">		<span class="keyword">output</span> [<span class="number">4</span>:<span class="number">1</span>]Ci</span><br><span class="line">	);</span><br><span class="line">    <span class="keyword">assign</span> Ci[<span class="number">1</span>] = G[<span class="number">0</span>] | P[<span class="number">0</span>] &amp; C_in;</span><br><span class="line">    <span class="keyword">assign</span> Ci[<span class="number">2</span>] = G[<span class="number">1</span>] | P[<span class="number">1</span>] &amp; Ci[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">assign</span> Ci[<span class="number">3</span>] = G[<span class="number">2</span>] | P[<span class="number">2</span>] &amp; Ci[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">assign</span> Ci[<span class="number">4</span>] = G[<span class="number">3</span>] | P[<span class="number">3</span>] &amp; Ci[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL11-脉冲同步器（快到慢）"><a href="#VL11-脉冲同步器（快到慢）" class="headerlink" title="VL11 脉冲同步器（快到慢）"></a>VL11 脉冲同步器（快到慢）</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 100ps/100ps</span></span><br><span class="line"><span class="keyword">module</span> pulse_detect(</span><br><span class="line">	<span class="keyword">input</span> 				clka	,    <span class="comment">//300M T = 3.33ns</span></span><br><span class="line">	<span class="keyword">input</span> 				clkb	,    <span class="comment">//100M T = 10 ns</span></span><br><span class="line">	<span class="keyword">input</span> 				rst_n		,</span><br><span class="line">	<span class="keyword">input</span>				sig_a		,</span><br><span class="line"></span><br><span class="line">	<span class="keyword">output</span>  		 	sig_b</span><br><span class="line">);</span><br><span class="line">    <span class="comment">//利用电平翻转保存脉冲信号</span></span><br><span class="line">    <span class="keyword">reg</span> sig_level;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clka <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            sig_level &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sig_a)</span><br><span class="line">            sig_level &lt;= ~sig_level;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//将clka同步到clkb时域</span></span><br><span class="line">    <span class="keyword">reg</span> sig_temp1, sig_temp2, sig_temp3;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clkb <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            sig_temp1 &lt;= <span class="number">0</span>;</span><br><span class="line">            sig_temp2 &lt;= <span class="number">0</span>;</span><br><span class="line">            sig_temp3 &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            sig_temp1 &lt;= sig_level;</span><br><span class="line">            sig_temp2 &lt;= sig_temp1;</span><br><span class="line">            sig_temp3 &lt;= sig_temp2;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">assign</span> sig_b = sig_temp3 ^ sig_temp2;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL12-序列检测器（Moore型）"><a href="#VL12-序列检测器（Moore型）" class="headerlink" title="VL12 序列检测器（Moore型）"></a>VL12 序列检测器（Moore型）</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<p>个人觉得三段式状态机输出应该由next态决定，否则输出会晚一个周期，但是答案波形要求检测state来得到输出。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> det_moore(</span><br><span class="line">   <span class="keyword">input</span>                clk   ,</span><br><span class="line">   <span class="keyword">input</span>                rst_n ,</span><br><span class="line">   <span class="keyword">input</span>                din   ,</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">output</span>	<span class="keyword">reg</span>         Y   </span><br><span class="line">);</span><br><span class="line">    <span class="comment">//state machine</span></span><br><span class="line">    <span class="comment">//set state</span></span><br><span class="line">    <span class="keyword">localparam</span> IDLE = <span class="number">0</span>, S1 = <span class="number">1</span>, S11 = <span class="number">2</span>, S110 = <span class="number">3</span>, S1101 = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] state, next;</span><br><span class="line">    <span class="comment">//state transition(combinational)</span></span><br><span class="line">    <span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(state)</span><br><span class="line">            IDLE: next = din ? S1 : IDLE;</span><br><span class="line">            S1: next = din ? S11 : IDLE;</span><br><span class="line">            S11: next = din ? S11 : S110;</span><br><span class="line">            S110: next = din ? S1101 : IDLE;</span><br><span class="line">            S1101: next = din ? S1 : IDLE;</span><br><span class="line">            <span class="keyword">default</span>: next = IDLE;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//state flip-flops(sequential)</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) </span><br><span class="line">            state &lt;= IDLE;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            state &lt;= next;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            Y &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">case</span>(state)</span><br><span class="line">            S1101: Y &lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">default</span>: Y &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="VL13-乘法与位运算"><a href="#VL13-乘法与位运算" class="headerlink" title="VL13 乘法与位运算"></a>VL13 乘法与位运算</h3><p>利用移位进行2的整数倍乘法，可以节省资源占用</p>
<details class="note info no-icon"><summary><p>code</p>
</summary>
<p>因为题目要求B &#x3D; A * 8’b1111_1011，而8’b1111_1011中1多0少，利用减法所耗资源会更少</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> dajiang13(</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>]    A,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>]   B</span><br><span class="line">	);</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">    <span class="keyword">assign</span> B = (A &lt;&lt; <span class="number">8</span>) - (A &lt;&lt; <span class="number">2</span>) - A;	<span class="comment">//8&#x27;b1111_1011 = 9&#x27;b1_0000_0000 - 3&#x27;b100 - 1&#x27;b1</span></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>资源占用如下</p>
<img src="/2022/05/02/nowcoder/nowcoder3-verilog2/1651637317640.png" class="" width="1651637317640">

<p>对照组：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> B = A * <span class="number">8&#x27;b1111_1011</span>;</span><br></pre></td></tr></table></figure>

<img src="/2022/05/02/nowcoder/nowcoder3-verilog2/1651637432951.png" class="" width="1651637432951">

<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> B = (A &lt;&lt; <span class="number">7</span>) + (A &lt;&lt; <span class="number">6</span>) + (A &lt;&lt; <span class="number">5</span>) + (A &lt;&lt; <span class="number">4</span>) + (A &lt;&lt; <span class="number">3</span>) + (A &lt;&lt; <span class="number">1</span>) + A;</span><br></pre></td></tr></table></figure>

<img src="/2022/05/02/nowcoder/nowcoder3-verilog2/1651637639832.png" class="" width="1651637639832">

</details>

<h3 id="VL16-异步复位同步释放-（有待复习）"><a href="#VL16-异步复位同步释放-（有待复习）" class="headerlink" title="VL16 异步复位同步释放 （有待复习）"></a>VL16 异步复位同步释放 （有待复习）</h3><p>同步复位</p>
<p><code>always@(posedge clk)</code> 复位信号只有在时钟上升沿到来时才能有效</p>
<p>优点：</p>
<ol>
<li>利于仿真器仿真；</li>
<li>可以滤除高于时钟频率的复位毛刺；</li>
<li>可以使系统称为100%的同步时序电路，有利于时序分析；</li>
</ol>
<p>缺点：</p>
<ol>
<li>复位信号必须大于一个时钟周期或刚好在触发边沿才能被识别；</li>
<li>由于大多数逻辑器件的目标库内的DFF都只有异步复位端口，使用同步复位综合器会额外插入组合逻辑，从而耗费较多的逻辑资源；</li>
</ol>
<p>异步复位：<code>always@(posedge clk or negedge rst_n)</code>复位信号有效时即刻进行复位</p>
<p>优点：</p>
<ol>
<li>设计简单；</li>
<li>大多数DFF都有异步复位端口，节省资源；</li>
<li>识别方便，并且可以很方便的使用FPGA的全局复位端口GSR；</li>
</ol>
<p>缺点：</p>
<ol>
<li>复位信号容易受毛刺影响；（可以对复位信号进行消抖处理）</li>
<li>复位信号释放时，若刚好处于时钟有效边沿附近，容易出现亚稳态；（可以采用异步复位，同步释放的方式来避免）</li>
</ol>
<p>一些问题可以点击<a href="https://blog.csdn.net/wordwarwordwar/article/details/79889725">参考</a>。</p>
<details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> ali16(</span><br><span class="line"><span class="keyword">input</span> clk,</span><br><span class="line"><span class="keyword">input</span> rst_n,</span><br><span class="line"><span class="keyword">input</span> d,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> dout</span><br><span class="line"> );</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">    <span class="comment">//将异步复位信号同步到该时钟域中</span></span><br><span class="line">    <span class="keyword">reg</span> rst_n_temp1, rst_n_temp2;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            rst_n_temp1 &lt;= <span class="number">0</span>;</span><br><span class="line">            rst_n_temp2 &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            rst_n_temp1 &lt;= <span class="number">1</span>;</span><br><span class="line">            rst_n_temp2 &lt;= rst_n_temp1;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//输入同步处理后的异步复位信号</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n_temp2) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n_temp2)</span><br><span class="line">            dout &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            dout &lt;= d;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>得到的波形如图：</p>
<img src="/2022/05/02/nowcoder/nowcoder3-verilog2/1651646358117.png" class="" width="1651646358117">

<p>即异步复位信号输入时即刻生效，但当输入的异步复位信号释放后，对于系统来说要经过2个时钟周期后才会真正释放。</p>

</details>

<h3 id="VL19-编写乘法器求解算法表达式"><a href="#VL19-编写乘法器求解算法表达式" class="headerlink" title="VL19 编写乘法器求解算法表达式"></a>VL19 编写乘法器求解算法表达式</h3><details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> calculation(</span><br><span class="line">	<span class="keyword">input</span> clk,</span><br><span class="line">	<span class="keyword">input</span> rst_n,</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] a,</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] b,</span><br><span class="line">	<span class="keyword">output</span> [<span class="number">8</span>:<span class="number">0</span>] c</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] temp1, temp2;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            temp1 &lt;= <span class="number">0</span>;</span><br><span class="line">            temp2 &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            temp1 &lt;= &#123;a, <span class="number">3&#x27;b000</span>&#125; + &#123;a, <span class="number">2&#x27;b00</span>&#125;;</span><br><span class="line">            temp2 &lt;= &#123;b, <span class="number">2&#x27;b00</span>&#125; + b;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">8</span>:<span class="number">0</span>] c_temp;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)</span><br><span class="line">            c_temp &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            c_temp &lt;= temp1 + temp2;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">assign</span> c = c_temp;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</details>





<details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

</details>]]></content>
      <tags>
        <tag>Verilog</tag>
      </tags>
  </entry>
</search>
