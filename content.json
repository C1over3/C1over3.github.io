{"meta":{"title":"Clover's blog","subtitle":"迷途的旅人，这里并没有你所寻找的东西","description":"似乎还未到境界...","author":"Clover","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2022-04-22T10:43:37.000Z","updated":"2022-04-22T10:44:44.598Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"似乎是还未到境界…"},{"title":"标签","date":"2022-04-22T10:44:58.000Z","updated":"2022-04-29T02:44:19.378Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-04-22T10:45:19.000Z","updated":"2022-04-29T02:44:39.885Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"C++笔记（十二）——函数（二）","slug":"cpp/cpp-note-12","date":"2022-05-09T04:16:01.000Z","updated":"2022-05-09T05:55:09.772Z","comments":true,"path":"2022/05/09/cpp/cpp-note-12/","link":"","permalink":"http://example.com/2022/05/09/cpp/cpp-note-12/","excerpt":"重载函数如果同一作用域内的几个函数名字相同但形参列表不同（形参数量或类型有所不同），称之为重载(overloaded)函数： 123void print(const char *cp);void print(const int *beg, const int *end);void print(const int ia[], size_t size); 编译器会根据实参类型推断想要的是哪个函数 注意： 不允许两个函数除了返回类型外，其他所有要素（包括函数名在内）都相同； 一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开； 如果形参是指针或引用，可以通过底层const区分； const_cast和重载对于： 123const string &amp;shorterString(const string &amp;s1, const string &amp;s2)&#123; return s1.size() &lt;= s2.size() ? s1 : s2;&#125; 返回的结果仍然是const string的引用，可以重载一个新的函数，当实参不是常量时，返回一个普通引用：","text":"重载函数如果同一作用域内的几个函数名字相同但形参列表不同（形参数量或类型有所不同），称之为重载(overloaded)函数： 123void print(const char *cp);void print(const int *beg, const int *end);void print(const int ia[], size_t size); 编译器会根据实参类型推断想要的是哪个函数 注意： 不允许两个函数除了返回类型外，其他所有要素（包括函数名在内）都相同； 一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开； 如果形参是指针或引用，可以通过底层const区分； const_cast和重载对于： 123const string &amp;shorterString(const string &amp;s1, const string &amp;s2)&#123; return s1.size() &lt;= s2.size() ? s1 : s2;&#125; 返回的结果仍然是const string的引用，可以重载一个新的函数，当实参不是常量时，返回一个普通引用： 1234string &amp;shorterString(string &amp;s1, string &amp;s2)&#123; auto &amp;r = shorterString(const_cast&lt;const string&amp;&gt;(s1), const_cast&lt;const string&amp;&gt;(s2)); return const_cast&lt;string&amp;&gt;(r);&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++笔记（十一）——函数（一）","slug":"cpp/cpp-note-11","date":"2022-05-08T07:47:54.000Z","updated":"2022-05-09T04:16:46.765Z","comments":true,"path":"2022/05/08/cpp/cpp-note-11/","link":"","permalink":"http://example.com/2022/05/08/cpp/cpp-note-11/","excerpt":"函数(function)C++中允许重载函数，也就是几个不同的函数可以使用同一个名字，程序员需要清楚地知道编译器如何从函数的若干重载形式中选取一个与调用匹配的版本。 函数基础一个典型的函数定义包括一下部分：返回类型、函数名字、由0个或多个形参(parameter)组成的列表以及函数体： 123456int fact(int val)&#123; int ret = 1; while(val &gt; 1) ret *= val--; return ret;&#125; 调用函数： 12345int main() &#123; int j = fact(5); cout &lt;&lt; &quot;5! is &quot; &lt;&lt; j &lt;&lt; endl; return 0;&#125; 函数的调用完成两项工作：一是用实参初始化函数对应的形参；二是将控制权转移给被调函数，此时主调函数(calling function)的执行被暂时中断，被调函数(called function)开始执行。 当遇到一条return时函数结束执行过程。和调用一样，return也完成两项工作：一是返回return语句中的值（如果有的话）；二是将控制权返还给主调函数 局部静态对象","text":"函数(function)C++中允许重载函数，也就是几个不同的函数可以使用同一个名字，程序员需要清楚地知道编译器如何从函数的若干重载形式中选取一个与调用匹配的版本。 函数基础一个典型的函数定义包括一下部分：返回类型、函数名字、由0个或多个形参(parameter)组成的列表以及函数体： 123456int fact(int val)&#123; int ret = 1; while(val &gt; 1) ret *= val--; return ret;&#125; 调用函数： 12345int main() &#123; int j = fact(5); cout &lt;&lt; &quot;5! is &quot; &lt;&lt; j &lt;&lt; endl; return 0;&#125; 函数的调用完成两项工作：一是用实参初始化函数对应的形参；二是将控制权转移给被调函数，此时主调函数(calling function)的执行被暂时中断，被调函数(called function)开始执行。 当遇到一条return时函数结束执行过程。和调用一样，return也完成两项工作：一是返回return语句中的值（如果有的话）；二是将控制权返还给主调函数 局部静态对象特点： 该变量在全局数据区分配内存； 在程序执行到该对象的声明处时被首次初始化，此后的函数调用不再对其进行初始化； 如果没有显式初始化，会被程序自动初始化为0； 始终驻留在全局数据区，直到程序运行结束，但其作用域仅为局部作用域（仅在定义它的函数或语句块中）； 可以用于记录函数被调用的次数等。 参数传递如果形参是引用类型，它将绑定到对应的实参上，称实参被引用传递(passed by reference)或者函数被传引用调用(called by reference)；否则，将实参的值拷贝后赋给形参，称实参被值传递(passed by value)或者称函数被传值调用(called by value)。 传值参数使用值形参，函数中对形参做的所有操作都不会影响到实参 指针形参1234void reset(int *ip)&#123; *ip = 0; //改变了形参ip所指对象的值，但此时形参与实参指针指向同一个对象，故实参所指对象也被改变 ip = 0; //仅改变形参，实参指针对象未被改变&#125; C++中，建议使用引用类型的形参替代指针（编译器会把引用解释为常量指针，或者说机器码层面引用等价于常量指针）。 传引用参数使用引用形参，允许函数改变一个或多个实参的值 使用引用避免拷贝拷贝大的类类型对象或容器对象比较低效，而且有的类（包括IO类型）根本不支持拷贝操作，如果函数无须改变引用形参的值，最好将其声明为对常量的引用。 使用引用形参返回额外信息一个函数只能返回一个值，让函数返回更多的信息，可以： 使用引用形参，在函数中改变引用形参的值； 将函数返回值设定为自定义的类，类在定义中可以封装多个属性； const形参和实参形参的初始化过程与变量的初始化过程一样，在初始化时，形参的顶层const会被忽略，即可以用非常量初始化const形参： 12int i = 0;void fcn(const int i) &#123; /*fcn可以读取i，但不可以向i写值*/ &#125; //初始化正确 复习初始化规则： 可以用非常量初始化顶层const对象； 可以用非常量初始化一个底层const对象，但不能用底层const对象初始化一个非常量对象； 一个普通的引用必须用同类型的对象初始化； 注意：定义形参时，尽量使用常量引用而不是普通引用，否则①会对函数使用者造成误导：②不能传递const对象、字面值、需要类型转换的对象（会产生临时变量，临时变量不可改变）；③其他拥有常量引用形参的函数中无法正常使用该函数。 数组形参 数组不能被拷贝，因此无法以值传递的方式使用数组参数；数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针： 1234//以下三个print函数等价void print (const int*);void print (const int[]);void print (const int[10]); //这里的维度表示我们期望数组含有多少元素，但实际不一定 编译器在处理时，只会检查传入的参数是否是const int类型的，而不会考虑其是否指向一个数组，但对于多维数组，*只有第一维长度不检查，其他维度的长度必须与形参一致： 123//以两个print函数等价void print(int matrix[][10], int rowSize)&#123; /*...*/ &#125;void print(int (*matrix)[10], int rowSize)&#123; /*...*/ &#125; //*matrix两端的()不可去掉 确定数组长度任何使用数组的代码，必须确保不会越界，大致有三种方法： 使用标记指定数组长度（常用于C风格字符串，以\\0为标记）； 向函数传递数组首元素和尾后元素的指针（受标准库技术启发而来）； 1234void print(const int *beg, const int *end)&#123; while(beg != end) cout &lt;&lt; *beg++ &lt;&lt;endl;&#125; 显式传递一个表示数组大小的形参； 1234void print (const int ia[], size_t size)&#123; for(size_t = 0; i != size; ++i) cout &lt;&lt; ia[i] &lt;&lt; endl;&#125; 数组引用形参C++允许将变量定义成数组的引用，同样形参也可以是数组的引用： 1234void print(int (&amp;arr)[10])&#123; //此处不能写成 &amp;arr[10]，它表示引用的数组（C++不允许定义引用的数组），与原意相悖 for(auto elem : arr) cout &lt;&lt; elem &lt;&lt;endl;&#125; 练习6.22 12345void exchange_pointer(int* (&amp;px), int* (&amp;py)) &#123; //对指针的引用（从里向外，从右到左） auto temp = px; px = py; py = temp;&#125; main:处理命令行选项有时我们需要向main函数传递实参，常用于设置一组选项来确定函数所要执行的操作。例如，假设main函数位于可执行文件prog之内，我们可以如此向程序传递下面的选项： 1prog -d -o ofile data0 这些命令行选项通过两个（可选的）形参传递给main函数： 1int main(int argc, char *argv[]) &#123;...&#125; 其中argc表示数组中字符串的数量，argv是一个数组，它的元素是指向C风格字符串的指针（即指针数组）。当使用argv中的实参时，一定要记得可选实参从argv[1]开始，因为argv[0]保存程序的名字，而非用户输入。 练习6.25、6.26 123456789int main(int argc, char** argv) &#123; string s; for (int i = 1; i != argc; ++i) &#123; s += argv[i]; s += &quot; &quot;; &#125; cout &lt;&lt; s &lt;&lt; endl; return 0;&#125; VS2022可以在本地调试器中设置命令参数： 含有可变形参的函数有时我们无法预知应该想函数传递几个实参，例如我们想要编写代码输出程序产生的错误信息，此时最好用同一个函数实现该功能，以便对所有错误的处理能够整齐划一。 C++11新标准提供了两种主要的方法： 若所有实参类型相同，可以传递一个名为initializer_list的标准库类型； 若不同，可以利用可变参数模板编写一种特殊的函数； initializer_list形参和vector一样，initializer_list也是一种模板类型，定义时必须说明列表中所含元素的类型： 12initializer_list&lt;string&gt; ls;initializer_list&lt;int&gt; li; 与vector不同的是，initializer_list对象中的元素永远是常量值。 作用于未知数量实参的函数： 12345void error_msg(initializer_list&lt;string&gt; i1) &#123; for (auto beg = i1.begin(); beg != i1.end(); ++beg) cout &lt;&lt; *beg &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125; 调用： 1234if (expected != actual) error_msg(&#123; &quot;functionX&quot;, expected, actual &#125;); else error_msg(&#123; &quot;functionX&quot;, &quot;okay&quot; &#125;); //通过&#123;&#125;为initializer_list形参中传递一个序列 省略符形参仅仅用于C和C++通用的类型，大多数类类型的对象在传递给省略符形参时都无法正确拷贝，形式如下： 12void foo(parm_list, ...);void foo(...); 练习6.27 1234567int sumation(initializer_list&lt;int&gt; ini1) &#123; int sum = 0; for (auto c : ini1) &#123; sum += c; &#125; return sum;&#125; 返回类型和return语句两种形式： 12return ; //返回一个空语句，只能用在返回类型是void的函数中，void函数最后一句后面会隐式地执行returnreturn /*expression*/; 返回类型是void的函数也能用第二种形式的return，但其expression必须是另一个返回void的函数。 值是如何被返回的返回一个值的方式和初始化一个变量或形参的范式完全一样：返回的值在调用点产生一个临时量，该临时量就是函数调用的结果。 C++11新标准规定，函数可以返回花括号包围的值的列表，即用花括号列表来对临时量进行初始化。 不要返回局部对象的引用或指针函数完成后，它所占用的内存空间随之被释放，局部变量的引用或指针将指向不在有效的内存区域： 1234567const string &amp;manip()&#123; //表示返回值是对string常量的引用 string ret; if(!ret.empty()) return ret; //错误：返回局部对象的引用 else return &quot;Empty&quot;; //错误：&quot;Empty&quot;是一个局部临时变量&#125; 可以返回对实参的引用： 123const string &amp;shorterString(const string &amp;s1, const string &amp;s2)&#123; return s1.size() &lt;= s2.size() ? s1 : s2; //s1，s2都是对实参的引用，不会产生临时量&#125; 返回类类型的函数如果函数返回指针、引用或类的对象，我们可以使用函数调用的结果访问结果对象的成员： 1auto sz = shorterString(s1, s2).size(); 引用返回左值这意味着可以为返回类型是非常量引用的函数的结果赋值 递归函数调用自己： 12345int factorial(int val)&#123; if(val &gt; 1) return factorial(val - 1) * val; return 1;&#125; 注意： 至少有一条路径不包含递归调用，否则会无限递归直至程序栈空间耗尽； main函数不能调用自己； 练习6.33 1234567void Get_vector_val(vector&lt;int&gt; ivec, size_t size) &#123; if (size != 0) &#123; cout &lt;&lt; ivec[ivec.size() - size] &lt;&lt; &quot; &quot;; Get_vector_val(ivec, size - 1); &#125; return;&#125; 返回数组指针最直接的方法是使用类型别名： 123typedef int arrT[10]; //arrT是一个类型别名，它表示的类型是含有10个整数的数组using arrT = int[10]; //C++11新标准下arrT的等价声明arrT* func(int i); //func返回一个指向含有10个整数的数组的指针 不使用类型别名： 1int (*func(int i))[10]; //形参列表必须紧靠着函数名，表示调用func函数时需要一个int类型的实参 C++11新标准中使用尾置返回类型(trailing return type)： 1auto func(int i) -&gt; int(*)[10]; 如果提前知道函数返回值将指向哪个数组，可以使用decltype： 12345int odd[] = &#123;1,3,5,7,9&#125;;int even[] = &#123;0,2,4,6,8&#125;;decltype(odd) *arrPtr(int i)&#123; return (i % 2) ? &amp;odd : &amp;even;&#125; 注意：int mat1[][10]和int (*mat2) [10]是等价的，但是int **mat3与它们不等价，因为++mat1和++mat2都表示指向下一个数组，地址移动了10个int元素，即40个字节；而++mat3只移动了1个int元素，即4个字节。 练习6.33 12345678string (&amp;func1(int i))[10]&#123;&#125; //直接声明auto func2(int i)-&gt;string(&amp;)[10] &#123;&#125; //尾置返回类型decltype(s) &amp;func3(int i)&#123;&#125; //decltypeusing arrStr = string[10]; //类型别名arrStr &amp;func4(int i)&#123;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++笔记（十）——语句","slug":"cpp/cpp-note-10","date":"2022-05-07T05:52:13.000Z","updated":"2022-05-08T07:46:15.291Z","comments":true,"path":"2022/05/07/cpp/cpp-note-10/","link":"","permalink":"http://example.com/2022/05/07/cpp/cpp-note-10/","excerpt":"语句和绝大多是语言一样，C++提供条件执行语句、重复执行相同代码的循环语句和用于中断当前控制流的跳转语句。 简单语句在一个语法上需要而逻辑上不需要语句的地方会用到空语句 ; 在一个语法上只需要一条语句而逻辑上需要多条语句的地方会用到块&#123; /*many statements*/ &#125;，一个块就是一个作用域，块的后面不需要分号。 语句作用域在if、switch、while、和for语句中的控制结构内定义的变量，其作用域仅在相应语句的内部 条件语句练习5.5 123456789101112131415161718192021vector&lt;string&gt; svec = &#123; &quot;E&quot;, &quot;D&quot;, &quot;C&quot;, &quot;B&quot;,&quot;A&quot;,&quot;A++&quot; &#125;;int grade = 0;string lettergrade;while (cin &gt;&gt; grade &amp;&amp; grade &lt;= 100 &amp;&amp; grade &gt;= 0) &#123; cout &lt;&lt; endl; int temp = grade / 10, temp2 = grade % 10; //temp表示分数百十位，temp2表示个位 if (temp &lt; 6) cout &lt;&lt; svec[0] &lt;&lt; endl; else &#123; if (temp &gt;= 5 &amp;&amp; temp &lt; svec.size() + 5) cout &lt;&lt; svec[temp - 5]; if (temp != 10) &#123; if (temp2 &gt; 7) cout &lt;&lt; &quot;+&quot;; if (temp2 &lt; 3) cout &lt;&lt; &quot;-&quot;; &#125; cout &lt;&lt; endl; &#125;&#125;","text":"语句和绝大多是语言一样，C++提供条件执行语句、重复执行相同代码的循环语句和用于中断当前控制流的跳转语句。 简单语句在一个语法上需要而逻辑上不需要语句的地方会用到空语句 ; 在一个语法上只需要一条语句而逻辑上需要多条语句的地方会用到块&#123; /*many statements*/ &#125;，一个块就是一个作用域，块的后面不需要分号。 语句作用域在if、switch、while、和for语句中的控制结构内定义的变量，其作用域仅在相应语句的内部 条件语句练习5.5 123456789101112131415161718192021vector&lt;string&gt; svec = &#123; &quot;E&quot;, &quot;D&quot;, &quot;C&quot;, &quot;B&quot;,&quot;A&quot;,&quot;A++&quot; &#125;;int grade = 0;string lettergrade;while (cin &gt;&gt; grade &amp;&amp; grade &lt;= 100 &amp;&amp; grade &gt;= 0) &#123; cout &lt;&lt; endl; int temp = grade / 10, temp2 = grade % 10; //temp表示分数百十位，temp2表示个位 if (temp &lt; 6) cout &lt;&lt; svec[0] &lt;&lt; endl; else &#123; if (temp &gt;= 5 &amp;&amp; temp &lt; svec.size() + 5) cout &lt;&lt; svec[temp - 5]; if (temp != 10) &#123; if (temp2 &gt; 7) cout &lt;&lt; &quot;+&quot;; if (temp2 &lt; 3) cout &lt;&lt; &quot;-&quot;; &#125; cout &lt;&lt; endl; &#125;&#125; switch语句如果表达式和某个case标签的值匹配成功，程序从该标签之后的第一条语句开始执行，**直到到达了switch的结尾或者是遇到一条break语句为止**： 1234567891011121314151617181920212223unsigned aCnt = 0, eCnt = 0, iCnt = 0, oCnt = 0, uCnt = 0;char ch;while (cin &gt;&gt; ch) &#123; switch (ch) &#123; case &#x27;a&#x27;: ++aCnt; break; //当输入为a时，如果没有这条break，程序还会执行后面的 ++eCnt; case &#x27;e&#x27;: ++eCnt; break; case &#x27;i&#x27;: ++iCnt; break; case &#x27;o&#x27;: ++oCnt; break; case &#x27;u&#x27;: ++uCnt; break; default: //即使default什么也不做，也最好加上default，表示已经考虑了default break; &#125;&#125; 如统计a、e、i、o、u的总数： 12345678int vowelCnt = 0;switch(ch)&#123; case&#x27;a&#x27;: case&#x27;e&#x27;: case&#x27;i&#x27;: case&#x27;o&#x27;: case&#x27;u&#x27;: ++vowelCnt; break; default: break; //即使在switch语句的结尾，也最好加上一句 break;&#125; switch内部的变量定义初始化操作和定义变量对于编译器来说是两码事，初始化操作（包括隐式初始化，例如string s;，和显示初始化，列如int i = 0;）是程序运行时才会被调用的语句，可能被case跳转屏蔽掉；而定义则是在编译时就完成检查，不能跳过分配空间。 C++不允许使用未初始化的变量，为了防止switch语句中发生这种情况，C++规定不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置： 12345678case true: string file_name; //错误：控制流绕过一个隐式初始化的变量（编译器会告诉你这是不合法的） int ival = 0; //错误：控制流绕过一个显式初始化的变量（编译器会告诉你这是不合法的） int jval; //正确：在作用域内定义jval break;case false: jval = next_num(); //正确：jval在作用域内有定义，此处给jval赋一个值 if(file_name.empty()) //file_name在作用域内，但没有被初始化 迭代语句练习5.14 123456789101112131415161718192021222324252627282930string input, temp;vector&lt;string&gt; svec;int cnt = 0;int max = 0;if (cin &gt;&gt; input) &#123; ++cnt; while (cin &gt;&gt; temp) &#123; if (input == temp) &#123; ++cnt; if (cnt &gt; max) &#123; svec = &#123;&#125;; max = cnt; svec.push_back(input); &#125; else if (cnt == max) &#123; svec.push_back(input); &#125; &#125; else&#123; cnt = 1; input = temp; &#125; &#125;&#125;if (max &gt; 1)&#123; for (auto&amp; c : svec) cout &lt;&lt; c &lt;&lt; &quot;出现了&quot; &lt;&lt; max &lt;&lt; &quot;次&quot; &lt;&lt; endl;&#125;else cout &lt;&lt; &quot;没有连续出现的单词&quot; &lt;&lt; endl; 练习5.17 1234567891011vector&lt;int&gt; ivec1&#123; 0,1,1,2,3,5,8, 0, 99, 3 &#125;, ivec2&#123; 0,1,1,2,3,5,8 &#125;;int small_size = (ivec1.size() &gt; ivec2.size()) ? ivec2.size() : ivec1.size();cout &lt;&lt; ((ivec1.size() &gt; ivec2.size()) ? &quot;ivec2&quot; : &quot;ivec1&quot;);for (int i = 0; i != small_size; ++i) &#123; if (ivec1[i] != ivec2[i]) &#123; cout &lt;&lt; &quot;不是&quot; &lt;&lt; ((ivec1.size() &gt; ivec2.size()) ? &quot;ivec1&quot; : &quot;ivec2&quot;) &lt;&lt; &quot;的前缀&quot; &lt;&lt; endl; return 0; &#125;&#125;cout &lt;&lt; &quot;是&quot; &lt;&lt; ((ivec1.size() &gt; ivec2.size()) ? &quot;ivec1&quot; : &quot;ivec2&quot;) &lt;&lt; &quot;的前缀&quot; &lt;&lt; endl;return 0; 范围for语句12345for(auto &amp;c : v)&#123;/*statements*/&#125; //来源于下述传统for语句，其中v是一个vector&lt;int&gt;对象for(auto beg = v.begin(), end = v.end(); beg != end; ++beg)&#123; auto &amp;r = *beg; /*statements*/&#125; do while语句condition使用的变量必须定义在循环体之外，先执行语句或块，后判断条件，不允许在条件部分定义变量，而且至少执行一次： 123do /*statements*/while (/*condition*/); //注意这里有一个分号表示语句结束 练习5.19 123456789101112string s1, s2;do &#123; cout &lt;&lt; &quot;Please input two strings: &quot; &lt;&lt; endl; cin &gt;&gt; s1; cin &gt;&gt; s2; if (s1.size() == s2.size()) cout &lt;&lt; &quot;Size of s1 is equal to size of s2.&quot; &lt;&lt; endl; else if (s1.size() &lt; s2.size()) cout &lt;&lt; s1 &lt;&lt; endl; else cout &lt;&lt; s2 &lt;&lt; endl;&#125; while (cin); 跳转语句break语句负责终止离它最近的迭代语句或者switch语句，只能出现在迭代语句或者switch语句内部 continue语句用于终止最近的循环中的当前迭代并立即开始下一次迭代，对于传统for，继续执行for语句头中的expression goto语句 作用是从goto语句无条件跳转到同一函数内的另一条语句 ，如： 12345&#123; goto end; /*statements*/ end: ;&#125; 与switch类似，goto不能绕过一个带初始化的变量定义，但可以从带初始化的变量定义之后跳回到之前，如： 12345begin: int sz = get_size(); if(sz &lt;= 0)&#123; goto begin; //此时goto执行后会先销毁sz，然后再重新执行sz的定义并初始化 &#125; try语句块和异常处理当程序的某部分检测到一个它无法处理的问题时，需要用到异常处理。异常处理机制由程序中异常检测和异常处理两部分协作提供支持，其中异常检测部分只负责发出异常信号，无须知道故障将在何处解决；异常处理部分负责处理问题。 throw表达式异常检测部分使用throw引发一个异常或者说抛出一个异常： 12if(item1.isbn() != item2.isbn()) throw runtime_error(&quot;Data must refer to same ISBN&quot;); //该异常是类型runtime_error的对象 runtime_error是标准库异常类型的一种，定义在stdexcept头文件中，我们必须初始化runtime_error对象，方式是给他提供一个string对象或者C风格字符串，如上文中的”Data must refer to same ISBN” 。 try语句块在try块之后是一个或多个catch子句： 1234567try&#123; /*program-statements*/&#125; catch (/*exception-declaration*/)&#123; //()中是一个异常声明 /*handler-statements*/&#125; catch (/*exception-declaration*/)&#123; /*handler-statements*/&#125; // ... 当选中了某个catch子句处理异常之后，执行与之对应的块： 12345678910111213141516Sales_item item1, item2;while (cin &gt;&gt; item1 &gt;&gt; item2) &#123; try &#123; if (item1.isbn() != item2.isbn()) &#123; throw runtime_error(&quot;Data must refer to same ISBN&quot;); &#125; cout &lt;&lt; item1 + item2 &lt;&lt; endl; &#125; catch (runtime_error err) &#123; cout &lt;&lt; err.what() &lt;&lt; &quot;\\nTry Again ? Enter y or n&quot; &lt;&lt; endl; char c; cin &gt;&gt; c; if (!cin || c == &#x27;n&#x27;) break; &#125;&#125; catch完成后，程序将跳转到try语句块最后一个catch子句之后的那条语句继续执行。复杂系统中，一个try语句块①可能调用了包含另一个try语句块②的函数，try语句块②可能调用了包含try语句块③的函数，以此类推。 寻找处理代码的过程则是先从try语句块③中寻找匹配的catch子句，若没有，则再从try语句块②中寻找，以此类推。如果最终没有找到任何匹配的子句，则程序转到名为terminate的标准库函数，一般情况下，执行该函数将导致程序非正常退出。 标准异常C++标准库定义了一组类，用于报告标准库函数遇到的问题，exception头文件定义了最通用的异常类exception；stdexcept头文件定义了集中常用的异常类；new头文件定义了bad_alloc异常类型；type_info头文件定义了bad_cast异常类型。 练习5.25 try语句块至少要设定一个catch子句，否则编译器会报错 1234567891011121314151617int i1, i2;do &#123; cout &lt;&lt; &quot;请输入两个整数用于除法运算，第一个为被除数，第二个为除数：&quot; &lt;&lt; endl; cin &gt;&gt; i1 &gt;&gt; i2; try&#123; if (i2 == 0) throw runtime_error(&quot;除数不可以为0！&quot;); cout &lt;&lt; static_cast&lt;double&gt;(i1) / i2 &lt;&lt; endl; &#125; catch (runtime_error err) &#123; cout &lt;&lt; err.what() &lt;&lt; &quot;\\nTry again？ Enter y or n&quot; &lt;&lt; endl; char c; cin &gt;&gt; c; if (!cin || c == &#x27;n&#x27;) break; &#125;&#125; while (cin);","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++笔记（九）——表达式","slug":"cpp/cpp-note-9","date":"2022-05-06T13:43:32.000Z","updated":"2022-05-07T05:51:48.012Z","comments":true,"path":"2022/05/06/cpp/cpp-note-9/","link":"","permalink":"http://example.com/2022/05/06/cpp/cpp-note-9/","excerpt":"表达式C++提供了一套丰富的运算符，并定义了这些运算符作用域内置类型的运算对象时所执行的操作。同时，当运算对象是类类型时，C++也允许用户自定义上述运算符的含义。 左值和右值当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。 对于关键字decltype()，如果()中是表达式（不是变量），且表达式的结果是一个左值，比如*p（*是解引用运算符，p是一个指针，它们组合起来构成一个表达式，表达式的结果是p所指对象i），decltype将得到一个引用类型。 算术运算符关于布尔值布尔值不不应该参与运算的原因： 12bool b = true;bool b2 = -b; //b2是true！ 当 - 运算符作用于布尔类型的对象时，先把它提升为int类型（大多数运算符都是这样）。b的值为真，参与运算时将被提升为整数1，求负后结果为-1。而-1不等于0，转换回布尔值后应该为1。","text":"表达式C++提供了一套丰富的运算符，并定义了这些运算符作用域内置类型的运算对象时所执行的操作。同时，当运算对象是类类型时，C++也允许用户自定义上述运算符的含义。 左值和右值当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。 对于关键字decltype()，如果()中是表达式（不是变量），且表达式的结果是一个左值，比如*p（*是解引用运算符，p是一个指针，它们组合起来构成一个表达式，表达式的结果是p所指对象i），decltype将得到一个引用类型。 算术运算符关于布尔值布尔值不不应该参与运算的原因： 12bool b = true;bool b2 = -b; //b2是true！ 当 - 运算符作用于布尔类型的对象时，先把它提升为int类型（大多数运算符都是这样）。b的值为真，参与运算时将被提升为整数1，求负后结果为-1。而-1不等于0，转换回布尔值后应该为1。 除法运算在C++11新标准中，整型除法的商一律向0取整（即直接切除小数部分）；取余运算符的运算对象必须是整型，m%n的结果符号只取决于被除数m，与n无关。 12321 % -5; /*结果是1*/ 21 / -5; /*结果是-4*/-21 % -5; /*结果是-1*/ -21 / -5; /*结果是4*/-21 % 5; /*结果是-1*/ -21 / 5; /*结果是-4*/ 赋值运算符赋值运算符满足右结合律： 1234int ival, jval;ival = jval = 0; //正确：ival和jval都被赋值为0int* pval;ival = pval = 0; //错误：虽然可以把0赋值给pval，但是int*类型无法转换为int，即pval无法赋值给ival 递增递减运算符只能用于左值运算对象，有前置和后置两种版本，前值版本将对象本身作为左值返回，后置版本将对象原始值的副本作为右值返回。 123int i = 0, j = 0;j = ++i; //此时j = 1, i = 1：前置版本得到递增之后的值j = i++; //此时j = 1, j = 2：后置版本得到递增之前的值 建议：除非必须，否则不用递增递减运算符的后置版本，前置版本不需要存储原始值，节省了资源。 在这种情况下，常用后置版本以保证简洁： 1cout &lt;&lt; *iter++ &lt;&lt;endl; //等价于*(iter++)，由于后置版本返回值为原始值，故这条语句将指针向前移动一个位置，并输出iter之前指向的那个元素 运算对象可按任意顺序求值： 12while(beg != s.end() &amp;&amp; !isspace(*beg)) *beg = toupper(*beg++); //错误：该赋值语句未定义 在赋值运算符左右的运算对象都用到了beg，并且右侧还改变了beg的值，无法确定左侧的beg是递增前的beg还是beg + 1（都有可能发生，由编译器决定） 注意：C++中只有4中运算符明确规定了运算对象的求值顺序，分别是逻辑与（&amp;&amp;）、逻辑或（||）、条件（? :）、逗号（,） 成员访问函数点运算符（.）和箭头运算符（-&gt;）都可用于访问成员： 1234string s1 = &quot;a string&quot;, *p = &amp;s1;auto n = s1.size();n = (*p).size();n = p -&gt; size(); //等价于 n = (*p).size(); 类型转换可以大致分为隐式转换和显式转换 隐式转换以算术转换为主，还包括数组转换成指针、指针转换成布尔类型、指针转换成常量、类类型定义的转换（如cin转换成布尔值）等 显示转换一个命名的强制类型转换具有如下形式： 1cast-name&lt;type&gt;(expression); 其中cast-name是static_cast、dynamic_cast、const_cast、reinterpret_cast中的一种，如： 12int i = 5, j = 2;double slope = static_cast&lt;double&gt;(j) / i; static_cast可以用于找回存在于void*指针中的值： 123int i = 42;void* p_void = &amp;i;cout &lt;&lt; *(static_cast&lt;int*&gt;(p_void)) &lt;&lt; endl; //输出结果为42 const_castconst_cast只能改变运算对象的const属性（去掉const），不能改变表达式类型： 12345int k = 100;const int* pk = &amp;k;int* pk2 = pk; //错误：const int*类型不能用于初始化int*类型int* pk3 = const_cast&lt;int*&gt;(pk); //正确double* pk4 = const_cast&lt;double*&gt;(pk); //错误：const_cast不能改变表达式类型 注意：如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为；但如果对象是一个常量，再使用const_cast执行写操作会产生未定义（由编译器决定，不同编译器结果不一样）的后果。 reinterpret_castreinterpret_cast通常为运算对象的位模式提供了较低层次上的重新解释，使用它非常危险（尽量不要用）： 12int *ip;char *pc = reinterpret_cast&lt;char*&gt;(ip); //pc所指的真实对象是一个int而非字符，编译器通过重新解释ip而把ip赋值给了pc 练习4.37 12345int i; double d; const string* ps; char* pc; void* pv;pv = const_cast&lt;string*&gt;(ps);i = static_cast&lt;int&gt;(*pc);pv = static_cast&lt;void*&gt;(&amp;d);pc = static_cast&lt;char*&gt;(pv);","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++笔记（八）——数组","slug":"cpp/cpp-note-8","date":"2022-05-05T05:45:55.000Z","updated":"2022-05-06T13:43:02.959Z","comments":true,"path":"2022/05/05/cpp/cpp-note-8/","link":"","permalink":"http://example.com/2022/05/05/cpp/cpp-note-8/","excerpt":"数组数组是一种类似于vector的数据结构，但其大小是固定的，不能随意增加。 定义和初始化内置数组对于数组a[d]，a是数组名，d是数组维度，**数组的最后一个元素是a[d-1]**。编译的时候维度应该是已知的，故d必须是一个常量表达式。 列表初始化时，如果数组维度大于所给的初始值数量，剩下的元素被初始化为默认值；列表初始化时，允许忽略数组维度，编译器会根据初始值推测维度： 123456const unsigned sz = 3;int al[sz] = &#123;0, 1, 2&#125;;int a2[] = &#123;0, 1, 2&#125;; //维度是3int a3[5] = &#123;0, 1, 2&#125;; //维度是5，等价于int a3[] = &#123;0, 1, 2, 0, 0&#125;;string a4[3] = &#123;&quot;hi&quot;, &quot;bye&quot;, &quot;&quot;&#125;; //等价于 string a4[] = &#123;&quot;hi&quot;, &quot;bye&quot;, &quot;&quot;&#125;;int a5[2] = &#123;0, 1, 2&#125;; //错误：初始值过多 对于字符数组，可以用字符串字面值对其进行初始化，但需要注意字符串结尾有一个空字符： 123char a1[] = &#123;&#x27;C&#x27;, &#x27;+&#x27;, &#x27;+&#x27;&#125;; //维度为3，不含空字符char a1[] = &#123;&#x27;C&#x27;, &#x27;+&#x27;, &#x27;+&#x27;, &#x27;\\0&#x27;&#125;; //维度为4，含有显式空字符char a1[] = &quot;C++&quot;; //维度为4，含有隐式空字符 不允许拷贝和赋值： 1234int a[] = &#123;0, 1, 2&#125;;int a2[] = a; //错误：不能用一个数组初始化另一个数组int a3[3] = &#123;0&#125;;a3 = a; //错误：不能把一个数组直接赋值给另一个数组","text":"数组数组是一种类似于vector的数据结构，但其大小是固定的，不能随意增加。 定义和初始化内置数组对于数组a[d]，a是数组名，d是数组维度，**数组的最后一个元素是a[d-1]**。编译的时候维度应该是已知的，故d必须是一个常量表达式。 列表初始化时，如果数组维度大于所给的初始值数量，剩下的元素被初始化为默认值；列表初始化时，允许忽略数组维度，编译器会根据初始值推测维度： 123456const unsigned sz = 3;int al[sz] = &#123;0, 1, 2&#125;;int a2[] = &#123;0, 1, 2&#125;; //维度是3int a3[5] = &#123;0, 1, 2&#125;; //维度是5，等价于int a3[] = &#123;0, 1, 2, 0, 0&#125;;string a4[3] = &#123;&quot;hi&quot;, &quot;bye&quot;, &quot;&quot;&#125;; //等价于 string a4[] = &#123;&quot;hi&quot;, &quot;bye&quot;, &quot;&quot;&#125;;int a5[2] = &#123;0, 1, 2&#125;; //错误：初始值过多 对于字符数组，可以用字符串字面值对其进行初始化，但需要注意字符串结尾有一个空字符： 123char a1[] = &#123;&#x27;C&#x27;, &#x27;+&#x27;, &#x27;+&#x27;&#125;; //维度为3，不含空字符char a1[] = &#123;&#x27;C&#x27;, &#x27;+&#x27;, &#x27;+&#x27;, &#x27;\\0&#x27;&#125;; //维度为4，含有显式空字符char a1[] = &quot;C++&quot;; //维度为4，含有隐式空字符 不允许拷贝和赋值： 1234int a[] = &#123;0, 1, 2&#125;;int a2[] = a; //错误：不能用一个数组初始化另一个数组int a3[3] = &#123;0&#125;;a3 = a; //错误：不能把一个数组直接赋值给另一个数组 指针和引用（先由内向外，再从右到左）： 1234int *ptrs[10]; //ptrs是含有10个整型指针的数组int &amp;refs[10]; //错误：引用不是对象，不存在引用的数组int (*Parray)[10] = &amp;arr; //Parray指向一个含有10个整数的数组int (&amp;arrRef)[10] = arr; //arrRef引用一个含有10个整数的数组 数组和指针数组的特效：在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针： 123string s[] = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;;string *p = s; //等价于string *p = &amp;s[0];auto s1 = s; //s1是一个指针，指向s的第一个元素，等价于 auto c = &amp;s[0]; 但decltype关键字有所不同： 12//s2是一个含有3个string的数组decltype(s) s2 = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;; 指向数组的指针支持迭代器所支持的所有运算： 123int arr[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;int *p = arr; //p指向arr的第一个元素，即arr[0]++p; //p指向arr[1] C++中可以设法获取数组尾元素后的那个并不存在的元素的地址： 1int *e = &amp;arr[10]; //e指向arr尾元素的下一个位置 这时，我们可以对数组进行遍历操作： 12for(int *b = arr; b != e; ++b) cout &lt;&lt; *b &lt;&lt; endl; C++11新标准中引入了begin和end函数来获取指向数组第一个元素的指针和指向数组尾元素下一位置的指针（注意，这两个函数的返回值都是指针）： 123int a1[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;int *beg = begin(a1);int *last = end(a2); //指向a1尾元素的下一位置 特别注意，尾后指针与尾后迭代器类似，不能执行解引用和递增操作。 与迭代器相同，两个指针相减得到它们之间的距离，其结果类型为ptrdiff_t，可以为负值： 1auto n = end(a1) - begin(a1); //n的值是10，也就是a1中元素的数量 只要指针指向的是数组中的元素，我们就可以对其进行下标运算： 12int *p = &amp;a1[2];int j = p[1]; //结果为j = a1[3]，等价于 int j = *(p + 1); 注意，标准库类型的下标运算必须是无符号类型，但内置的下标运算可以处理负值，比如此处可以令j = p[-1];，结果即是j &#x3D; a1[1] 。 练习3.39 code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; //比较两个string string s1, s2; cin &gt;&gt; s1 &gt;&gt; s2; if (s1 == s2) cout &lt;&lt; &quot;equal&quot; &lt;&lt; endl; else if (s1 &gt; s2) cout &lt;&lt; s1 &lt;&lt; &quot; &gt; &quot; &lt;&lt; s2 &lt;&lt; endl; else cout &lt;&lt; s1 &lt;&lt; &quot; &lt; &quot; &lt;&lt; s2 &lt;&lt; endl; //比较两个C风格字符串，利用for循环遍历 char ca1[] = &#123; &quot;A string example&quot; &#125;; char ca2[] = &#123; &quot;A string example&quot; &#125;; unsigned len1 = sizeof(ca1); unsigned len2 = sizeof(ca2); if (len1 == len2) &#123; for (int i = 0; i != len1; ++i) &#123; if (ca1[i] &gt; ca1[i]) &#123; cout &lt;&lt; ca1 &lt;&lt; &quot; &gt; &quot; &lt;&lt; ca2 &lt;&lt; endl; return 0; &#125; else if (ca1[i] &lt; ca1[i]) &#123; cout &lt;&lt; ca1 &lt;&lt; &quot; &lt; &quot; &lt;&lt; ca2 &lt;&lt; endl; return 0; &#125; &#125; cout &lt;&lt; ca1 &lt;&lt; &quot; = &quot; &lt;&lt; ca2 &lt;&lt; endl; &#125; else if (len1 &gt; len2) cout &lt;&lt; ca1 &lt;&lt; &quot; &gt; &quot; &lt;&lt; ca2 &lt;&lt; endl; else cout &lt;&lt; ca1 &lt;&lt; &quot; &lt; &quot; &lt;&lt; ca2 &lt;&lt; endl; //比较两个C风格字符串，调用strcmp()函数 char ca3[] = &#123; &quot;A string example&quot; &#125;; char ca4[] = &#123; &quot;A string example&quot; &#125;; if(strcmp(ca3, ca4) == 0) cout &lt;&lt; ca3 &lt;&lt; &quot; = &quot; &lt;&lt; ca4 &lt;&lt; endl; else if (strcmp(ca3, ca4) &gt; 0) cout &lt;&lt; ca3 &lt;&lt; &quot; &gt; &quot; &lt;&lt; ca4 &lt;&lt; endl; else cout &lt;&lt; ca3 &lt;&lt; &quot; &lt; &quot; &lt;&lt; ca4 &lt;&lt; endl; return 0;&#125; 练习3.40 1234567891011121314#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; char a[100] = &#123; &quot;How are &quot; &#125;, b[100] = &#123; &quot;you ?&quot; &#125;; char c[100] = &#123;&#125;; strcpy_s(c, a); //等价于strcpy函数 strcat_s(c, b); //等价于strcat函数 for (auto i : c) cout &lt;&lt; i; cout &lt;&lt; endl; return 0;&#125; 由于strcpy和strcat函数没有内部检查，微软担心可能造成栈溢出，在新版本的VS中改写了这些函数，并在名字后面加上_s来作为区分。 与旧代码的接口允许用C风格字符串（即已空字符结束的字符数组）来为string对象赋值，反之不可； 允许在string对象的加法运算中使用C风格字符串作为其中一个运算对象（不能两个都是）； 可以通过c_str()函数来为C风格字符串赋值（其返回值是一个指向const C风格字符串的指针），如： 123string s(&quot;Hello world&quot;);char *str = s; //错误：不能用string对象初始化char*const char *str = s.c_str(); //正确 注意，如果后续操作改变了s的值，s.c_str()可能会发生变化（指针存放的地址发生改变），而str不会跟着变化（指针存放的地址未改变，但原本的对象不再存放在该地址，str成了野指针），这样之前返回的数组就失去了效用。 允许使用数组来初始化vector，如： 123int int_arr[] = &#123;0,1,2,3,4,5&#125;;vector&lt;int&gt; ivec1(begin(int_arr), end(int_arr)); //指明拷贝区域的地址范围vector&lt;int&gt; ivec2(int_arr + 1, int_arr + 4); //ivec2只包含int_arr中下标为1，2，3的三个元素 多维数组严格来说，C++语言中没有多维数组，通常所说的多位数组其实是数组的数组。 练习3.43 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; int ia[3][4] = &#123; &#123;0,1,2,3&#125;, &#123;4,5,6,7&#125;, &#123;8,9,10,11&#125; &#125;; //利用范围for循环(不使用auto) for (int (&amp;d1)[4] : ia) &#123; for (int&amp; d2 : d1) cout &lt;&lt; d2 &lt;&lt; &#x27; &#x27;; &#125; //使用auto for (auto&amp; d1 : ia) &#123; for (auto&amp; d2 : d1) cout &lt;&lt; d2 &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; endl; //利用下标运算符 for (int i = 0; i != 3; ++i) &#123; for (int j = 0; j != 4; ++j) &#123; cout &lt;&lt; ia[i][j] &lt;&lt; &#x27; &#x27;; &#125; &#125; cout &lt;&lt; endl; //利用指针（不使用auto） for (int(*p1)[4] = ia; p1 != ia + 3; ++p1) &#123; for (int* p2 = *p1; p2 != *p1 + 4; ++(p2)) &#123; cout &lt;&lt; *p2 &lt;&lt; &#x27; &#x27;; &#125; &#125; //使用auto //这里的p1是int (*p1)[4]类型，其所指对象为一个含有4个元素的整型数组（该数组是数组的数组的首元素） for (auto p1 = ia; p1 != ia + 3; ++p1) &#123; //这里的p2是 int *p2类型，其所指对象为一个整数（该整数是整型数组的首元素） for (auto p2 = *p1; p2 != *p1 + 4; ++(p2)) &#123; cout &lt;&lt; *p2 &lt;&lt; &#x27; &#x27;; &#125; &#125; return 0;&#125; 练习3.44 利用类型别名 1234567891011121314151617181920212223int ia[3][4] = &#123; &#123;0,1,2,3&#125;, &#123;4,5,6,7&#125;, &#123;8,9,10,11&#125;&#125;;using int_arr1 = int[4]; //C++11新标准typedef int int_arr2[4]; //注意与上一条语句的区别，其中int_arr1和int_arr2类型相同for (int_arr2 &amp;d1 : ia) &#123; for (int&amp; d2 : d1) cout &lt;&lt; d2 &lt;&lt; &#x27; &#x27;;&#125;cout &lt;&lt; endl;for (int i = 0; i != 3; ++i) &#123; for (int j = 0; j != 4; ++j) &#123; cout &lt;&lt; ia[i][j] &lt;&lt; &#x27; &#x27;; &#125;&#125;cout &lt;&lt; endl;for (int_arr1 * p1 = ia; p1 != ia + 3; ++p1) &#123; for (int* p2 = *p1; p2 != *p1 + 4; ++(p2)) &#123; cout &lt;&lt; *p2 &lt;&lt; &#x27; &#x27;; &#125;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"学习FPGA过程中遇到的一些问题","slug":"FPGA/FPGA-note","date":"2022-05-03T05:06:56.000Z","updated":"2022-05-03T05:43:30.469Z","comments":true,"path":"2022/05/03/FPGA/FPGA-note/","link":"","permalink":"http://example.com/2022/05/03/FPGA/FPGA-note/","excerpt":"quartus门级仿真出错在确认verilog代码没有问题，testbench代码没有问题，RTL级仿真正常后，门级仿真中许多信号都出现了红线（此时testbench中时间单位为1 ns）： （没有图了，我没办法复现出错的波形了，我也不知道我改了什么了，怎么这么玄学？！） 原因可能是在testbench中设定的时间单位太小，导致在门级仿真的延迟时间内，信号就已经发生了变化，即激励信号维持的时间没有大于触发器的建立时间和保持时间与逻辑门的延迟时间之和。 下面是将testbench中时间单位改成1 ms后的波形： 放大可以看出： 上图中第二行为clk信号，可以看出，触发器从接受时钟上升沿直到变化成下一个稳态经过了约9ns左右。","text":"quartus门级仿真出错在确认verilog代码没有问题，testbench代码没有问题，RTL级仿真正常后，门级仿真中许多信号都出现了红线（此时testbench中时间单位为1 ns）： （没有图了，我没办法复现出错的波形了，我也不知道我改了什么了，怎么这么玄学？！） 原因可能是在testbench中设定的时间单位太小，导致在门级仿真的延迟时间内，信号就已经发生了变化，即激励信号维持的时间没有大于触发器的建立时间和保持时间与逻辑门的延迟时间之和。 下面是将testbench中时间单位改成1 ms后的波形： 放大可以看出： 上图中第二行为clk信号，可以看出，触发器从接受时钟上升沿直到变化成下一个稳态经过了约9ns左右。","categories":[],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"http://example.com/tags/FPGA/"}]},{"title":"牛客网Verilog刷题笔记3——企业真题","slug":"nowcoder/nowcoder3-verilog2","date":"2022-05-02T04:13:54.000Z","updated":"2022-05-04T15:30:07.055Z","comments":true,"path":"2022/05/02/nowcoder/nowcoder3-verilog2/","link":"","permalink":"http://example.com/2022/05/02/nowcoder/nowcoder3-verilog2/","excerpt":"VL2 使用握手信号实现跨时钟域数据传输 （有待复习）code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394`timescale 1ns/1nsmodule data_driver( input clk_a, input rst_n, input data_ack, output reg [3:0]data, output reg data_req ); //counter reg [2:0] cnt; always@(posedge clk_a or negedge rst_n) begin if(~rst_n) cnt &lt;= 0; else if(!data_req) begin if(cnt == 4) cnt &lt;= 0; else cnt &lt;= cnt + 1&#x27;b1; end else cnt &lt;= 0; end //output 0-7 always@(posedge clk_a or negedge rst_n) begin if(~rst_n) data &lt;= 0; else if(data_ack_temp1 &amp; ~data_ack_temp2) begin if(data == 7) data &lt;= 0; else data &lt;= data + 1&#x27;b1; end end //synchronize data_ack reg data_ack_temp1, data_ack_temp2; always@(posedge clk_a or negedge rst_n) begin if(~rst_n) begin data_ack_temp1 &lt;= 0; data_ack_temp2 &lt;= 0; end else begin data_ack_temp1 &lt;= data_ack; data_ack_temp2 &lt;= data_ack_temp1; end end always@(posedge clk_a or negedge rst_n) begin if(~rst_n) begin data_ack_temp1 &lt;= 0; data_ack_temp2 &lt;= 0; end else begin data_ack_temp1 &lt;= data_ack; data_ack_temp2 &lt;= data_ack_temp1; end end //output data_req always@(posedge clk_a or negedge rst_n) begin if(~rst_n) data_req &lt;= 0; else if(cnt == 4) data_req &lt;= 1; else if(data_ack_temp1 &amp; ~data_ack_temp2) data_req &lt;= 0; endendmodulemodule data_receiver(clk_b, rst_n, data, data_req, data_ack); input clk_b; input rst_n; input [3:0] data; input data_req; output reg data_ack; //synchronize data_ack reg data_req_temp1, data_req_temp2; always@(posedge clk_b or negedge rst_n) begin if(~rst_n) begin data_req_temp1 &lt;= 0; data_req_temp2 &lt;= 0; end else begin data_req_temp1 &lt;= data_req; data_req_temp2 &lt;= data_req_temp1; end end //output data_ack always@(posedge clk_b or negedge rst_n) begin if(~rst_n) data_ack &lt;= 0; else if(data_req_temp1 &amp; ~data_req_temp2) data_ack &lt;= 1; else data_ack &lt;= 0; endendmodule VL3 自动售卖机code 采用的是三段式Moore机 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091`timescale 1ns/1nsmodule sale( input clk , input rst_n , input sel ,//sel=0,5$dranks,sel=1,10&amp;=$drinks input [1:0] din ,//din=1,input 5$,din=2,input 10$ output reg [1:0] drinks_out,//drinks_out=1,output 5$ drinks,drinks_out=2,output 10$ drinks output reg change_out ); //state machine //set state localparam IDLE = 0, S005 = 1, S010 = 2, S105 = 3, S110 = 4, S115 = 5; reg [2:0] state, next; //state transition always@(*) begin case(state) IDLE: begin if(sel) case(din) 2&#x27;d1: next = S105; 2&#x27;d2: next = S110; default: next = IDLE; endcase else case(din) 2&#x27;d1: next = S005; 2&#x27;d2: next = S010; default: next = IDLE; endcase end S105: begin case(din) 2&#x27;d1: next = S110; 2&#x27;d2: next = S115; default: next = S105; endcase end default: begin //实现连续购买，即买完一次饮料后，不要回到IDLE态，而是继续响应下一次购买 if(sel) case(din) 2&#x27;d1: next = S105; 2&#x27;d2: next = S110; default: next = IDLE; endcase else case(din) 2&#x27;d1: next = S005; 2&#x27;d2: next = S010; default: next = IDLE; endcase end endcase end //state flip-flops always@(posedge clk or negedge rst_n) begin if(~rst_n) state &lt;= IDLE; else state &lt;= next; end //output always@(posedge clk or negedge rst_n) begin if(~rst_n) begin drinks_out &lt;= 0; change_out &lt;= 0; end else case(next) S005: begin drinks_out &lt;= 1; change_out &lt;= 0; end S010: begin drinks_out &lt;= 1; change_out &lt;= 1; end S110: begin drinks_out &lt;= 2; change_out &lt;= 0; end S115: begin drinks_out &lt;= 2; change_out &lt;= 1; end default: begin drinks_out &lt;= 0; change_out &lt;= 0; end endcase endendmodule VL4 序列发生器计数器移位寄存器折叠表格1234567891011121314151617181920212223242526272829`timescale 1ns/1nsmodule sequence_generator( input clk, input rst_n, output reg data ); reg [2:0] cnt; //输出序列为6位，故6进制计数 always@(posedge clk or negedge rst_n) begin if(~rst_n) cnt &lt;= 0; else if(cnt == 5) cnt &lt;= 0; else cnt &lt;= cnt + 1&#x27;b1; end always@(posedge clk or negedge rst_n) begin if(~rst_n) data &lt;= 0; else case(cnt) 3&#x27;d0: data &lt;= 0; 3&#x27;d1: data &lt;= 0; 3&#x27;d2: data &lt;= 1; 3&#x27;d3: data &lt;= 0; 3&#x27;d4: data &lt;= 1; 3&#x27;d5: data &lt;= 1; default: data &lt;= 0; endcase endendmodule1234567891011121314151617181920`timescale 1ns/1nsmodule sequence_generator( input clk, input rst_n, output reg data ); reg [5:0] data_reg; always@(posedge clk or negedge rst_n) begin if(~rst_n) data_reg &lt;= 6&#x27;b001011; else data_reg &lt;= &#123;data_reg[4:0], data_reg[5]&#125;; end always@(posedge clk or negedge rst_n) begin if(~rst_n) data &lt;= 0; else data &lt;= data_reg[5]; endendmodule VL5 并串转换 （有待复习）状态机移位思想折叠表格123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475`timescale 1ns/1nsmodule huawei5( input wire clk , input wire rst , input wire [3:0]d , output reg valid_in , output reg dout );//*************code***********// //state machine //set state localparam IDLE = 0, S1 = 1, SOut = 2; reg [1:0] state, next; //counter reg [1:0] cnt; always@(posedge clk or negedge rst) begin if(~rst) cnt &lt;= 0; else if(cnt == 3) cnt &lt;= 0; else cnt &lt;= cnt + 1; end //state transition always@(*) begin case(state) IDLE: next = (cnt == 3) ? S1: IDLE; S1: next = SOut; SOut: next = (cnt == 3) ? S1: SOut; default: next = IDLE; endcase end //data reg reg [3:0] d_temp; always@(posedge clk or negedge rst) begin if(~rst) d_temp &lt;= 0; else if(next == S1) d_temp &lt;= d; end //state flip-flops always@(posedge clk or negedge rst) begin if(~rst) state &lt;= IDLE; else state &lt;= next; end //output always@(posedge clk or negedge rst) begin if(~rst) begin valid_in &lt;= 0; dout &lt;= 0; end else case(next) S1: begin valid_in &lt;= 1; dout &lt;= d[3]; end SOut: begin valid_in &lt;= 0; case(cnt) 2&#x27;d0: dout &lt;= d_temp[2]; 2&#x27;d1: dout &lt;= d_temp[1]; 2&#x27;d2: dout &lt;= d_temp[0]; default: dout &lt;= 0; endcase end default: begin valid_in &lt;= 0; dout &lt;= 0; end endcase end//*************code***********//endmodule1234567891011121314151617181920212223242526272829303132333435363738394041`timescale 1ns/1nsmodule huawei5( input wire clk , input wire rst , input wire [3:0]d , output wire valid_in , output wire dout );//*************code***********// //counter reg [1:0] cnt; always@(posedge clk or negedge rst) begin if(~rst) cnt &lt;= 0; else if(cnt == 3) cnt &lt;= 0; else cnt &lt;= cnt + 1; end //data reg reg [3:0] d_temp; reg valid; always@(posedge clk or negedge rst) begin if(~rst) begin d_temp &lt;= 0; valid &lt;= 0; end else if(cnt == 3) begin d_temp &lt;= d[3:0]; valid &lt;= 1; end else begin d_temp &lt;= d_temp&lt;&lt;1; valid &lt;= 0; end end //output assign dout = d_temp[3]; assign valid_in = valid;//*************code***********//endmodule VL6 时钟切换 （有待复习） 题目中说了是两个同步的倍频时钟clk0 clk1,已知clk0是clk1的二倍频，属于相关时钟，避免切换时毛刺出现，只需要在组合逻辑的基础上添加下降沿触发的DFF 。","text":"VL2 使用握手信号实现跨时钟域数据传输 （有待复习）code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394`timescale 1ns/1nsmodule data_driver( input clk_a, input rst_n, input data_ack, output reg [3:0]data, output reg data_req ); //counter reg [2:0] cnt; always@(posedge clk_a or negedge rst_n) begin if(~rst_n) cnt &lt;= 0; else if(!data_req) begin if(cnt == 4) cnt &lt;= 0; else cnt &lt;= cnt + 1&#x27;b1; end else cnt &lt;= 0; end //output 0-7 always@(posedge clk_a or negedge rst_n) begin if(~rst_n) data &lt;= 0; else if(data_ack_temp1 &amp; ~data_ack_temp2) begin if(data == 7) data &lt;= 0; else data &lt;= data + 1&#x27;b1; end end //synchronize data_ack reg data_ack_temp1, data_ack_temp2; always@(posedge clk_a or negedge rst_n) begin if(~rst_n) begin data_ack_temp1 &lt;= 0; data_ack_temp2 &lt;= 0; end else begin data_ack_temp1 &lt;= data_ack; data_ack_temp2 &lt;= data_ack_temp1; end end always@(posedge clk_a or negedge rst_n) begin if(~rst_n) begin data_ack_temp1 &lt;= 0; data_ack_temp2 &lt;= 0; end else begin data_ack_temp1 &lt;= data_ack; data_ack_temp2 &lt;= data_ack_temp1; end end //output data_req always@(posedge clk_a or negedge rst_n) begin if(~rst_n) data_req &lt;= 0; else if(cnt == 4) data_req &lt;= 1; else if(data_ack_temp1 &amp; ~data_ack_temp2) data_req &lt;= 0; endendmodulemodule data_receiver(clk_b, rst_n, data, data_req, data_ack); input clk_b; input rst_n; input [3:0] data; input data_req; output reg data_ack; //synchronize data_ack reg data_req_temp1, data_req_temp2; always@(posedge clk_b or negedge rst_n) begin if(~rst_n) begin data_req_temp1 &lt;= 0; data_req_temp2 &lt;= 0; end else begin data_req_temp1 &lt;= data_req; data_req_temp2 &lt;= data_req_temp1; end end //output data_ack always@(posedge clk_b or negedge rst_n) begin if(~rst_n) data_ack &lt;= 0; else if(data_req_temp1 &amp; ~data_req_temp2) data_ack &lt;= 1; else data_ack &lt;= 0; endendmodule VL3 自动售卖机code 采用的是三段式Moore机 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091`timescale 1ns/1nsmodule sale( input clk , input rst_n , input sel ,//sel=0,5$dranks,sel=1,10&amp;=$drinks input [1:0] din ,//din=1,input 5$,din=2,input 10$ output reg [1:0] drinks_out,//drinks_out=1,output 5$ drinks,drinks_out=2,output 10$ drinks output reg change_out ); //state machine //set state localparam IDLE = 0, S005 = 1, S010 = 2, S105 = 3, S110 = 4, S115 = 5; reg [2:0] state, next; //state transition always@(*) begin case(state) IDLE: begin if(sel) case(din) 2&#x27;d1: next = S105; 2&#x27;d2: next = S110; default: next = IDLE; endcase else case(din) 2&#x27;d1: next = S005; 2&#x27;d2: next = S010; default: next = IDLE; endcase end S105: begin case(din) 2&#x27;d1: next = S110; 2&#x27;d2: next = S115; default: next = S105; endcase end default: begin //实现连续购买，即买完一次饮料后，不要回到IDLE态，而是继续响应下一次购买 if(sel) case(din) 2&#x27;d1: next = S105; 2&#x27;d2: next = S110; default: next = IDLE; endcase else case(din) 2&#x27;d1: next = S005; 2&#x27;d2: next = S010; default: next = IDLE; endcase end endcase end //state flip-flops always@(posedge clk or negedge rst_n) begin if(~rst_n) state &lt;= IDLE; else state &lt;= next; end //output always@(posedge clk or negedge rst_n) begin if(~rst_n) begin drinks_out &lt;= 0; change_out &lt;= 0; end else case(next) S005: begin drinks_out &lt;= 1; change_out &lt;= 0; end S010: begin drinks_out &lt;= 1; change_out &lt;= 1; end S110: begin drinks_out &lt;= 2; change_out &lt;= 0; end S115: begin drinks_out &lt;= 2; change_out &lt;= 1; end default: begin drinks_out &lt;= 0; change_out &lt;= 0; end endcase endendmodule VL4 序列发生器计数器移位寄存器折叠表格1234567891011121314151617181920212223242526272829`timescale 1ns/1nsmodule sequence_generator( input clk, input rst_n, output reg data ); reg [2:0] cnt; //输出序列为6位，故6进制计数 always@(posedge clk or negedge rst_n) begin if(~rst_n) cnt &lt;= 0; else if(cnt == 5) cnt &lt;= 0; else cnt &lt;= cnt + 1&#x27;b1; end always@(posedge clk or negedge rst_n) begin if(~rst_n) data &lt;= 0; else case(cnt) 3&#x27;d0: data &lt;= 0; 3&#x27;d1: data &lt;= 0; 3&#x27;d2: data &lt;= 1; 3&#x27;d3: data &lt;= 0; 3&#x27;d4: data &lt;= 1; 3&#x27;d5: data &lt;= 1; default: data &lt;= 0; endcase endendmodule1234567891011121314151617181920`timescale 1ns/1nsmodule sequence_generator( input clk, input rst_n, output reg data ); reg [5:0] data_reg; always@(posedge clk or negedge rst_n) begin if(~rst_n) data_reg &lt;= 6&#x27;b001011; else data_reg &lt;= &#123;data_reg[4:0], data_reg[5]&#125;; end always@(posedge clk or negedge rst_n) begin if(~rst_n) data &lt;= 0; else data &lt;= data_reg[5]; endendmodule VL5 并串转换 （有待复习）状态机移位思想折叠表格123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475`timescale 1ns/1nsmodule huawei5( input wire clk , input wire rst , input wire [3:0]d , output reg valid_in , output reg dout );//*************code***********// //state machine //set state localparam IDLE = 0, S1 = 1, SOut = 2; reg [1:0] state, next; //counter reg [1:0] cnt; always@(posedge clk or negedge rst) begin if(~rst) cnt &lt;= 0; else if(cnt == 3) cnt &lt;= 0; else cnt &lt;= cnt + 1; end //state transition always@(*) begin case(state) IDLE: next = (cnt == 3) ? S1: IDLE; S1: next = SOut; SOut: next = (cnt == 3) ? S1: SOut; default: next = IDLE; endcase end //data reg reg [3:0] d_temp; always@(posedge clk or negedge rst) begin if(~rst) d_temp &lt;= 0; else if(next == S1) d_temp &lt;= d; end //state flip-flops always@(posedge clk or negedge rst) begin if(~rst) state &lt;= IDLE; else state &lt;= next; end //output always@(posedge clk or negedge rst) begin if(~rst) begin valid_in &lt;= 0; dout &lt;= 0; end else case(next) S1: begin valid_in &lt;= 1; dout &lt;= d[3]; end SOut: begin valid_in &lt;= 0; case(cnt) 2&#x27;d0: dout &lt;= d_temp[2]; 2&#x27;d1: dout &lt;= d_temp[1]; 2&#x27;d2: dout &lt;= d_temp[0]; default: dout &lt;= 0; endcase end default: begin valid_in &lt;= 0; dout &lt;= 0; end endcase end//*************code***********//endmodule1234567891011121314151617181920212223242526272829303132333435363738394041`timescale 1ns/1nsmodule huawei5( input wire clk , input wire rst , input wire [3:0]d , output wire valid_in , output wire dout );//*************code***********// //counter reg [1:0] cnt; always@(posedge clk or negedge rst) begin if(~rst) cnt &lt;= 0; else if(cnt == 3) cnt &lt;= 0; else cnt &lt;= cnt + 1; end //data reg reg [3:0] d_temp; reg valid; always@(posedge clk or negedge rst) begin if(~rst) begin d_temp &lt;= 0; valid &lt;= 0; end else if(cnt == 3) begin d_temp &lt;= d[3:0]; valid &lt;= 1; end else begin d_temp &lt;= d_temp&lt;&lt;1; valid &lt;= 0; end end //output assign dout = d_temp[3]; assign valid_in = valid;//*************code***********//endmodule VL6 时钟切换 （有待复习） 题目中说了是两个同步的倍频时钟clk0 clk1,已知clk0是clk1的二倍频，属于相关时钟，避免切换时毛刺出现，只需要在组合逻辑的基础上添加下降沿触发的DFF 。 code 答案貌似有问题，代码后附上仿真图像 1234567891011121314151617181920212223242526272829303132module test_2( input wire clk0 , input wire clk1 , input wire rst , input wire sel , //sel==0时，输出为clk0；sel==1时，输出为clk1 output reg clk_out);//*************code***********// reg q0, q1; //q0表示目前输出为clk0，q1表示目前输出为clk1 //为了避免毛刺，当clk0和clk1都为低电平的时候切换 //由clk0下降沿触发，确保q0跳变时clk0处于低电平 //如果当前输出为clk0，sel变化后，直到clk0下降沿后q0才会跳变至0 always@(negedge clk0 or negedge rst) begin if(~rst) q0 &lt;= 0; else q0 &lt;= ~sel &amp; ~q1; //sel为0并且输出不为clk1时，输出clk0 end //由clk1下降沿触发，确保q1跳变时clk1处于低电平 //如果当前输出为clk1，sel变化后，直到clk1下降沿后q1才会跳变至0 always@(negedge clk1 or negedge rst) begin if(~rst) q1 &lt;= 0; else q1 &lt;= sel &amp; ~q0; //sel为1并且输出不为clk0时，输出clk1 end always@(*) begin clk_out &lt;= (q0 &amp; clk0) | (q1 &amp; clk1); end//*************code***********//endmodule testbench: 1234567891011121314151617181920212223242526272829303132333435363738`timescale 1ps/1ps `define clk0_period 20`define clk1_period 40module test_2_tb(); reg clk0, clk1; reg rst; reg sel; wire clk_out; initial clk0 = 0; always #(`clk0_period/2) clk0 = ~clk0; initial clk1 = 0; always #(`clk1_period/2) clk1 = ~clk1; reg [15:0] myRandom0, myRandom1; initial begin rst = 0; sel = 0; #5 rst = 1; repeat(50) begin myRandom0 = &#123;$random&#125;%1000; myRandom1 = &#123;$random&#125;%1000; sel = 0; #myRandom0; sel = 1; #myRandom1; end #200 $stop; end test_2 u1( .clk0(clk0), .clk1(clk1), .rst(rst), .sel(sel), .clk_out(clk_out) );endmodule VL7 状态机与时钟分频code 123456789101112131415161718192021222324252627282930313233343536373839`timescale 1ns/1nsmodule huawei7( input wire clk , input wire rst , output reg clk_out);//*************code***********// //set state localparam A = 0, B = 1, C = 2, D = 3; reg [1:0] state, next; //state transition always@(*) begin case(state) A: next = B; B: next = C; C: next = D; D: next = A; endcase end //state flip-flops always@(posedge clk or negedge rst) begin if(~rst) state &lt;= A; else state &lt;= next; end //output always@(posedge clk or negedge rst) begin if(~rst) clk_out &lt;= A; else case(next) A: clk_out &lt;= 0; B: clk_out &lt;= 1; C: clk_out &lt;= 0; D: clk_out &lt;= 0; endcase end//*************code***********//endmodule VL8 超前进位加法器 故可令Gi = Ai &amp; Bi; Pi = Ai | Bi，则Ci+1 = Gi | Pi &amp; Ci code 1234567891011121314151617181920212223242526272829303132333435363738394041424344`timescale 1ns/1nsmodule huawei8//四位超前进位加法器( input wire [3:0]A, input wire [3:0]B, output wire [4:0]OUT);//*************code***********// wire [3:0] P, G; wire [4:1] Ci; Add1 u0(.a(A[0]), .b(B[0]), .C_in(1&#x27;b0), .f(OUT[0]), .p(P[0]), .g(G[0])); Add1 u1(.a(A[1]), .b(B[1]), .C_in(Ci[1]), .f(OUT[1]), .p(P[1]), .g(G[1])); Add1 u2(.a(A[2]), .b(B[2]), .C_in(Ci[2]), .f(OUT[2]), .p(P[2]), .g(G[2])); Add1 u3(.a(A[3]), .b(B[3]), .C_in(Ci[3]), .f(OUT[3]), .p(P[3]), .g(G[3])); CLA_4 mod_0(.P(P), .G(G), .C_in(1&#x27;b0), .Ci(Ci)); assign OUT[4] = Ci[4];//*************code***********//endmodule//////////////下面是两个子模块////////module Add1( input a, input b, input C_in, output f, output g, output p ); assign g = a &amp; b; assign p = a | b; assign f = a ^ b ^ C_in; //加法结果endmodule//超前进位module CLA_4( input [3:0]P, input [3:0]G, input C_in, output [4:1]Ci ); assign Ci[1] = G[0] | P[0] &amp; C_in; assign Ci[2] = G[1] | P[1] &amp; Ci[1]; assign Ci[3] = G[2] | P[2] &amp; Ci[2]; assign Ci[4] = G[3] | P[3] &amp; Ci[3];endmodule VL11 脉冲同步器（快到慢）code 12345678910111213141516171819202122232425262728293031323334`timescale 100ps/100psmodule pulse_detect( input clka , //300M T = 3.33ns input clkb , //100M T = 10 ns input rst_n , input sig_a , output sig_b); //利用电平翻转保存脉冲信号 reg sig_level; always@(posedge clka or negedge rst_n) begin if(~rst_n) sig_level &lt;= 0; else if(sig_a) sig_level &lt;= ~sig_level; end //将clka同步到clkb时域 reg sig_temp1, sig_temp2, sig_temp3; always@(posedge clkb or negedge rst_n) begin if(~rst_n) begin sig_temp1 &lt;= 0; sig_temp2 &lt;= 0; sig_temp3 &lt;= 0; end else begin sig_temp1 &lt;= sig_level; sig_temp2 &lt;= sig_temp1; sig_temp3 &lt;= sig_temp2; end end //output assign sig_b = sig_temp3 ^ sig_temp2;endmodule VL12 序列检测器（Moore型）code 个人觉得三段式状态机输出应该由next态决定，否则输出会晚一个周期，但是答案波形要求检测state来得到输出。 1234567891011121314151617181920212223242526272829303132333435363738394041`timescale 1ns/1nsmodule det_moore( input clk , input rst_n , input din , output reg Y ); //state machine //set state localparam IDLE = 0, S1 = 1, S11 = 2, S110 = 3, S1101 = 4; reg [2:0] state, next; //state transition(combinational) always@(*) begin case(state) IDLE: next = din ? S1 : IDLE; S1: next = din ? S11 : IDLE; S11: next = din ? S11 : S110; S110: next = din ? S1101 : IDLE; S1101: next = din ? S1 : IDLE; default: next = IDLE; endcase end //state flip-flops(sequential) always@(posedge clk or negedge rst_n) begin if(~rst_n) state &lt;= IDLE; else state &lt;= next; end //output always@(posedge clk or negedge rst_n) begin if(~rst_n) Y &lt;= 0; else case(state) S1101: Y &lt;= 1; default: Y &lt;= 0; endcase endendmodule VL13 乘法与位运算利用移位进行2的整数倍乘法，可以节省资源占用 code 因为题目要求B &#x3D; A * 8’b1111_1011，而8’b1111_1011中1多0少，利用减法所耗资源会更少 12345678module dajiang13( input [7:0] A, output [15:0] B );//*************code***********// assign B = (A &lt;&lt; 8) - (A &lt;&lt; 2) - A; //8&#x27;b1111_1011 = 9&#x27;b1_0000_0000 - 3&#x27;b100 - 1&#x27;b1//*************code***********//endmodule 资源占用如下 对照组： 1assign B = A * 8&#x27;b1111_1011; 1assign B = (A &lt;&lt; 7) + (A &lt;&lt; 6) + (A &lt;&lt; 5) + (A &lt;&lt; 4) + (A &lt;&lt; 3) + (A &lt;&lt; 1) + A; VL16 异步复位同步释放 （有待复习）同步复位 always@(posedge clk) 复位信号只有在时钟上升沿到来时才能有效 优点： 利于仿真器仿真； 可以滤除高于时钟频率的复位毛刺； 可以使系统称为100%的同步时序电路，有利于时序分析； 缺点： 复位信号必须大于一个时钟周期或刚好在触发边沿才能被识别； 由于大多数逻辑器件的目标库内的DFF都只有异步复位端口，使用同步复位综合器会额外插入组合逻辑，从而耗费较多的逻辑资源； 异步复位：always@(posedge clk or negedge rst_n)复位信号有效时即刻进行复位 优点： 设计简单； 大多数DFF都有异步复位端口，节省资源； 识别方便，并且可以很方便的使用FPGA的全局复位端口GSR； 缺点： 复位信号容易受毛刺影响；（可以对复位信号进行消抖处理） 复位信号释放时，若刚好处于时钟有效边沿附近，容易出现亚稳态；（可以采用异步复位，同步释放的方式来避免） 一些问题可以点击参考。 code 12345678910111213141516171819202122232425262728module ali16(input clk,input rst_n,input d,output reg dout );//*************code***********// //将异步复位信号同步到该时钟域中 reg rst_n_temp1, rst_n_temp2; always@(posedge clk or negedge rst_n) begin if(~rst_n) begin rst_n_temp1 &lt;= 0; rst_n_temp2 &lt;= 0; end else begin rst_n_temp1 &lt;= 1; rst_n_temp2 &lt;= rst_n_temp1; end end //输入同步处理后的异步复位信号 always@(posedge clk or negedge rst_n_temp2) begin if(~rst_n_temp2) dout &lt;= 0; else dout &lt;= d; end//*************code***********//endmodule 得到的波形如图： 即异步复位信号输入时即刻生效，但当输入的异步复位信号释放后，对于系统来说要经过2个时钟周期后才会真正释放。 VL19 编写乘法器求解算法表达式code 123456789101112131415161718192021222324252627module calculation( input clk, input rst_n, input [3:0] a, input [3:0] b, output [8:0] c); reg [7:0] temp1, temp2; always@(posedge clk or negedge rst_n) begin if(~rst_n) begin temp1 &lt;= 0; temp2 &lt;= 0; end else begin temp1 &lt;= &#123;a, 3&#x27;b000&#125; + &#123;a, 2&#x27;b00&#125;; temp2 &lt;= &#123;b, 2&#x27;b00&#125; + b; end end reg [8:0] c_temp; always@(posedge clk or negedge rst_n) begin if(~rst_n) c_temp &lt;= 0; else c_temp &lt;= temp1 + temp2; end assign c = c_temp;endmodule code 1","categories":[],"tags":[{"name":"Verilog","slug":"Verilog","permalink":"http://example.com/tags/Verilog/"}]},{"title":"C++笔记（七）——迭代器介绍","slug":"cpp/cpp-note-7","date":"2022-05-01T14:12:52.000Z","updated":"2022-05-05T05:45:15.164Z","comments":true,"path":"2022/05/01/cpp/cpp-note-7/","link":"","permalink":"http://example.com/2022/05/01/cpp/cpp-note-7/","excerpt":"迭代器下标运算符可以用于访问string对象的字符或vector对象的元素，迭代器(iterator)可以达到同样的目的。所有标准器件库容器都可以使用迭代器（更通用），但只有少数几种才同时支持下标运算符。 迭代器类似于指针，提供了对对象的间接访问，也分为有效和无效（有效迭代器指向某个元素或者容器中尾元素的下一个位置；其他情况均无效）。 使用迭代器与指针不同，获取迭代器不是使用取地址符（&amp;）： 12//v是一个非空的vector，拥有迭代器的类同时拥有返回迭代器的成员，如begin()和end()auto b = v.begin(), e = v.end(); //b表示v的第一个元素，e表示v尾元素的下一位置 与指针类似，可以通过解引用符（*）来获取它所指的元素： 123456//利用迭代器将s的首字母替换为大写string s(&quot;some string&quot;);if (s.begin() != s.end()) &#123; auto it = s.begin(); *it = toupper(*it);&#125; 迭代器使用递增（++）运算符来移动到下一个元素： 12345//利用迭代器将s的所有字母替换为大写string s(&quot;some string&quot;);for (auto it = s.begin(); it != s.end(); ++it) &#123; *it = toupper(*it);&#125;","text":"迭代器下标运算符可以用于访问string对象的字符或vector对象的元素，迭代器(iterator)可以达到同样的目的。所有标准器件库容器都可以使用迭代器（更通用），但只有少数几种才同时支持下标运算符。 迭代器类似于指针，提供了对对象的间接访问，也分为有效和无效（有效迭代器指向某个元素或者容器中尾元素的下一个位置；其他情况均无效）。 使用迭代器与指针不同，获取迭代器不是使用取地址符（&amp;）： 12//v是一个非空的vector，拥有迭代器的类同时拥有返回迭代器的成员，如begin()和end()auto b = v.begin(), e = v.end(); //b表示v的第一个元素，e表示v尾元素的下一位置 与指针类似，可以通过解引用符（*）来获取它所指的元素： 123456//利用迭代器将s的首字母替换为大写string s(&quot;some string&quot;);if (s.begin() != s.end()) &#123; auto it = s.begin(); *it = toupper(*it);&#125; 迭代器使用递增（++）运算符来移动到下一个元素： 12345//利用迭代器将s的所有字母替换为大写string s(&quot;some string&quot;);for (auto it = s.begin(); it != s.end(); ++it) &#123; *it = toupper(*it);&#125; 关键概念：泛型编程(Generic Programming)如上段代码所示，for()中的条件部分使用了!&#x3D;而非&lt;，这是因为所有标准库容器的迭代器都定义了&#x3D;&#x3D;和!&#x3D;，而大多数没有定义&lt;运算符。因此，养成使用迭代器和!&#x3D;的习惯，就可以不用纠结容器类型。 泛型编程提出是为了发明一种语言机制，能够帮助实现一个通用的标准容器库。这样便于编写完全一般化且可重复使用的算法，实现算法和数据结构分离。 迭代器类型： 123vector&lt;int&gt;::iterator it1; //it是能读写vector&lt;int&gt;对象中的字符的迭代器vector&lt;int&gt;::const_iterator cit;//类似于指向常量的指针，即迭代器可以递增，但是不可通过它修改其所指对象const vector&lt;int&gt;::iterator it2;//类似于常量指针，迭代器不可递增，但可通过它 begin和end返回的具体类型由对象是否是常量决定，若对象是常量，则返回const_iterator；反之，返回iterator。 使用cbegin和cend则可以返回const_iterator： 12345vector&lt;int&gt; v;const vector&lt;int&gt; cv;auto it1 = v.begin(); //it1的类型是iteratorauto it2 = cv.begin(); //it2的类型是const_iteratorauto it3 = v.cbegin(); //it3的类型是const_iterator 通过解引用符获得迭代器所指对象后，若该对象恰好是类，就可以进一步利用点运算符访问其成员： 123vector&lt;string&gt; sv;auto it = sv.begin();cout&lt;&lt;(*it).empty(); //第一个括号必不可少，必须先进行解引用操作 使用C++的箭头表达式（-&gt;）可以达到同样的效果： 1it-&gt;empty(); //等价于(*it).empty(); 注意：任何一个可能改变vector对象容量的操作都会使该vector对象的迭代器失效，故千万不要在使用了迭代器的循环体中向迭代器所属的容器添加元素。 练习3.22 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;string&gt; vs; string s(&quot;&quot;); while (cin &gt;&gt; s) &#123; if (!s.empty()) vs.push_back(s); &#125; for (auto it = vs.begin(); it != vs.end() &amp;&amp; !it-&gt;empty(); ++it) &#123; for (auto c = it-&gt;begin(); c != it-&gt;end(); ++c) &#123; if (*c != &#x27;\\0&#x27;) *c = toupper(*c); &#125; cout &lt;&lt; *it &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; endl; return 0;&#125; 迭代器运算迭代器加、减任何一个整数仍得到一个迭代器，迭代器指示的新位置与原来相比向前、向后移动了若干个元素（不能溢出）； 两个迭代器相减得到它们之间的距离，其结果的类型是difference_type，参与运算的两个迭代器必须指向同一个容器中的元素（没有相加操作）； 迭代器的关系运算（&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D;），如果某迭代器指向的容器位置在另一个迭代器所指位置之前，则前者小于后者； 经典算法：二分搜索123456789101112//text必须是有序的//beg和end表示我们搜索的范围auto beg = text.begin(), end = text.end();auto mid = text.begin() + (end - beg) / 2;//当还有元素尚未检查并且我们还没有找到sought时执行循环while (mid != end &amp;&amp; *mid != sought) &#123; if (sought &lt; *mid) //判断sought是否在前半部分 end = mid; //如果是，调整搜索范围忽略后半部分 else beg = mid + 1; //如果不是，忽略前半部分 mid = beg + (end - beg) / 2; //新的中间点&#125; 练习3.24 123456789101112131415161718#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; vi; int i; while (cin &gt;&gt; i) &#123; vi.push_back(i); &#125; for (auto c = vi.begin(); c != vi.begin() + vi.size() / 2; c++) &#123; cout &lt;&lt; *c + *(vi.begin() + (vi.end() - c) - 1) &lt;&lt; &#x27; &#x27;; &#125; if (vi.size() % 2 == 1) cout &lt;&lt; *(vi.begin() + vi.size()/2) &lt;&lt; endl; return 0;&#125; 练习3.25 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; scores(11,0); int grade; while (cin &gt;&gt; grade) &#123; if (grade &lt;= 100) &#123; ++ *(scores.begin() + grade/10); //注意不要忘了括号前的 * &#125; &#125; for (auto c = scores.begin(); c != scores.end(); ++c) &#123; cout &lt;&lt; *c &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"学习FPGA（五）——异步FIFO","slug":"FPGA/FPGA-5","date":"2022-04-30T11:39:42.000Z","updated":"2022-05-01T09:04:49.534Z","comments":true,"path":"2022/04/30/FPGA/FPGA-5/","link":"","permalink":"http://example.com/2022/04/30/FPGA/FPGA-5/","excerpt":"异步FIFO​ 异步FIFO代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697module Asynchronous_FIFO#(parameter DEPTH = 16, parameter WIDTH = 8)(wclk, wrstn, winc, wdata, wfull, rclk, rrstn, rinc, rdata, rempty); //write module I/O input wclk; input wrstn; input winc; //enable signal input [WIDTH-1 : 0] wdata; output reg wfull; //read module I/O input rclk; input rrstn; input rinc; //enable signal output [WIDTH-1 : 0] rdata; output reg rempty; //set enable signal wire wenc, renc; assign wenc = winc &amp; !wfull; assign renc = rinc &amp; !rempty; //adress counter ***************************************************************************************** reg [$clog2(DEPTH) : 0] waddr, raddr; always@(posedge wclk or negedge wrstn) begin if(!wrstn) waddr &lt;= 0; else if(wenc) waddr &lt;= waddr + 1&#x27;b1; end always@(posedge rclk or negedge rrstn) begin if(!rrstn) raddr &lt;= 0; else if(renc) raddr &lt;= raddr + 1&#x27;b1; end //binary to gray ***************************************************************************************** reg [$clog2(DEPTH) : 0] waddr_gray, raddr_gray; always@(posedge wclk or negedge wrstn) begin if(!wrstn) waddr_gray &lt;= 0; else if(wenc) waddr_gray &lt;= (waddr + 1&#x27;b1) ^ (waddr + 1&#x27;b1)&gt;&gt;1; //保证gray code与当前的binary code同步 end always@(posedge rclk or negedge rrstn) begin if(!rrstn) raddr_gray &lt;= 0; else if(renc) raddr_gray &lt;= (raddr + 1&#x27;b1) ^ (raddr + 1&#x27;b1)&gt;&gt;1; //保证gray code与当前的binary code同步 end //synchonize ***************************************************************************************** reg [$clog2(DEPTH) : 0] raddr_gray_temp1, raddr_gray_temp2; reg [$clog2(DEPTH) : 0] waddr_gray_temp1, waddr_gray_temp2; always@(posedge wclk or negedge wrstn) begin //将raddr_gray同步到wclk if(!wrstn) begin raddr_gray_temp1 &lt;= 0; raddr_gray_temp2 &lt;= 0; end else begin raddr_gray_temp1 &lt;= raddr_gray; raddr_gray_temp2 &lt;= raddr_gray_temp1; end end always@(posedge rclk or negedge rrstn) begin //将raddr_gray同步到wclk if(!rrstn) begin waddr_gray_temp1 &lt;= 0; waddr_gray_temp2 &lt;= 0; end else begin waddr_gray_temp1 &lt;= waddr_gray; waddr_gray_temp2 &lt;= waddr_gray_temp1; end end //full or empty ***************************************************************************************** always@(*) begin if(!wrstn) wfull = 0; else if(&#123;~waddr_gray[$clog2(DEPTH) : $clog2(DEPTH) - 1], waddr_gray[$clog2(DEPTH) - 2 : 0]&#125; == raddr_gray_temp2) //gray code最高两位不同而其他位全等时，写满 wfull = 1; else wfull = 0; end always@(*) begin if(!rrstn) rempty = 0; else if(raddr_gray == waddr_gray_temp2) //gray code全等时，读空 rempty = 1; else rempty = 0; end //RAM ***************************************************************************************** FIFO_DUAL_RAM RAM1( .wclk(wclk), .wenc(wenc), .waddr(waddr), .wdata(wdata), .rclk(rclk), .renc(renc), .raddr(raddr), .rdata(rdata) );endmodule RAM代码： 12345678910111213141516171819202122232425//FIFO_DUAL_RAM需要的端口有时钟、地址、使能、数据端，读、写模块各四个端口，复位端看需求module FIFO_DUAL_RAM#(parameter DEPTH = 16, parameter WIDTH = 8)(wclk, wenc, waddr, wdata, rclk, renc, raddr, rdata); input wclk; input wenc; input [$clog2(DEPTH) - 1 : 0] waddr; input [WIDTH - 1 : 0] wdata; input rclk; input renc; input [$clog2(DEPTH) - 1 : 0] raddr; output reg [WIDTH - 1 : 0] rdata; //write reg [WIDTH-1 : 0] RAM_MEM [0 : DEPTH - 1]; always@(posedge wclk) begin if(wenc) RAM_MEM[waddr] &lt;= wdata; end //read always@(posedge rclk) begin if(renc) rdata &lt;= RAM_MEM[raddr]; endendmodule 写入和读出的数据均正常，没有出现数据覆盖： 波形总览：","text":"异步FIFO​ 异步FIFO代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697module Asynchronous_FIFO#(parameter DEPTH = 16, parameter WIDTH = 8)(wclk, wrstn, winc, wdata, wfull, rclk, rrstn, rinc, rdata, rempty); //write module I/O input wclk; input wrstn; input winc; //enable signal input [WIDTH-1 : 0] wdata; output reg wfull; //read module I/O input rclk; input rrstn; input rinc; //enable signal output [WIDTH-1 : 0] rdata; output reg rempty; //set enable signal wire wenc, renc; assign wenc = winc &amp; !wfull; assign renc = rinc &amp; !rempty; //adress counter ***************************************************************************************** reg [$clog2(DEPTH) : 0] waddr, raddr; always@(posedge wclk or negedge wrstn) begin if(!wrstn) waddr &lt;= 0; else if(wenc) waddr &lt;= waddr + 1&#x27;b1; end always@(posedge rclk or negedge rrstn) begin if(!rrstn) raddr &lt;= 0; else if(renc) raddr &lt;= raddr + 1&#x27;b1; end //binary to gray ***************************************************************************************** reg [$clog2(DEPTH) : 0] waddr_gray, raddr_gray; always@(posedge wclk or negedge wrstn) begin if(!wrstn) waddr_gray &lt;= 0; else if(wenc) waddr_gray &lt;= (waddr + 1&#x27;b1) ^ (waddr + 1&#x27;b1)&gt;&gt;1; //保证gray code与当前的binary code同步 end always@(posedge rclk or negedge rrstn) begin if(!rrstn) raddr_gray &lt;= 0; else if(renc) raddr_gray &lt;= (raddr + 1&#x27;b1) ^ (raddr + 1&#x27;b1)&gt;&gt;1; //保证gray code与当前的binary code同步 end //synchonize ***************************************************************************************** reg [$clog2(DEPTH) : 0] raddr_gray_temp1, raddr_gray_temp2; reg [$clog2(DEPTH) : 0] waddr_gray_temp1, waddr_gray_temp2; always@(posedge wclk or negedge wrstn) begin //将raddr_gray同步到wclk if(!wrstn) begin raddr_gray_temp1 &lt;= 0; raddr_gray_temp2 &lt;= 0; end else begin raddr_gray_temp1 &lt;= raddr_gray; raddr_gray_temp2 &lt;= raddr_gray_temp1; end end always@(posedge rclk or negedge rrstn) begin //将raddr_gray同步到wclk if(!rrstn) begin waddr_gray_temp1 &lt;= 0; waddr_gray_temp2 &lt;= 0; end else begin waddr_gray_temp1 &lt;= waddr_gray; waddr_gray_temp2 &lt;= waddr_gray_temp1; end end //full or empty ***************************************************************************************** always@(*) begin if(!wrstn) wfull = 0; else if(&#123;~waddr_gray[$clog2(DEPTH) : $clog2(DEPTH) - 1], waddr_gray[$clog2(DEPTH) - 2 : 0]&#125; == raddr_gray_temp2) //gray code最高两位不同而其他位全等时，写满 wfull = 1; else wfull = 0; end always@(*) begin if(!rrstn) rempty = 0; else if(raddr_gray == waddr_gray_temp2) //gray code全等时，读空 rempty = 1; else rempty = 0; end //RAM ***************************************************************************************** FIFO_DUAL_RAM RAM1( .wclk(wclk), .wenc(wenc), .waddr(waddr), .wdata(wdata), .rclk(rclk), .renc(renc), .raddr(raddr), .rdata(rdata) );endmodule RAM代码： 12345678910111213141516171819202122232425//FIFO_DUAL_RAM需要的端口有时钟、地址、使能、数据端，读、写模块各四个端口，复位端看需求module FIFO_DUAL_RAM#(parameter DEPTH = 16, parameter WIDTH = 8)(wclk, wenc, waddr, wdata, rclk, renc, raddr, rdata); input wclk; input wenc; input [$clog2(DEPTH) - 1 : 0] waddr; input [WIDTH - 1 : 0] wdata; input rclk; input renc; input [$clog2(DEPTH) - 1 : 0] raddr; output reg [WIDTH - 1 : 0] rdata; //write reg [WIDTH-1 : 0] RAM_MEM [0 : DEPTH - 1]; always@(posedge wclk) begin if(wenc) RAM_MEM[waddr] &lt;= wdata; end //read always@(posedge rclk) begin if(renc) rdata &lt;= RAM_MEM[raddr]; endendmodule 写入和读出的数据均正常，没有出现数据覆盖： 波形总览： FIFO IP核利用quartus的IP核生成一个参数基本相同的IP核，对同一个testbench得到的波形如下图： 总结自己写的异步FIFO从RTL级仿真的图像来看勉强能实现双端口输入输出的功能，但也有很多瑕疵，比如没有初始化RAM等。","categories":[],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"http://example.com/tags/FPGA/"},{"name":"Verilog","slug":"Verilog","permalink":"http://example.com/tags/Verilog/"}]},{"title":"牛客网Verilog刷题笔记2","slug":"nowcoder/nowcoder2-verilog17","date":"2022-04-29T07:07:21.000Z","updated":"2022-05-04T02:55:10.980Z","comments":true,"path":"2022/04/29/nowcoder/nowcoder2-verilog17/","link":"","permalink":"http://example.com/2022/04/29/nowcoder/nowcoder2-verilog17/","excerpt":"VL17 任意小数分频核心思想是让10个clk_out周期是clk_in周期的87倍，无法让clk_out的每个周期都相等，但可以让其尽量接近，所以把87拆分成3 * 8 + 7 * 9，即3个8分频和7个9分频。 本题答案对9分频部分的占空比没有要求，不过利用V16的方法可以使得9分频的占空比为50% code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263`timescale 1ns/1nsmodule div_M_N( input wire clk_in, input wire rst, output reg clk_out);parameter M_N = 8&#x27;d87; parameter c89 = 8&#x27;d24; // 8/9时钟切换点parameter div_e = 5&#x27;d8; //偶数周期parameter div_o = 5&#x27;d9; //奇数周期//*************code***********////考虑10个clk_out时钟周期是1个clk_in时钟周期的87倍 //counter reg [6:0] cnt; //总计数器 always@(posedge clk_in or negedge rst) begin if(~rst) cnt &lt;= 6&#x27;d0; else if(cnt == (M_N - 1&#x27;b1)) cnt &lt;= 6&#x27;d0; else cnt &lt;= cnt + 1&#x27;b1; end reg state; //state为0时8分频，为1时9分频 always@(posedge clk_in or negedge rst) begin if(~rst) state &lt;= 0; else if((cnt == (c89 - 1&#x27;b1)) | (cnt == (M_N - 1&#x27;b1))) state &lt;= ~state; end reg [3:0] cnt_d; //分频计数器 always@(posedge clk_in or negedge rst) begin if(~rst) cnt_d &lt;= 4&#x27;d0; else if(state == 0) begin if(cnt_d == div_e - 1&#x27;b1) cnt_d &lt;= 4&#x27;d0; else cnt_d &lt;= cnt_d + 1&#x27;b1; end else if(state == 1) begin if(cnt_d == div_o - 1&#x27;b1) cnt_d &lt;= 4&#x27;d0; else cnt_d &lt;= cnt_d + 1&#x27;b1; end end //div always@(posedge clk_in or negedge rst) begin if(~rst) clk_out &lt;= 1&#x27;d0; else case(state) 1&#x27;b0: begin if((cnt_d == div_e/2) | (cnt_d == 4&#x27;d0)) clk_out &lt;= ~clk_out; end 1&#x27;b1: begin if((cnt_d == (div_o - 1&#x27;b1)/2) | (cnt_d == 4&#x27;d0)) clk_out &lt;= ~clk_out; end endcase end//*************code***********//endmodule VL18 无占空比要求的奇数分频code 123456789101112131415161718192021222324252627282930`timescale 1ns/1nsmodule odd_div ( input wire rst , input wire clk_in, output wire clk_out5);//*************code***********// localparam N = 5; localparam SIZE = 2; //counter reg [SIZE:0] cnt; always@(posedge clk_in or negedge rst) begin if(~rst) cnt &lt;= &#x27;d0; else if(cnt == N - 1) cnt &lt;= &#x27;d0; else cnt &lt;= cnt + 1&#x27;b1; end //div reg clk_out; always@(posedge clk_in or negedge rst) begin if(~rst) clk_out &lt;= 1&#x27;d0; else if((cnt == (N - 1)/2) | (cnt == 0)) clk_out &lt;= ~clk_out; end assign clk_out5 = clk_out;//*************code***********//endmodule VL19 根据状态转移写状态机-三段式code 123456789101112131415161718192021222324252627282930313233343536373839`timescale 1ns/1nsmodule fsm1( input wire clk , input wire rst , input wire data , output reg flag);//*************code***********// //set state localparam S0 = 0, S1 = 1, S2 = 2, S3 = 3; reg [1:0] state, next; //state transition always@(*) begin case(state) S0: next = data ? S1 : S0; S1: next = data ? S2 : S1; S2: next = data ? S3 : S2; S3: next = data ? S0 : S3; default: next = S0; endcase end //state flip-flops always@(posedge clk or negedge rst) begin if(~rst) state &lt;= S0; else state &lt;= next; end //output 三段式输出用时序逻辑 可以防止出现毛刺 always@(posedge clk or negedge rst) begin if(~rst) flag &lt;= 1&#x27;b0; else case(state) S3: flag &lt;= data; default: flag &lt;= 1&#x27;b0; endcase end//*************code***********//endmodule VL20 根据状态转移写状态机-二段式code 123456789101112131415161718192021222324252627282930313233343536`timescale 1ns/1nsmodule fsm2( input wire clk , input wire rst , input wire data , output reg flag);//*************code***********// //set state localparam S0 = 0, S1 = 1, S2 = 2, S3 = 3, S4 = 4; reg [2:0] state, next; //state transition always@(*) begin case(state) S0: next = data ? S1 : S0; S1: next = data ? S2 : S1; S2: next = data ? S3 : S2; S3: next = data ? S4 : S3; S4: next = S0; default: next = S0; endcase end //state flip-flops always@(posedge clk or negedge rst) begin if(~rst) state &lt;= S0; else state &lt;= next; end //output 二段式输出用组合逻辑 always@(*) begin flag = (state == S4); end//*************code***********//endmodule","text":"VL17 任意小数分频核心思想是让10个clk_out周期是clk_in周期的87倍，无法让clk_out的每个周期都相等，但可以让其尽量接近，所以把87拆分成3 * 8 + 7 * 9，即3个8分频和7个9分频。 本题答案对9分频部分的占空比没有要求，不过利用V16的方法可以使得9分频的占空比为50% code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263`timescale 1ns/1nsmodule div_M_N( input wire clk_in, input wire rst, output reg clk_out);parameter M_N = 8&#x27;d87; parameter c89 = 8&#x27;d24; // 8/9时钟切换点parameter div_e = 5&#x27;d8; //偶数周期parameter div_o = 5&#x27;d9; //奇数周期//*************code***********////考虑10个clk_out时钟周期是1个clk_in时钟周期的87倍 //counter reg [6:0] cnt; //总计数器 always@(posedge clk_in or negedge rst) begin if(~rst) cnt &lt;= 6&#x27;d0; else if(cnt == (M_N - 1&#x27;b1)) cnt &lt;= 6&#x27;d0; else cnt &lt;= cnt + 1&#x27;b1; end reg state; //state为0时8分频，为1时9分频 always@(posedge clk_in or negedge rst) begin if(~rst) state &lt;= 0; else if((cnt == (c89 - 1&#x27;b1)) | (cnt == (M_N - 1&#x27;b1))) state &lt;= ~state; end reg [3:0] cnt_d; //分频计数器 always@(posedge clk_in or negedge rst) begin if(~rst) cnt_d &lt;= 4&#x27;d0; else if(state == 0) begin if(cnt_d == div_e - 1&#x27;b1) cnt_d &lt;= 4&#x27;d0; else cnt_d &lt;= cnt_d + 1&#x27;b1; end else if(state == 1) begin if(cnt_d == div_o - 1&#x27;b1) cnt_d &lt;= 4&#x27;d0; else cnt_d &lt;= cnt_d + 1&#x27;b1; end end //div always@(posedge clk_in or negedge rst) begin if(~rst) clk_out &lt;= 1&#x27;d0; else case(state) 1&#x27;b0: begin if((cnt_d == div_e/2) | (cnt_d == 4&#x27;d0)) clk_out &lt;= ~clk_out; end 1&#x27;b1: begin if((cnt_d == (div_o - 1&#x27;b1)/2) | (cnt_d == 4&#x27;d0)) clk_out &lt;= ~clk_out; end endcase end//*************code***********//endmodule VL18 无占空比要求的奇数分频code 123456789101112131415161718192021222324252627282930`timescale 1ns/1nsmodule odd_div ( input wire rst , input wire clk_in, output wire clk_out5);//*************code***********// localparam N = 5; localparam SIZE = 2; //counter reg [SIZE:0] cnt; always@(posedge clk_in or negedge rst) begin if(~rst) cnt &lt;= &#x27;d0; else if(cnt == N - 1) cnt &lt;= &#x27;d0; else cnt &lt;= cnt + 1&#x27;b1; end //div reg clk_out; always@(posedge clk_in or negedge rst) begin if(~rst) clk_out &lt;= 1&#x27;d0; else if((cnt == (N - 1)/2) | (cnt == 0)) clk_out &lt;= ~clk_out; end assign clk_out5 = clk_out;//*************code***********//endmodule VL19 根据状态转移写状态机-三段式code 123456789101112131415161718192021222324252627282930313233343536373839`timescale 1ns/1nsmodule fsm1( input wire clk , input wire rst , input wire data , output reg flag);//*************code***********// //set state localparam S0 = 0, S1 = 1, S2 = 2, S3 = 3; reg [1:0] state, next; //state transition always@(*) begin case(state) S0: next = data ? S1 : S0; S1: next = data ? S2 : S1; S2: next = data ? S3 : S2; S3: next = data ? S0 : S3; default: next = S0; endcase end //state flip-flops always@(posedge clk or negedge rst) begin if(~rst) state &lt;= S0; else state &lt;= next; end //output 三段式输出用时序逻辑 可以防止出现毛刺 always@(posedge clk or negedge rst) begin if(~rst) flag &lt;= 1&#x27;b0; else case(state) S3: flag &lt;= data; default: flag &lt;= 1&#x27;b0; endcase end//*************code***********//endmodule VL20 根据状态转移写状态机-二段式code 123456789101112131415161718192021222324252627282930313233343536`timescale 1ns/1nsmodule fsm2( input wire clk , input wire rst , input wire data , output reg flag);//*************code***********// //set state localparam S0 = 0, S1 = 1, S2 = 2, S3 = 3, S4 = 4; reg [2:0] state, next; //state transition always@(*) begin case(state) S0: next = data ? S1 : S0; S1: next = data ? S2 : S1; S2: next = data ? S3 : S2; S3: next = data ? S4 : S3; S4: next = S0; default: next = S0; endcase end //state flip-flops always@(posedge clk or negedge rst) begin if(~rst) state &lt;= S0; else state &lt;= next; end //output 二段式输出用组合逻辑 always@(*) begin flag = (state == S4); end//*************code***********//endmodule VL21 异步FIFO （有待复习，重点！！！） FIFO指First Input First Output，即先进先出。FIFO存储器一般作为系统的缓冲环节，作用 对连续的数据流进行缓存，防止在进机和存储操作时丢失数据； 数据集中起来进行进栈和存储，可避免频繁的总线操作，减轻CPU的负担； 允许系统进行DMA操作，提高数据的传输速度。这是至关重要的一点，如果不采用DMA操作，数据传输将达不到传输要求，而且大大增加CPU的负担，无法同时完成数据的存储工作。 code 12345678910111213141516171819202122232425262728293031323334353637383940414243`timescale 1ns/1ns/***************************************RAM*****************************************/// #()中定义的是 “可以提供给外部调用” 的常数参数module dual_port_RAM #(parameter DEPTH = 16, parameter WIDTH = 8)( input wclk, input wenc, input [$clog2(DEPTH)-1:0] waddr, //$clog2()是对2取对数函数，深度对2取对数，得到地址的位宽 input [WIDTH-1:0] wdata, //数据写入 input rclk, input renc, input [$clog2(DEPTH)-1:0] raddr, //深度对2取对数，得到地址的位宽 output reg [WIDTH-1:0] rdata //数据输出); reg [WIDTH-1:0] RAM_MEM [0:DEPTH-1]; always @(posedge wclk) begin if(wenc) RAM_MEM[waddr] &lt;= wdata; end always @(posedge rclk) begin if(renc) rdata &lt;= RAM_MEM[raddr]; end endmodule /***************************************AFIFO*****************************************/module asyn_fifo#( parameter WIDTH = 8, parameter DEPTH = 16)( input wclk , input rclk , input wrstn , input rrstn , input winc , input rinc , input [WIDTH-1:0] wdata , output wire wfull , output wire rempty , output wire [WIDTH-1:0] rdata); endmodule VL22 同步FIFO单纯做题实现功能折叠表格虽然通过了，但我的代码实际上是有问题的，答案给的波形也是有点问题的，参考。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798`timescale 1ns/1ns/**********************************RAM************************************/module dual_port_RAM #(parameter DEPTH = 16, parameter WIDTH = 8)( input wclk ,input wenc ,input [$clog2(DEPTH)-1:0] waddr //深度对2取对数，得到地址的位宽。 ,input [WIDTH-1:0] wdata //数据写入 ,input rclk ,input renc ,input [$clog2(DEPTH)-1:0] raddr //深度对2取对数，得到地址的位宽。 ,output reg [WIDTH-1:0] rdata //数据输出);reg [WIDTH-1:0] RAM_MEM [0:DEPTH-1]; always @(posedge wclk) begin if(wenc) RAM_MEM[waddr] &lt;= wdata;end always @(posedge rclk) begin if(renc) rdata &lt;= RAM_MEM[raddr];end endmodule /**********************************SFIFO************************************/module sfifo#( parameter WIDTH = 8, parameter DEPTH = 16)( input clk , input rst_n , input winc , input rinc , input [WIDTH-1:0] wdata , output reg wfull , output reg rempty , output wire [WIDTH-1:0] rdata); //set enable signal wire wenc, renc; assign wenc = winc &amp; ~wfull; assign renc = rinc &amp; ~rempty; //address //这里的地址移动方式只有在DEPTH为2的整数次幂时才能正常工作 reg [$clog2(DEPTH):0] waddr, raddr; always@(posedge clk or negedge rst_n) begin //waddr，when wfull == 1, keep waddr if(~rst_n) waddr &lt;= 0; else if(winc) begin //这部分可以简化，改成以下代码 if((waddr[$clog2(DEPTH)-1:0] == raddr[$clog2(DEPTH)-1:0]) &amp; (waddr[$clog2(DEPTH)] != raddr[$clog2(DEPTH)])) waddr &lt;= waddr; //else if(wenc) else // waddr &lt;= waddr + 1&#x27;b1; waddr &lt;= waddr + 1&#x27;b1; // end // end always@(posedge clk or negedge rst_n) begin //raddr，when rempty == 1, keep raddr if(~rst_n) raddr &lt;= 0; else if(rinc) begin //同理可简化为以下 if((waddr[$clog2(DEPTH)-1:0] == raddr[$clog2(DEPTH)-1:0]) &amp; (waddr[$clog2(DEPTH)] == raddr[$clog2(DEPTH)])) raddr &lt;= raddr; //else if(renc) else // raddr &lt;= raddr + 1&#x27;b1; raddr &lt;= raddr + 1&#x27;b1; // end // end //flag output //当读地址和写地址[$clog2(DEPTH)-1:0]位相同时，且最高位不同时，表明写地址超了读地址一圈，即写满了 always@(posedge clk or negedge rst_n) begin if(~rst_n) wfull &lt;= 0; else if((waddr[$clog2(DEPTH)-1:0] == raddr[$clog2(DEPTH)-1:0]) &amp; (waddr[$clog2(DEPTH)] != raddr[$clog2(DEPTH)])) wfull &lt;= 1; else wfull &lt;= 0; end //当读地址和写地址[$clog2(DEPTH)-1:0]位相同时，且最高位相同时，表明写地址与读地址相同，即读空了 always@(posedge clk or negedge rst_n) begin if(~rst_n) rempty &lt;= 0; else if((waddr[$clog2(DEPTH)-1:0] == raddr[$clog2(DEPTH)-1:0]) &amp; (waddr[$clog2(DEPTH)] == raddr[$clog2(DEPTH)])) rempty &lt;= 1; else rempty &lt;= 0; end //RAM dual_port_RAM RAM1( .wclk(clk), .wenc(wenc), .waddr(waddr[$clog2(DEPTH)-1:0]), //深度对2取对数，得到地址的位宽。 .wdata(wdata), //数据写入 .rclk(clk), .renc(renc), .raddr(raddr[$clog2(DEPTH)-1:0]), //深度对2取对数，得到地址的位宽。 .rdata(rdata) //数据输出 );endmodule 波形如下，分析时序可以发现，在输入为19的那个时钟上升沿时，waddr已经变成了10，且raddr为00，即此时已经“写满”，但wfull信号要在下一个上升沿到来时才会跳变为·，这导致waddr多走了一位，从而引发后续一系列的错误。（这居然能通过，只能说牛客网这道题的testbench不是很理想） 将输出wfull和rempty部分改为组合逻辑后能够得到正常的波形，不过实际使用时组合逻辑很容易产生毛刺。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293`timescale 1ns/1ns/**********************************RAM************************************/module dual_port_RAM #(parameter DEPTH = 16, parameter WIDTH = 8)( input wclk ,input wenc ,input [$clog2(DEPTH)-1:0] waddr //深度对2取对数，得到地址的位宽。 ,input [WIDTH-1:0] wdata //数据写入 ,input rclk ,input renc ,input [$clog2(DEPTH)-1:0] raddr //深度对2取对数，得到地址的位宽。 ,output reg [WIDTH-1:0] rdata //数据输出);reg [WIDTH-1:0] RAM_MEM [0:DEPTH-1];always @(posedge wclk) begin if(wenc) RAM_MEM[waddr] &lt;= wdata;end always @(posedge rclk) begin if(renc) rdata &lt;= RAM_MEM[raddr];end endmodule /**********************************SFIFO************************************/module sfifo#( parameter WIDTH = 8, parameter DEPTH = 16)( input clk , input rst_n , input winc , input rinc , input [WIDTH-1:0] wdata , output reg wfull , output reg rempty , output wire [WIDTH-1:0] rdata); //set enable signal wire wenc, renc; assign wenc = winc &amp; ~wfull; assign renc = rinc &amp; ~rempty; //address //这里的地址移动方式只有在DEPTH为2的整数次幂时才能正常工作 reg [$clog2(DEPTH):0] waddr, raddr; always@(posedge clk or negedge rst_n) begin //waddr，when wfull == 1, keep waddr if(~rst_n) waddr &lt;= 0; else if(wenc) waddr &lt;= waddr + 1&#x27;b1; end always@(posedge clk or negedge rst_n) begin //raddr，when rempty == 1, keep raddr if(~rst_n) raddr &lt;= 0; else if(renc) raddr &lt;= raddr + 1&#x27;b1; end //output //当读地址和写地址[$clog2(DEPTH)-1:0]位相同时，且最高位不同时，表明写地址超了读地址一圈，即写满了 always@(*) begin if(~rst_n) wfull = 0; else if((waddr[$clog2(DEPTH)-1:0] == raddr[$clog2(DEPTH)-1:0]) &amp; (waddr[$clog2(DEPTH)] != raddr[$clog2(DEPTH)])) wfull = 1; else wfull = 0; end //当读地址和写地址[$clog2(DEPTH)-1:0]位相同时，且最高位相同时，表明写地址与读地址相同，即读空了 always@(*) begin if(~rst_n) rempty = 0; else if((waddr[$clog2(DEPTH)-1:0] == raddr[$clog2(DEPTH)-1:0]) &amp; (waddr[$clog2(DEPTH)] == raddr[$clog2(DEPTH)])) rempty = 1; else rempty = 0; end //RAM dual_port_RAM RAM1( .wclk(clk), .wenc(wenc), .waddr(waddr[$clog2(DEPTH)-1:0]), //深度对2取对数，得到地址的位宽。 .wdata(wdata), //数据写入 .rclk(clk), .renc(renc), .raddr(raddr[$clog2(DEPTH)-1:0]), //深度对2取对数，得到地址的位宽。 .rdata(rdata) //数据输出 );endmodule 下图中可以看到，在输入为19的那个时钟上升沿时，wfull就已经跳变为1，系统不再记录后续的数据。从后续波形可以看出，没有发生数据覆盖。 VL23 格雷码计数器如果用二进制计数，再译码为格雷码输出，本质上还是二进制计数器，没有体现出格雷码计数时只改变一位的优势，所以采用状态机实现。各个状态直接用格雷码表示，状态转换时只会有一位发生改变。 code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566`timescale 1ns/1nsmodule gray_counter( input clk, input rst_n, output [3:0] gray_out); //二分频（很喜欢讨论区的一句话，什么逆天计数器） reg cnt; always@(posedge clk or negedge rst_n) begin if(~rst_n) cnt &lt;= 1&#x27;d0; else cnt &lt;= cnt +1&#x27;b1; end //set state (gray code) localparam S0 = 4&#x27;b0000, S1 = 4&#x27;b0001, S2 = 4&#x27;b0011, S3 = 4&#x27;b0010, S4 = 4&#x27;b0110, S5 = 4&#x27;b0111, S6 = 4&#x27;b0101, S7 = 4&#x27;b0100, S8 = 4&#x27;b1100, S9 = 4&#x27;b1101, S10 = 4&#x27;b1111, S11 = 4&#x27;b1110, S12 = 4&#x27;b1010, S13 = 4&#x27;b1011, S14 = 4&#x27;b1001, S15 = 4&#x27;b1000; reg [3:0] state, next; always@(*) begin case(state) S0: next = S1; S1: next = S2; S2: next = S3; S3: next = S4; S4: next = S5; S5: next = S6; S6: next = S7; S7: next = S8; S8: next = S9; S9: next = S10; S10: next = S11; S11: next = S12; S12: next = S13; S13: next = S14; S14: next = S15; S15: next = S0; endcase end //state flip-flops always@(posedge clk or negedge rst_n) begin if(~rst_n) state &lt;= S0; else if(cnt) state &lt;= next; else state &lt;= state; end //output assign gray_out = state;endmodule VL24 多bit MUX同步器Solution 1Solution 2折叠表格这种做法用的寄存器资源较多，看了题解，发现让使能信号data_en“打两拍”可以达到同样的效果，而且节省资源。（题目说了data_in变化很慢，至少间隔10个B时钟周期，而且data_en为1至少保持3个B时钟周期） 1234567891011121314151617181920212223242526272829303132333435363738`timescale 1ns/1nsmodule mux( input clk_a , input clk_b , input arstn , input brstn , input [3:0] data_in , input data_en , output reg [3:0] dataout); reg [3:0] data_temp1, data_temp2, data_temp3; always@(posedge clk_a or negedge arstn) begin if(!arstn) data_temp1 &lt;= 4&#x27;d0; else if(data_en) data_temp1 &lt;= data_in; end //对异步信号进行同步处理时，一般采用多级D触发器级联，这样做的好处是，当第一级寄存器产生亚稳态后，第二级寄存器稳定输出概率为90%，第三级为99% always@(posedge clk_b or negedge brstn) begin if(!brstn) begin data_temp2 &lt;= 4&#x27;d0; data_temp3 &lt;= 4&#x27;d0; end else if(data_en) begin data_temp2 &lt;= data_temp1; data_temp3 &lt;= data_temp2; end end always@(posedge clk_b or negedge brstn) begin if(!brstn) dataout &lt;= 4&#x27;d0; else if(data_en) dataout &lt;= data_temp3; endendmodule12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849`timescale 1ns/1nsmodule mux( input clk_a , input clk_b , input arstn , input brstn , input [3:0] data_in , input data_en , output reg [3:0] dataout); //data_in变化很慢才能这样做，否则当使能信号同步到B端时，data_temp1已经发生变化了 reg [3:0] data_temp1; always@(posedge clk_a or negedge arstn) begin if(!arstn) data_temp1 &lt;= 4&#x27;d0; else data_temp1 &lt;= data_in; end reg data_en_a; always@(posedge clk_a or negedge arstn) begin if(!arstn) data_en_a &lt;= 1&#x27;d0; else data_en_a &lt;= data_en; end //同步使能信号 reg data_en_b1, data_en_b2; always@(posedge clk_b or negedge brstn) begin if(!brstn) begin data_en_b1 &lt;= 1&#x27;d0; data_en_b2 &lt;= 1&#x27;d0; end else begin data_en_b1 &lt;= data_en_a; data_en_b2 &lt;= data_en_b1; end end //output always@(posedge clk_b or negedge brstn) begin if(!brstn) dataout &lt;= 4&#x27;d0; else if(data_en_b2) dataout &lt;= data_temp1; else dataout &lt;= dataout; endendmodule VL25 脉冲同步电路题目告知了A时域两个脉冲之间的间隔很大，故不用考虑两个脉冲间隔小于clk_slow的情况 code 12345678910111213141516171819202122232425262728293031323334353637`timescale 1ns/1nsmodule pulse_detect( input clk_fast , input clk_slow , input rst_n , input data_in , output reg dataout); //记录A时域(clk_fast)的脉冲，每产生一次脉冲会让data_fast_temp中电平翻转一次 reg data_fast_temp; //相当于一个扩展信号，把A时域的脉冲展宽至两个相邻脉冲的间隔 always@(posedge clk_fast or negedge rst_n) begin if(~rst_n) data_fast_temp &lt;= 1&#x27;b0; else data_fast_temp &lt;= data_in? ~data_fast_temp : data_fast_temp; end //将data_fast_temp同步到B时域(clk_slow) reg data_slow_temp1, data_slow_temp2; always@(posedge clk_slow or negedge rst_n) begin if(~rst_n) begin data_slow_temp1 &lt;= 1&#x27;b0; data_slow_temp2 &lt;= 1&#x27;b0; end else begin data_slow_temp1 &lt;= data_fast_temp; data_slow_temp2 &lt;= data_slow_temp1; end end //捕捉data_fast_temp的电平翻转，即是脉冲 always@(posedge clk_slow or negedge rst_n) begin if(~rst_n) dataout &lt;= 1&#x27;b0; else dataout &lt;= data_slow_temp1 ^ data_slow_temp2; endendmodule 自用test bench： test bench 1234567891011121314151617181920212223242526272829303132333435363738394041`timescale 1 ps/ 1 ps`define clk_period 20module test_vlg_tst(); reg clk_fast, clk_slow, rst_n, data_in; wire dataout; initial begin clk_fast = 1&#x27;b0; forever #(`clk_period/2) clk_fast = ~clk_fast; // Create clock with period=2 end initial begin clk_slow = 1&#x27;b0; forever #(`clk_period*10/2) clk_slow = ~clk_slow; // Create clock with period=20 end// A testbench test u1( .clk_fast(clk_fast) , .clk_slow(clk_slow), .rst_n(rst_n), .data_in(data_in), .dataout(dataout) ); initial rst_n = 1&#x27;b0; initial #(`clk_period/2) rst_n = 1&#x27;b1; initial begin data_in = 0; repeat(30) begin #(`clk_period*200) data_in = 1; #(`clk_period*1) data_in = 0; #(`clk_period*500) data_in = 1; #(`clk_period*1) data_in = 0; #(`clk_period*300) data_in = 1; #(`clk_period*1) data_in = 0; end #(`clk_period*2000) $stop; endendmodule 波形图： VL27 可置位计数器题目波形可以看出，一定要打一拍，也就是延迟一个时钟信号输出number。 code 1234567891011121314151617181920212223242526272829303132333435`timescale 1ns/1nsmodule count_module( input clk, input rst_n, input set, input [3:0] set_num, output reg [3:0]number, output reg zero ); reg [3:0] num; always@(negedge rst_n or posedge clk)begin if(~rst_n) num &lt;= 0; else if(set) num &lt;= set_num; else if(num==15) num &lt;= 0; else num &lt;= num + 1; end always@(negedge rst_n or posedge clk)begin if(~rst_n) zero &lt;= 0; else if(num==0) zero &lt;= 1; else zero &lt;= 0; end always@(negedge rst_n or posedge clk)begin if(~rst_n) number &lt;= 0; else number &lt;= num; endendmodule VL28 加减计数器code 12345678910111213141516171819202122232425262728293031323334353637383940414243`timescale 1ns/1nsmodule count_module( input clk, input rst_n, input mode, output reg [3:0]number, output reg zero ); reg [3:0] num; always@(negedge rst_n or posedge clk)begin if(~rst_n) num &lt;= 0; else case(mode) 1&#x27;b0: begin //减法mode if(num==0) num &lt;= 9; else num &lt;= num - 1; end 1&#x27;b1: begin //加法mode if(num==9) num &lt;= 0; else num &lt;= num + 1; end endcase end always@(negedge rst_n or posedge clk)begin if(~rst_n) zero &lt;= 0; else if(num==0) zero &lt;= 1; else zero &lt;= 0; end always@(negedge rst_n or posedge clk)begin if(~rst_n) number &lt;= 0; else number &lt;= num; endendmodule VL29 单端口RAMcode 1234567891011121314151617181920212223`timescale 1ns/1nsmodule RAM_1port( input clk, input rst, input enb, input [6:0]addr, input [3:0]w_data, output wire [3:0]r_data);//*************code***********// reg [3:0] RAM_MEM [127:0]; integer i; always@(posedge clk or negedge rst) begin if(~rst) begin for(i=0;i&lt;127;i=i+1) RAM_MEM[i] &lt;= 0; end else if(enb) RAM_MEM[addr] &lt;= w_data; end assign r_data = enb? 0 : RAM_MEM[addr];//*************code***********//endmodule VL30 RAM的简单实现code 1234567891011121314151617181920212223242526272829`timescale 1ns/1nsmodule ram_mod( input clk, input rst_n, input write_en, input [7:0]write_addr, input [3:0]write_data, input read_en, input [7:0]read_addr, output reg [3:0]read_data); reg [3:0] RAM_MEM [255:0]; //2^8 = 256 integer i; always@(posedge clk or negedge rst_n) begin if(~rst_n) for(i = 0; i &lt; 255; i = i + 1) RAM_MEM[i] &lt;= 0; else if(write_en) RAM_MEM[write_addr] &lt;= write_data; end always@(*) begin if(~rst_n) read_data = 0; else if(read_en) read_data = read_en? RAM_MEM[read_addr] : read_data; endendmodule VL31 Johnson Counter （扭环形计数器）code 1234567891011121314`timescale 1ns/1nsmodule JC_counter( input clk , input rst_n, output reg [3:0] Q ); always@(posedge clk or negedge rst_n) begin if(~rst_n) Q = 4&#x27;b0000; else Q = &#123;~Q[0], Q[3:1]&#125;; //在无效态时，不可自启动 endendmodule VL32 流水线乘法器 （待补充）把二进制乘法拆解为每一位相乘，即4’b1010 * 4’b0101 &#x3D;( ‘b0 + ‘b10 + ‘b000 + ‘b1000) * 4’b0101；而二进制数乘以2^N就相当于左移N位，即( ‘b0 + ‘b10 + ‘b000 + ‘b1000) * 4’b0101 &#x3D; ‘b0 + ‘b0101&lt;&lt;1 + ‘b0 + ‘b0101&lt;&lt;3。 code 1//未完成 VL33 交通灯暂存 code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108module triffic_light ( input rst_n, //异位复位信号，低电平有效 input clk, //时钟信号 input pass_request, output wire[7:0]clock, output reg red, output reg yellow, output reg green ); //state machine localparam RED = 0, YELLOW = 1, GREEN = 2; reg [1:0] state, next; //set counter reg [3:0] cnt_red, cnt_yellow, cnt_green_l, cnt_green_h; //red counter 倒计时 always@(posedge clk or negedge rst_n) begin if(~rst_n) cnt_red &lt;= 10; else if(next == RED) begin //红灯时计时 cnt_red &lt;= cnt_red - 1&#x27;b1; //到0后发生状态转换，不需要借位 end else cnt_red &lt;= 10; end //yellow counter 倒计时 always@(posedge clk or negedge rst_n) begin if(~rst_n) cnt_yellow &lt;= 5; else if(next == YELLOW) //黄灯时计时 cnt_yellow &lt;= cnt_yellow - 1&#x27;b1; //到0后发生状态转换，不需要借位 else cnt_yellow &lt;= 5; end //green counter 倒计时 always@(posedge clk or negedge rst_n) begin if(~rst_n) cnt_green_l &lt;= 0; else if(next == GREEN) begin //绿灯时计时 if((cnt_green_h != 0) &amp;&amp; pass_request) cnt_green_l &lt;= 9; else if(cnt_green_l == 0) //减到0借位 cnt_green_l &lt;= 9; else cnt_green_l &lt;= cnt_green_l - 1&#x27;b1; end else cnt_green_l &lt;= 0; end always@(posedge clk or negedge rst_n) begin if(~rst_n) cnt_green_h &lt;= 6; //从60开始倒计时 else if(next == GREEN) begin //绿灯时计时 if((cnt_green_h != 0) &amp;&amp; pass_request) cnt_green_h &lt;= 0; else if(cnt_green_l == 0) cnt_green_h &lt;= cnt_green_h - 1&#x27;b1; //高位等于0后如果低位等于0会发生状态转换，故不需要借位 end else cnt_green_h &lt;= 6; end //state transition always@(*) begin case(state) RED: next = (cnt_red == 0) ? GREEN : RED; GREEN: next = ((cnt_green_l==0)&amp;(cnt_green_h==0)) ? YELLOW : GREEN; YELLOW: next = (cnt_yellow == 0) ? RED : YELLOW; default: next = RED; endcase end //state flip-flops always@(posedge clk or negedge rst_n) begin if(~rst_n) state &lt;= RED; else state &lt;= next; end //output always@(posedge clk or negedge rst_n) begin if(~rst_n) begin red &lt;= 0; yellow &lt;= 0; green &lt;= 0; end else case(next) RED: begin red &lt;= 1; yellow &lt;= 0; green &lt;= 0; end YELLOW: begin red &lt;= 0; yellow &lt;= 1; green &lt;= 0; end GREEN: begin red &lt;= 0; yellow &lt;= 0; green &lt;= 1; end endcase end //outputclock assign clock = (state == RED) ? &#123;4&#x27;d0, cnt_red&#125; : (state == YELLOW) ? &#123;4&#x27;d0, cnt_yellow&#125; : (state == GREEN) ? &#123;cnt_green_h, cnt_green_l&#125; : 8&#x27;d0;endmodule VL34 游戏机计费程序code 题目答案波形可以看出，加钱的时候不扣钱，这是否… 12345678910111213141516171819202122232425262728293031323334353637383940414243`timescale 1ns/1nsmodule game_count ( input rst_n, //异位复位信号，低电平有效 input clk, //时钟信号 input [9:0]money, input set, input boost, output reg[9:0]remain, output reg yellow, output reg red ); //每个时钟周期代表一分钟 always@(posedge clk or negedge rst_n) begin if(~rst_n) remain &lt;= 0; else casex(&#123;set, boost&#125;) 2&#x27;b1x: remain &lt;= remain + money; 2&#x27;b01: remain &lt;= remain - 2; 2&#x27;b00: remain &lt;= remain - 1; default: ; endcase end //output yellow, red always@(posedge clk or negedge rst_n) begin if(~rst_n) begin yellow &lt;= 0; red &lt;= 0; end else if(remain == 0) begin yellow &lt;= 0; red &lt;= 1; end else if(remain &lt; 10) begin yellow &lt;= 1; red &lt;= 0; end else begin yellow &lt;= 0; red &lt;= 0; end endendmodule","categories":[],"tags":[{"name":"Verilog","slug":"Verilog","permalink":"http://example.com/tags/Verilog/"}]},{"title":"C++笔记（六）——标准库类型vector","slug":"cpp/cpp-note-6","date":"2022-04-29T06:31:39.000Z","updated":"2022-05-01T14:12:00.555Z","comments":true,"path":"2022/04/29/cpp/cpp-note-6/","link":"","permalink":"http://example.com/2022/04/29/cpp/cpp-note-6/","excerpt":"标准库类型vectorvector表示对象的集合，其中所有的对象类型都相同。集合中每个对象都有一个与之对应的索引，索引用于访问对象。因为vector“容纳着”其他对象，所以它也被称为**容器(container)**。 12#include &lt;vector&gt; //一定要包含vector头文件using std::vector; C++语音既有类模板(class template)，也有函数模板，其中vector是一个类模板。模板本身不是类或函数，可以将模板看做编译器生成类或函数编写的一份说明。 12345//vector是模板而非类型，由vector生成的类型必须包含vector中元素的类型vector&lt;int&gt; ivec; //ivec保存int类型对象，初始化为空vectorvector&lt;Sales_item&gt; Sales_vec; //保存Sales_item类型对象vector&lt;vector&lt;string&gt;&gt; file; //该向量的元素是vector对象，该语句为C++11的定义形式vector&lt;vector&lt;string&gt; &gt; file; //老式定义形式，多一个空格，即vector&lt;vector&lt;string&gt;(空格)&gt; 注意，引用本身不是对象，所以不可以称为vector的元素。 定义和初始化vector对象除了与string对象类似的几种初始化方式外，vector还有列表初始化： 1vector&lt;string&gt; v1&#123;&quot;a&quot;, &quot;an&quot;, &quot;the&quot;&#125;; //必须使用花括号 注意：区分列表初始化使用的花括号和直接初始化使用的圆括号。","text":"标准库类型vectorvector表示对象的集合，其中所有的对象类型都相同。集合中每个对象都有一个与之对应的索引，索引用于访问对象。因为vector“容纳着”其他对象，所以它也被称为**容器(container)**。 12#include &lt;vector&gt; //一定要包含vector头文件using std::vector; C++语音既有类模板(class template)，也有函数模板，其中vector是一个类模板。模板本身不是类或函数，可以将模板看做编译器生成类或函数编写的一份说明。 12345//vector是模板而非类型，由vector生成的类型必须包含vector中元素的类型vector&lt;int&gt; ivec; //ivec保存int类型对象，初始化为空vectorvector&lt;Sales_item&gt; Sales_vec; //保存Sales_item类型对象vector&lt;vector&lt;string&gt;&gt; file; //该向量的元素是vector对象，该语句为C++11的定义形式vector&lt;vector&lt;string&gt; &gt; file; //老式定义形式，多一个空格，即vector&lt;vector&lt;string&gt;(空格)&gt; 注意，引用本身不是对象，所以不可以称为vector的元素。 定义和初始化vector对象除了与string对象类似的几种初始化方式外，vector还有列表初始化： 1vector&lt;string&gt; v1&#123;&quot;a&quot;, &quot;an&quot;, &quot;the&quot;&#125;; //必须使用花括号 注意：区分列表初始化使用的花括号和直接初始化使用的圆括号。 值初始化(value-initialized)，即只声明vector对象容纳的元素数量，由库创建元素初值： 123//初值根据元素的类型来决定vector&lt;int&gt; ivec(10); //10个元素，全部初始化为0vector&lt;string&gt; svec(10); //10个元素，全部初始化为空string 当花括号中元素不能列表初始化vector时，编译器会尝试用默认值初始化： 12vector&lt;string&gt; v2&#123;10&#125;; //10是int，不能初始化string元素，结果：等价于vector&lt;string&gt; v2(10)vector&lt;string&gt; v2&#123;10, &quot;hi&quot;&#125;; //同理，等价于vector&lt;string&gt; v2(10, &quot;hi&quot;) 向vector中添加元素利用vector的成员函数push_back向其中添加元素： 12345string word;vector&lt;string&gt; text;while (cin &gt;&gt; word) &#123; //输入为string对象时执行&#123;&#125;内语句 text.push_back(word); //将word添加到text中&#125; 注意：vector对象能高效增长，因此在定义vector对象时设定其大小没有什么必要，事实上如果这么做性能可能更差。同时，高效便捷地向vector中添加元素，要求编写程序时确保所写的循环正确无误，**尤其是可能改变vector对象容量的循环**，如：for语句体内不应该改变其所遍历序列的大小，范围for循环内不能像vector添加元素。如果容器的容量不确定，则不能说遍历。 其他vector操作v.empty()：若v中不含任何元素，返回真；否则返回假 v.size()：返回v中元素个数 下标： 使用下标的时候必须验证其是否在合理范围内。 不能用下标形式添加元素 练习3.17 123456789101112131415161718192021#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; vector&lt;string&gt; svec; string word; while (cin &gt;&gt; word) &#123; if (!word.empty()) svec.push_back(word); &#125; for (decltype(svec.size()) i = 0; i != svec.size(); ++i) &#123; auto&amp; temp = svec[i]; for (decltype(temp.size())j = 0; j != temp.size(); ++j)&#123; auto&amp; temp2 = temp[j]; temp2 = toupper(temp2); &#125; cout &lt;&lt; svec[i] &lt;&lt; endl; &#125; return 0;&#125; 参考方法： 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;void main()&#123; vector&lt;string&gt; My_vector; string istring; while (cin &gt;&gt; istring) &#123; My_vector.push_back(istring); &#125; for (int i = 0;i &lt; My_vector.size();i++) for (int j = 0;j &lt; My_vector[i].length();j++) //length()函数也能得到string的长度 &#123; My_vector[i][j] = toupper(My_vector[i][j]); &#125; for (int i = 0;i &lt; My_vector.size();i++) &#123; cout&lt;&lt;My_vector[i]&lt;&lt;endl; &#125;&#125; 练习3.20 12345678910111213141516171819202122232425262728293031323334//第一问#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int i = 0; vector&lt;int&gt; ivec; while (cin &gt;&gt; i) &#123; ivec.push_back(i); &#125; for (int j = 0; j &lt; ivec.size() - 1; ++j) &#123; cout &lt;&lt; ivec[j] + ivec[j + 1] &lt;&lt; endl; &#125; return 0;&#125;//第二问int main() &#123; int i = 0; vector&lt;int&gt; ivec; while (cin &gt;&gt; i) &#123; ivec.push_back(i); &#125; if (ivec.size() % 2)&#123; for (int j = 0; j &lt; (ivec.size() - 1) / 2; ++j) cout &lt;&lt; ivec[j] + ivec[ivec.size() - 1 - j] &lt;&lt; endl; cout &lt;&lt; ivec[(ivec.size() - 1) / 2] &lt;&lt; endl; &#125; else&#123; for (int j = 0; j &lt; ivec.size() / 2; ++j) cout &lt;&lt; ivec[j] + ivec[ivec.size() - 1 - j] &lt;&lt; endl; &#125; return 0;&#125; 参考方法： 1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; arr; //创立一个对象为整数的vector int num; while (cin &gt;&gt; num) //循环给vector赋值，当输入0时退出循环 &#123; arr.push_back(num); &#125; int sum;//用于统计两个相邻整数的和 for (int i = 0, j = arr.size() - 1; i &lt; j; i++, j--)&#123; //循环计算首尾依次相加 sum = arr[i] + arr[j]; //原来for还可以这么用 cout &lt;&lt; sum &lt;&lt; &quot; &quot;; &#125; if (arr.size() % 2 == 1) //如果数量为奇的话，则最后输出中间值 cout &lt;&lt; arr[(arr.size() - 1) / 2]; cout &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++笔记（五）——标准库类型string","slug":"cpp/cpp-note-5","date":"2022-04-27T15:01:00.000Z","updated":"2022-05-01T13:47:53.817Z","comments":true,"path":"2022/04/27/cpp/cpp-note-5/","link":"","permalink":"http://example.com/2022/04/27/cpp/cpp-note-5/","excerpt":"字符串、向量和数组命名空间的using声明： 12using namespaece std; //using声明，获取std中的所有名字using std::cin; //using声明，当我们使用名字cin时，从std中获取它 标准库类型string12#include &lt;string&gt; //一定要包含string头文件using std::string; 定义和初始化string对象几个初始化方式： 1234567string s1; //默认初始化，s1是一个空串string s2(s1); //直接初始化(direct initialization)，s2是s1的副本string s2 = s1; //拷贝初始化(copy initialization)，s2是s1的副本string s3(&quot;value&quot;); //直接初始化，s3是字面值&quot;value&quot;的副本，除了字面值最后的那个空字符外string s3 = &quot;value&quot;; //拷贝初始化，s3是字面值&quot;value&quot;的副本string s4(n, &#x27;c&#x27;); //直接初始化，s4是由连续n个字符c组成的串string s5 = string(10,&#x27;c&#x27;) //拷贝初始化，创建了一个临时对象用于拷贝，s5内容是cccccccccc string对象上的操作读入数量未知的string对象：","text":"字符串、向量和数组命名空间的using声明： 12using namespaece std; //using声明，获取std中的所有名字using std::cin; //using声明，当我们使用名字cin时，从std中获取它 标准库类型string12#include &lt;string&gt; //一定要包含string头文件using std::string; 定义和初始化string对象几个初始化方式： 1234567string s1; //默认初始化，s1是一个空串string s2(s1); //直接初始化(direct initialization)，s2是s1的副本string s2 = s1; //拷贝初始化(copy initialization)，s2是s1的副本string s3(&quot;value&quot;); //直接初始化，s3是字面值&quot;value&quot;的副本，除了字面值最后的那个空字符外string s3 = &quot;value&quot;; //拷贝初始化，s3是字面值&quot;value&quot;的副本string s4(n, &#x27;c&#x27;); //直接初始化，s4是由连续n个字符c组成的串string s5 = string(10,&#x27;c&#x27;) //拷贝初始化，创建了一个临时对象用于拷贝，s5内容是cccccccccc string对象上的操作读入数量未知的string对象： 1234567int main()&#123; string word; while(cin &gt;&gt; word) //反复读取，直到输入文件结束标记 cout &lt;&lt; word &lt;&lt; endl; //逐个输出单词，每个单词之间有一个换行符 return 0;&#125; 读取整行： 1234567int main()&#123; string line; while(getline(cin, line)) //如果输入换行符，会直接结束读取，并返回结果（结果为空string） cout &lt;&lt; line &lt;&lt; endl; //触发getline的换行符被丢弃掉了，所以手动加上换行符 return 0;&#125; empty根据string是否为空返回一个布尔值，可以用来筛除空string： 1234567int main() &#123; string line; while (getline(cin,line)) if(!line.empty()) //只有当line是非空string时，才会执行输出 cout &lt;&lt; line &lt;&lt; endl; return 0;&#125; size返回一个size_type类型的值，表示string对象的大小，它是一个无符号的值： 1auto len = line.size(); //len的类型是string::size_type 切记，表达式中混用带符号数和无符号数时，带符号数会自动转换成无符号数，负值会转换成（负值+无符号数的模） （int是有符号数） 字面值和string对象相加： 123456//必须确保+两侧的对象至少有一个是stringstring s1 = &quot;hello&quot;, s2 = &quot;world&quot;;string s3 = s1 + &quot;, &quot; + s2 + &#x27;\\n&#x27;; //正确string s4 = &quot;hello&quot; + &quot;, &quot; + s2; //错误：不能把字面值直接相加string s4 = (&quot;hello&quot; + &quot;, &quot;) + s2; //按照加法运算符的工作机理，上一条语句与这条语句等价string s5 = s1 + &quot;, &quot; + &quot;world&quot;; //正确 由于历史原因，也为了与C兼容，C++中字符串字面值并不是string对象，它们是不同的类型 练习3.5 12345678910#include &lt;string&gt;using namespace std;int main() &#123; string total, s_in; while (cin &gt;&gt; s_in) &#123; total = total + &quot; &quot; + s_in; &#125; cout &lt;&lt; total &lt;&lt; endl; return 0;&#125; 处理string对象中的字符C++11新标准：范围for语句(range for)： 12for (auto c : &quot;some string&quot;) //每次迭代，都把&quot;&quot;中的下一个字符拷贝给c cout &lt;&lt; c &lt;&lt; endl; 统计string中的标点符号数： 123456string s(&quot;Hello World!!!&quot;);decltype(s.size()) punct_cnt = 0; //定义punct_cnt为size_type类型for (auto c : s) if (ispunct(c)) //ispunct()函数在&lt;cctype&gt;中，&lt;string&gt;已经包含了&lt;cctype&gt; ++punct_cnt;cout &lt;&lt; punct_cnt &lt;&lt; &quot; punctuation characters in &quot; &lt;&lt; s &lt;&lt; endl; 改变string中字符的值： 1234string s(&quot;Hello World!!!&quot;);for (auto&amp; c : s) //c是对s中某个字符的引用 c = toupper(c); //通过c来将s中的字符改为大写，toupper()是&lt;ctype.h&gt;中函数，&lt;cctype&gt;中已经包含了&lt;ctype.h&gt;cout &lt;&lt; s &lt;&lt; endl; 利用下标运算符处理string的部分字符： 12345string s1(&quot;some string&quot;);if (!s1.empty())&#123; //下标取值范围是[0, s1.size()-1]，超出此范围会读出未知结果 s1[0] = toupper(s1[0]); //将s1的第一个字符赋值为大写 cout &lt;&lt; s1[0] &lt;&lt; endl; //输出s1的第一个字符&#125; 还有一种处理部分字符的方式是使用迭代器，暂不介绍。 使用下标执行迭代： 1234string s(&quot;Hello World&quot;);for (decltype(s.size()) index = 0; index != s.size() &amp;&amp; !isspace(s[index]); ++index) s[index] = toupper(s[index]);cout &lt;&lt; s &lt;&lt; endl; //输出结果为HELLO World 注意，C++中&amp;&amp; 运算符只有在左侧运算对象为真时，才会检查右侧的运算对象，上述写法中保证了下标取值合理时才访问s[index]。 使用下标执行随机访问： 12345678const string hexdigits = &quot;0123456789ABCDEF&quot;;cout &lt;&lt; &quot;Enter a series of numbers between 0 and 15&quot; &lt;&lt; endl;string result; //初始化为空stringstring::size_type n; //定义n为size_type类型，但注意此处并没有初始化while (cin &gt;&gt; n) if (n &lt; hexdigits.size()) result += hexdigits[n]; //根据输入来拼接resultcout &lt;&lt; &quot;Your hex number is: &quot; &lt;&lt; result &lt;&lt; endl; 练习3.6 1234567891011#include &lt;string&gt; //&lt;string&gt;里面已经包含了&lt;cctype&gt;#include &lt;iostream&gt;using namespace std;int main() &#123; string str; cin &gt;&gt; str; for (auto&amp; c : str) c = &#x27;X&#x27;; cout &lt;&lt; str; return 0;&#125; 练习3.9 不合法，s为空字符串，第一个元素是未知的，虽然vs2022中会输出一个空字符，但是不同机器上得到的结果可能会不同。 练习3.10 但是好像并不能识别中文的标点 123456789101112#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main() &#123; string str, result; cin &gt;&gt; str; for (auto c : str) if (!ispunct(c)) result += c; cout &lt;&lt; result &lt;&lt; endl; return 0;&#125; 练习3.11 c是const char&amp;类型的值，for语句块中不给c赋值的话就合法，否则不合法。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"牛客网Verilog刷题笔记1","slug":"nowcoder/nowcoder1-verilog24","date":"2022-04-26T10:12:24.000Z","updated":"2022-05-04T15:54:04.590Z","comments":true,"path":"2022/04/26/nowcoder/nowcoder1-verilog24/","link":"","permalink":"http://example.com/2022/04/26/nowcoder/nowcoder1-verilog24/","excerpt":"VL24 边沿检测code 1234567891011121314151617181920212223242526272829`timescale 1ns/1nsmodule edge_detect( input clk, input rst_n, input a, output reg rise, output reg down); reg past; always@(posedge clk or negedge rst_n) begin if(~rst_n) past &lt;= 1&#x27;b0; else past &lt;= a; end always@(posedge clk or negedge rst_n) begin if(~rst_n) begin rise &lt;= 1&#x27;b0; down &lt;= 1&#x27;b0; end else begin rise &lt;= ((~past &amp; a) === 1&#x27;b1)? 1 : 0; //使用全等于，避免未知态带来的影响 down &lt;= ((past &amp; ~a) === 1&#x27;b1)? 1 : 0; end endendmodule 进阶挑战VL2 含有无关项的序列检测code 123456789101112131415161718192021222324252627`timescale 1ns/1nsmodule sequence_detect( input clk, input rst_n, input a, output reg match ); //因为存在三位无关项，用状态机需要用到太多状态了，实现起来较为困难 //故使用9位移位寄存器实现 reg [8:0] data; always @(posedge clk or negedge rst_n) begin if (~rst_n) data &lt;= 9&#x27;d0; else data &lt;=&#123;data[7:0], a&#125;; end always @(posedge clk or negedge rst_n) begin if (~rst_n) match &lt;= 1&#x27;b0; else if ((data[8:6]==3&#x27;b011)&amp;(data[2:0]==3&#x27;b110)) //中间三项为无关项 match &lt;= 1&#x27;b1; else match &lt;= 1&#x27;b0; endendmodule VL3 不重叠序列检测移位寄存器方法code 123456789101112131415161718192021222324252627282930313233343536373839404142434445`timescale 1ns/1nsmodule sequence_detect( input clk, input rst_n, input data, output reg match, output reg not_match ); //counter reg [2:0] cnt; always@(posedge clk or negedge rst_n) begin if(~rst_n) cnt &lt;= 3&#x27;d0; else if(cnt == 3&#x27;d6) cnt &lt;= 3&#x27;d1; else cnt &lt;= cnt + 1&#x27;b1; end //shifting register reg [5:0] data_in; always@(posedge clk or negedge rst_n) begin if(~rst_n) data_in &lt;= 6&#x27;d0; else data_in &lt;= &#123;data_in[4:0], data&#125;; end //output always@(*) begin if(cnt == 3&#x27;d6) case(data_in) 6&#x27;b011100: begin match &lt;= 1&#x27;b1; not_match &lt;= 1&#x27;b0; end default: begin match &lt;= 1&#x27;b0; not_match &lt;= 1&#x27;b1; end endcase else begin match &lt;= 1&#x27;b0; not_match &lt;= 1&#x27;b0; end endendmodule 状态机方法code 用状态机方法还是会用到计数器，个人感觉移位寄存器方法要更简单一点，以下是状态机方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667`timescale 1ns/1nsmodule sequence_detect( input clk, input rst_n, input data, output reg match, output reg not_match ); //state machine //counter reg [2:0] cnt; always@(posedge clk or negedge rst_n) begin if(~rst_n) cnt &lt;= 3&#x27;d0; else if(cnt == 3&#x27;d6) cnt &lt;= 3&#x27;d1; else cnt &lt;= cnt + 1&#x27;b1; end //set state localparam IDLE = 0, S0 = 1, S01 = 2, S011 = 3, S0111 = 4, S01110 = 5, S011100 = 6, SErro = 7; reg [2:0] state , next; //state transition always@(*) begin case(state) IDLE : next = data ? SErro : S0; SErro : begin if(cnt == 3&#x27;d6) next = data ? SErro : S0; else next = SErro; end S0 : next = data ? S01 : SErro; S01 : next = data ? S011 : SErro; S011 : next = data ? S0111: SErro; S0111 : next = data ? SErro: S01110; S01110 : next = data ? SErro: S011100; S011100: next = data ? SErro: S0; endcase end //state flip-flops always@(posedge clk or negedge rst_n) begin if(~rst_n) state &lt;= IDLE; else state &lt;= next; end //output always@(*) begin if(~rst_n) begin match &lt;= 1&#x27;b0; not_match &lt;= 1&#x27;b0; end else if(state == S011100) begin match &lt;= 1&#x27;b1; not_match &lt;= 1&#x27;b0; end else if ((state == SErro)&amp;(cnt == 3&#x27;d6)) begin match &lt;= 1&#x27;b0; not_match &lt;= 1&#x27;b1; end else begin match &lt;= 1&#x27;b0; not_match &lt;= 1&#x27;b0; end endendmodule","text":"VL24 边沿检测code 1234567891011121314151617181920212223242526272829`timescale 1ns/1nsmodule edge_detect( input clk, input rst_n, input a, output reg rise, output reg down); reg past; always@(posedge clk or negedge rst_n) begin if(~rst_n) past &lt;= 1&#x27;b0; else past &lt;= a; end always@(posedge clk or negedge rst_n) begin if(~rst_n) begin rise &lt;= 1&#x27;b0; down &lt;= 1&#x27;b0; end else begin rise &lt;= ((~past &amp; a) === 1&#x27;b1)? 1 : 0; //使用全等于，避免未知态带来的影响 down &lt;= ((past &amp; ~a) === 1&#x27;b1)? 1 : 0; end endendmodule 进阶挑战VL2 含有无关项的序列检测code 123456789101112131415161718192021222324252627`timescale 1ns/1nsmodule sequence_detect( input clk, input rst_n, input a, output reg match ); //因为存在三位无关项，用状态机需要用到太多状态了，实现起来较为困难 //故使用9位移位寄存器实现 reg [8:0] data; always @(posedge clk or negedge rst_n) begin if (~rst_n) data &lt;= 9&#x27;d0; else data &lt;=&#123;data[7:0], a&#125;; end always @(posedge clk or negedge rst_n) begin if (~rst_n) match &lt;= 1&#x27;b0; else if ((data[8:6]==3&#x27;b011)&amp;(data[2:0]==3&#x27;b110)) //中间三项为无关项 match &lt;= 1&#x27;b1; else match &lt;= 1&#x27;b0; endendmodule VL3 不重叠序列检测移位寄存器方法code 123456789101112131415161718192021222324252627282930313233343536373839404142434445`timescale 1ns/1nsmodule sequence_detect( input clk, input rst_n, input data, output reg match, output reg not_match ); //counter reg [2:0] cnt; always@(posedge clk or negedge rst_n) begin if(~rst_n) cnt &lt;= 3&#x27;d0; else if(cnt == 3&#x27;d6) cnt &lt;= 3&#x27;d1; else cnt &lt;= cnt + 1&#x27;b1; end //shifting register reg [5:0] data_in; always@(posedge clk or negedge rst_n) begin if(~rst_n) data_in &lt;= 6&#x27;d0; else data_in &lt;= &#123;data_in[4:0], data&#125;; end //output always@(*) begin if(cnt == 3&#x27;d6) case(data_in) 6&#x27;b011100: begin match &lt;= 1&#x27;b1; not_match &lt;= 1&#x27;b0; end default: begin match &lt;= 1&#x27;b0; not_match &lt;= 1&#x27;b1; end endcase else begin match &lt;= 1&#x27;b0; not_match &lt;= 1&#x27;b0; end endendmodule 状态机方法code 用状态机方法还是会用到计数器，个人感觉移位寄存器方法要更简单一点，以下是状态机方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667`timescale 1ns/1nsmodule sequence_detect( input clk, input rst_n, input data, output reg match, output reg not_match ); //state machine //counter reg [2:0] cnt; always@(posedge clk or negedge rst_n) begin if(~rst_n) cnt &lt;= 3&#x27;d0; else if(cnt == 3&#x27;d6) cnt &lt;= 3&#x27;d1; else cnt &lt;= cnt + 1&#x27;b1; end //set state localparam IDLE = 0, S0 = 1, S01 = 2, S011 = 3, S0111 = 4, S01110 = 5, S011100 = 6, SErro = 7; reg [2:0] state , next; //state transition always@(*) begin case(state) IDLE : next = data ? SErro : S0; SErro : begin if(cnt == 3&#x27;d6) next = data ? SErro : S0; else next = SErro; end S0 : next = data ? S01 : SErro; S01 : next = data ? S011 : SErro; S011 : next = data ? S0111: SErro; S0111 : next = data ? SErro: S01110; S01110 : next = data ? SErro: S011100; S011100: next = data ? SErro: S0; endcase end //state flip-flops always@(posedge clk or negedge rst_n) begin if(~rst_n) state &lt;= IDLE; else state &lt;= next; end //output always@(*) begin if(~rst_n) begin match &lt;= 1&#x27;b0; not_match &lt;= 1&#x27;b0; end else if(state == S011100) begin match &lt;= 1&#x27;b1; not_match &lt;= 1&#x27;b0; end else if ((state == SErro)&amp;(cnt == 3&#x27;d6)) begin match &lt;= 1&#x27;b0; not_match &lt;= 1&#x27;b1; end else begin match &lt;= 1&#x27;b0; not_match &lt;= 1&#x27;b0; end endendmodule VL4 输入序列不连续的序列检测code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364`timescale 1ns/1nsmodule sequence_detect( input clk, input rst_n, input data, input data_valid, output reg match ); //state machine //set state localparam IDLE = 0, S0 = 1, S01 = 2, S011 = 3, S0110 = 4; reg [2:0] state, next; //state transition always@(*) begin case(state) IDLE: begin if(data_valid) next = data ? IDLE : S0; else next = IDLE; end S0: begin if(data_valid) next = data ? S01 : S0; else next = IDLE; end S01: begin if(data_valid) next = data ? S011 : S0; else next = IDLE; end S011: begin if(data_valid) next = data ? IDLE : S0110; else next = IDLE; end S0110: begin if(data_valid) next = data ? S01 : S0; else next = IDLE; end endcase end //state flip-flops always@(posedge clk or negedge rst_n) begin if(~rst_n) state &lt;= IDLE; else state &lt;= next; end //output always@(posedge clk or negedge rst_n) begin if(~rst_n) match &lt;= 1&#x27;b0; else case(next) S0110: match &lt;= 1&#x27;b1; default: match &lt;= 1&#x27;b0; endcase endendmodule VL5 信号发生器 （这道题蛮难的）code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758`timescale 1ns/1nsmodule signal_generator( input clk, input rst_n, input [1:0] wave_choise, output reg [4:0]wave ); //counter (only for retangular wave) reg [4:0] cnt; always@(posedge clk or negedge rst_n) begin if(~rst_n | (wave_choise != 2&#x27;b00)) cnt &lt;= 5&#x27;d0; else if(cnt == 5&#x27;d19) cnt &lt;= 5&#x27;d0; else cnt &lt;= cnt + 1&#x27;b1; end //delta wave flag (only for delta wave) reg flag; always@(posedge clk or negedge rst_n) begin if(~rst_n | (wave_choise != 2&#x27;b10)) flag &lt;= 1&#x27;b1; else if(wave == 5&#x27;d1) flag &lt;= 1&#x27;b0; else if(wave == 5&#x27;d19) flag &lt;= 1&#x27;b1; end //output always@(posedge clk or negedge rst_n) begin if(~rst_n) wave &lt;= 5&#x27;d0; else case(wave_choise) 2&#x27;b00: begin if(cnt == 5&#x27;d19) wave &lt;= 5&#x27;d0; else if(cnt == 5&#x27;d9) wave &lt;= 5&#x27;d20; end 2&#x27;b01: begin if(wave == 5&#x27;d20) wave &lt;= 5&#x27;d0; else wave &lt;= wave + 1&#x27;b1; end 2&#x27;b10: begin if(wave == 5&#x27;d20) //考虑到刚好在wave=20以及wave=0时发生波形变化 wave &lt;= wave - 1&#x27;b1; // else if(wave == 5&#x27;d0) // wave &lt;= wave + 1&#x27;b1; // else if(flag) wave &lt;= wave - 1&#x27;b1; else wave &lt;= wave + 1&#x27;b1; end default: wave &lt;= 5&#x27;d0; endcase endendmodule VL6 数据串转并电路code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657`timescale 1ns/1nsmodule s_to_p( input clk , input rst_n , input valid_a , input data_a , output reg ready_a , output reg valid_b , output reg [5:0] data_b); //根据题意，一直拉高ready_a always@(posedge clk or negedge rst_n) begin if(~rst_n) ready_a &lt;= 1&#x27;b0; else ready_a &lt;= 1&#x27;b1; end //counter reg [2:0] cnt; always@(posedge clk or negedge rst_n) begin if(~rst_n) cnt &lt;= 3&#x27;d0; else if(valid_a &amp; ready_a) begin //输入数据有效时，counter才开始计数 if(cnt == 3&#x27;d5) cnt &lt;= 3&#x27;d0; else cnt &lt;= cnt + 1&#x27;b1; end else cnt &lt;= cnt; end //6-bit shifting register reg [5:0] data_temp; always@(posedge clk or negedge rst_n) begin if(~rst_n) data_temp &lt;= 6&#x27;b0; else if(valid_a &amp; ready_a) data_temp &lt;= &#123;data_a, data_temp[5:1]&#125;; //最新的输入数据存放在最高位 end //output always@(posedge clk or negedge rst_n) begin if(~rst_n) begin valid_b &lt;= 1&#x27;b0; data_b &lt;= 6&#x27;b000000; end else if(cnt == 3&#x27;d5) begin valid_b &lt;= 1&#x27;b1; data_b &lt;= &#123;data_a, data_temp[5:1]&#125;; //此时的输出应当是最新的1位输入和计数时暂存的5位拼接而成 end else begin valid_b &lt;= 1&#x27;b0; data_b &lt;= data_b; end endendmodule VL7 数据累加输出 （抄的答案，这题还需加深理解）code 1234567891011121314151617181920212223242526272829303132333435363738394041`timescale 1ns/1nsmodule valid_ready( input clk , input rst_n , input [7:0] data_in , input valid_a , input ready_b , output ready_a , output reg valid_b , output reg [9:0] data_out); reg [1:0] data_cnt; assign ready_a = ~valid_b | ready_b; //表示下游准备好接受本模块的输出或者本模块还没有产生有效输出时，本模块可以接受上游的输出。如此保证不会产生数据丢失，且保持本模块保持满速。 always @(posedge clk or negedge rst_n ) begin if(~rst_n) data_cnt &lt;= &#x27;d0; else if(valid_a &amp;&amp; ready_a) data_cnt &lt;= (data_cnt == 2&#x27;d3) ? &#x27;d0 : (data_cnt + 1&#x27;d1); end always @(posedge clk or negedge rst_n ) begin if(~rst_n) valid_b &lt;= &#x27;d0; else if(data_cnt == 2&#x27;d3 &amp;&amp; valid_a &amp;&amp; ready_a) valid_b &lt;= 1&#x27;d1; else if(valid_b &amp;&amp; ready_b) valid_b &lt;= 1&#x27;d0; end always @(posedge clk or negedge rst_n ) begin if(~rst_n) data_out &lt;= &#x27;d0; else if(ready_b &amp;&amp; valid_a &amp;&amp; ready_a &amp;&amp; (data_cnt == 2&#x27;d0)) data_out &lt;= data_in; else if(valid_a &amp;&amp; ready_a) data_out &lt;= data_out + data_in; endendmodule VL8 非整数倍数据位宽转换24to128 （看懂了VL7，这题就感觉蛮简单了）Solution 1Solution2折叠表格123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566`timescale 1ns/1nsmodule width_24to128( input clk , input rst_n , input valid_in , input [23:0] data_in , output reg valid_out , output reg [127:0] data_out); //16-counter reg [3:0] cnt; always@(posedge clk or negedge rst_n) begin if(~rst_n) cnt &lt;= 4&#x27;b0; else if(valid_in) cnt &lt;= cnt + 1&#x27;b1; end //output valid_out always@(posedge clk or negedge rst_n) begin if(~rst_n) valid_out &lt;= 1&#x27;b0; else if((cnt == 4&#x27;d5)|(cnt == 4&#x27;d10)|(cnt == 4&#x27;d15)) valid_out &lt;= 1&#x27;b1; else valid_out &lt;= 1&#x27;b0; end //output data reg [23:0] data_temp1; //设置data_temp1用以缓存一个data_in always@(posedge clk or negedge rst_n) begin if(~rst_n) data_temp1 &lt;= 24&#x27;b0; else if(valid_in) data_temp1 &lt;= data_in; end reg [128:0] data_temp2; //设置data_temp2只是为了迎合牛客网的tb，它的tb要求在输出无效时，输出必须为0，故用data_temp2作为移位寄存器 always@(posedge clk or negedge rst_n) begin if(~rst_n) data_temp2 &lt;= 128&#x27;b0; else if(valid_in) begin if(cnt == 4&#x27;d5) data_temp2 &lt;= &#123;data_temp2[119:0], data_in[23:16]&#125;; //5*24 + 8 = 128 else if(cnt == 4&#x27;d6) data_temp2 &lt;= &#123;data_temp2[87:0], data_temp1[15:0], data_in&#125;; else if(cnt == 4&#x27;d10) data_temp2 &lt;= &#123;data_temp2[111:0], data_in[23:8]&#125;; //16 + 24*4 + 16 = 128 else if(cnt == 4&#x27;d11) data_temp2 &lt;= &#123;data_temp2[95:0], data_temp1[7:0], data_in&#125;; else data_temp2 &lt;= &#123;data_temp2[103:0], data_in&#125;; //8 + 24*5 = 128 end end always@(posedge clk or negedge rst_n) begin if(~rst_n) data_out &lt;= 128&#x27;b0; else if(valid_in) begin if(cnt == 4&#x27;d5) data_out &lt;= &#123;data_temp2[119:0], data_in[23:16]&#125;; //5*24 + 8 = 128 else if(cnt == 4&#x27;d10) data_out &lt;= &#123;data_temp2[111:0], data_in[23:8]&#125;; //16 + 24*4 + 16 = 128 else if(cnt == 4&#x27;d15) data_out &lt;= &#123;data_temp2[103:0], data_in&#125;; //8 + 24*5 = 128 end endendmodule修改后占用资源更少： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152`timescale 1ns/1nsmodule width_24to128( input clk , input rst_n , input valid_in , input [23:0] data_in , output reg valid_out , output reg [127:0] data_out); //16-counter reg [3:0] cnt; always@(posedge clk or negedge rst_n) begin if(~rst_n) cnt &lt;= 4&#x27;b0; else if(valid_in) cnt &lt;= cnt + 1&#x27;b1; end //output valid_out always@(posedge clk or negedge rst_n) begin if(~rst_n) valid_out &lt;= 1&#x27;b0; else if((cnt == 4&#x27;d5)|(cnt == 4&#x27;d10)|(cnt == 4&#x27;d15)&amp;valid_in) valid_out &lt;= 1&#x27;b1; else valid_out &lt;= 1&#x27;b0; end //output data //cnt==5时，data_temp的值为&#123;data_in_0[7:0],data_in_1,data_in_2,data_in_3,data_in_4,data_in_5&#125;； //cnt==9时，data_temp的值为&#123;data_in_4[7:0],data_in_5,data_in_6,data_in_7,data_in_8,data_in_9&#125;； //cnt==14时，data_temp的值为&#123;data_in_9[7:0],data_in_10,data_in_11,data_in_12,data_in_13,data_in_14&#125; reg [128:0] data_temp; always@(posedge clk or negedge rst_n) begin if(~rst_n) data_temp &lt;= 128&#x27;b0; else if(valid_in) data_temp &lt;= &#123;data_temp[103:0], data_in&#125;; end always@(posedge clk or negedge rst_n) begin if(~rst_n) data_out &lt;= 128&#x27;b0; else if(valid_in) begin if(cnt == 4&#x27;d5) data_out &lt;= &#123;data_temp[119:0], data_in[23:16]&#125;; //5*24 + 8 = 128 else if(cnt == 4&#x27;d10) data_out &lt;= &#123;data_temp[111:0], data_in[23:8]&#125;; //16 + 24*4 + 16 = 128 else if(cnt == 4&#x27;d15) data_out &lt;= &#123;data_temp[103:0], data_in&#125;; //8 + 24*5 = 128 end endendmodule VL9 非整数倍数据位宽转换8to12Solution 1Solution2折叠表格123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566`timescale 1ns/1nsmodule width_8to12( input clk , input rst_n , input valid_in , input [7:0] data_in , output reg valid_out, output reg [11:0] data_out); //counter reg [1:0] cnt; always@(posedge clk or negedge rst_n) begin if(~rst_n) cnt &lt;= 2&#x27;b0; else if(valid_in) begin if(cnt == 2&#x27;b10) cnt &lt;= 2&#x27;b0; else cnt &lt;= cnt + 1&#x27;b1; end end //output valid_out always@(posedge clk or negedge rst_n) begin if(~rst_n) valid_out &lt;= 1&#x27;b0; else if(((cnt == 2&#x27;b01) | (cnt == 2&#x27;b10)) &amp; valid_in) valid_out &lt;= 1&#x27;b1; else valid_out &lt;= 1&#x27;b0; end //shifting register reg [7:0] data_temp1; reg [11:0] data_temp2; always@(posedge clk or negedge rst_n) begin if(~rst_n) data_temp1 &lt;= 8&#x27;b0; else if(valid_in) data_temp1 &lt;= data_in; end always@(posedge clk or negedge rst_n) begin if(~rst_n) data_temp2 &lt;= 8&#x27;b0; else if(valid_in) begin if(cnt == 2&#x27;b01) data_temp2 &lt;= &#123;data_temp2[7:0], data_in[7:4]&#125;; else if(cnt == 2&#x27;b10) data_temp2 &lt;= &#123;data_temp1[3:0], data_in&#125;; else data_temp2 &lt;= &#123;data_temp2[3:0], data_in&#125;; end end always@(posedge clk or negedge rst_n) begin if(~rst_n) data_out &lt;= 12&#x27;b0; else if(valid_in) begin if(cnt == 2&#x27;b01) data_out &lt;= &#123;data_temp2[7:0], data_in[7:4]&#125;; else if(cnt == 2&#x27;b10) data_out &lt;= &#123;data_temp1[3:0], data_in&#125;; end endendmodule修改后资源占用更少： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152`timescale 1ns/1nsmodule test( input clk , input rst_n , input valid_in , input [7:0] data_in , output reg valid_out, output reg [11:0] data_out); //counter reg [1:0] cnt; always@(posedge clk or negedge rst_n) begin if(~rst_n) cnt &lt;= 2&#x27;b0; else if(valid_in) begin if(cnt == 2&#x27;b10) cnt &lt;= 2&#x27;b0; else cnt &lt;= cnt + 1&#x27;b1; end end //output valid_out always@(posedge clk or negedge rst_n) begin if(~rst_n) valid_out &lt;= 1&#x27;b0; else if(((cnt == 2&#x27;b01) | (cnt == 2&#x27;b10)) &amp; valid_in) valid_out &lt;= 1&#x27;b1; else valid_out &lt;= 1&#x27;b0; end //shifting register reg [11:0] data_temp; always@(posedge clk or negedge rst_n) begin if(~rst_n) data_temp &lt;= 12&#x27;b0; else if(valid_in) data_temp &lt;= &#123;data_temp[3:0], data_in&#125;; end always@(posedge clk or negedge rst_n) begin if(~rst_n) data_out &lt;= 12&#x27;b0; else if(valid_in) begin if(cnt == 2&#x27;b01) data_out &lt;= &#123;data_temp[7:0], data_in[7:4]&#125;; else if(cnt == 2&#x27;b10) data_out &lt;= &#123;data_temp[3:0], data_in&#125;; end endendmodule VL10 整数倍数据位宽转换8to16code 1234567891011121314151617181920212223242526272829303132333435363738394041424344`timescale 1ns/1nsmodule width_8to16( input clk, input rst_n, input valid_in, input [7:0] data_in, output reg valid_out, output reg [15:0] data_out); //counter reg cnt; always@(posedge clk or negedge rst_n) begin if(~rst_n) cnt &lt;= 1&#x27;b0; else if(valid_in) cnt &lt;= cnt + 1&#x27;b1; end //output valid_out always@(posedge clk or negedge rst_n) begin if(~rst_n) valid_out &lt;= 1&#x27;b0; else if((cnt == 1&#x27;b1) &amp; valid_in) valid_out &lt;= 1&#x27;b1; else valid_out &lt;= 1&#x27;b0; end //shifting register reg [7:0] data_temp; //整数倍转换只需要一个寄存器 always@(posedge clk or negedge rst_n) begin if(~rst_n) data_temp &lt;= 8&#x27;b0; else if(valid_in) data_temp &lt;= data_in; end always@(posedge clk or negedge rst_n) begin if(~rst_n) data_out &lt;= 16&#x27;b0; else if((cnt== 1&#x27;b1) &amp; valid_in) data_out &lt;= &#123;data_temp, data_in&#125;; endendmodule VL11 状态机-非重叠的序列检测code 用了一个很常规的三段式状态机： 1234567891011121314151617181920212223242526272829303132333435363738394041`timescale 1ns/1nsmodule sequence_test1( input wire clk , input wire rst , //这里的rst其实是低电平有效，但是题目给的名字时rst input wire data , output reg flag);//*************code***********// //set state localparam IDLE = 0, S1 = 1, S10 = 2, S101 = 3, S1011 = 4, S10111 = 5; reg [2:0] state, next; //state transition always@(*) begin case(state) IDLE: next = data ? S1 : IDLE ; S1: next = data ? S1 : S10 ; S10: next = data ? S101 : IDLE ; S101: next = data ? S1011 : S10 ; S1011: next = data ? S10111: S10 ; S10111: next = data ? S1 : IDLE ; endcase end //state flip-flops always@(posedge clk or negedge rst) begin if(~rst) state &lt;= IDLE; else state &lt;= next; end //output always@(posedge clk or negedge rst) begin if(~rst) flag &lt;= 1&#x27;b0; else case(next) S10111: flag &lt;= 1&#x27;b1; default: flag &lt;= 1&#x27;b0; endcase end//*************code***********//endmodule VL12 状态机-重叠序列检测code 12345678910111213141516171819202122232425262728293031323334353637383940`timescale 1ns/1nsmodule sequence_test2( input wire clk , input wire rst , //这里的rst其实是低电平有效，但是题目给的名字时rst input wire data , output reg flag);//*************code***********// //set state localparam IDLE = 0, S1 = 1, S10 = 2, S101 = 3, S1011 = 4; reg [2:0] state, next; //state transition always@(*) begin case(state) IDLE: next = data ? S1 : IDLE ; S1: next = data ? S1 : S10 ; S10: next = data ? S101 : IDLE ; S101: next = data ? S1011 : S10 ; S1011: next = data ? S1 : S10 ; endcase end //state flip-flops always@(posedge clk or negedge rst) begin if(~rst) state &lt;= IDLE; else state &lt;= next; end //output always@(posedge clk or negedge rst) begin if(~rst) flag &lt;= 1&#x27;b0; else case(state) S1011: flag &lt;= 1&#x27;b1; default: flag &lt;= 1&#x27;b0; endcase end//*************code***********//endmodule VL13 时钟分频（偶数）有计数器无计数器折叠表格123456789101112131415161718192021222324252627282930313233343536373839404142`timescale 1ns/1nsmodule even_div ( input wire rst , //这里的rst其实是低电平有效，但是题目给的名字时rst input wire clk_in, output reg clk_out2, output reg clk_out4, output reg clk_out8 );//*************code***********// //counter reg [1:0] cnt; always@(posedge clk_in or negedge rst) begin if(~rst) cnt &lt;= 3&#x27;d0; else cnt &lt;= cnt + 1&#x27;b1; end //clk_out2 always@(posedge clk_in or negedge rst) begin if(~rst) clk_out2 &lt;= 1&#x27;b0; else clk_out2 &lt;= ~clk_out2; end //clk_out4 always@(posedge clk_in or negedge rst) begin if(~rst) clk_out4 &lt;= 1&#x27;b0; else if((cnt == 2&#x27;d0) | (cnt == 2&#x27;d2)) clk_out4 &lt;= ~clk_out4; end //clk_out8 always@(posedge clk_in or negedge rst) begin if(~rst) clk_out8 &lt;= 1&#x27;b0; else if(cnt == 2&#x27;d0) clk_out8 &lt;= ~clk_out8; end//*************code***********//endmodule不含计数器的做法，实际使用时不推荐： 12345678910111213141516171819202122232425262728293031323334`timescale 1ns/1nsmodule even_div ( input wire rst , //这里的rst其实是低电平有效，但是题目给的名字时rst input wire clk_in, output reg clk_out2, output reg clk_out4, output reg clk_out8 );//*************code***********// //clk_out2 always@(posedge clk_in or negedge rst) begin if(~rst) clk_out2 &lt;= 1&#x27;b0; else clk_out2 &lt;= ~clk_out2; end //clk_out4 always@(posedge clk_out2 or negedge rst) begin if(~rst) clk_out4 &lt;= 1&#x27;b0; else clk_out4 &lt;= ~clk_out4; end //clk_out8 always@(posedge clk_out4 or negedge rst) begin if(~rst) clk_out8 &lt;= 1&#x27;b0; else clk_out8 &lt;= ~clk_out8; end//*************code***********//endmodule 此方法在低频信号中可以使用，但是在高频时钟下会出现失误， 在FPGA中所有的时钟都要连接到全局时钟网络中去，又叫全局时钟数，其目的是为了保证时钟信号到达每一个器件的时间都尽可能相同，而这种方法并没有连接到全局时钟网络中 。 想要改进，可以使用脉冲标志信号，即在每个所需周期末尾输出一个clk_flag脉冲信号，利用always@(posedge clk or negedge rst_n) 和if(clk_flag = 1&#39;b1)达到分频的目的。 VL14 自动贩售机1状态机方法非状态机方法折叠表格因为题目中的d1，d2，d3只输入半个周期高电平，所以需要增加3个寄存器来存放输入，写出来的代码有点笨重： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142`timescale 1ns/1nsmodule seller1( input wire clk , input wire rst , input wire d1 , input wire d2 , input wire d3 , output reg out1, output reg [1:0]out2);//*************code***********// //state machine //set state localparam IDLE = 0, S05 = 1, S10 = 2, S15 = 3, S20 = 4, S25 = 5, S30 = 6; reg [2:0] state, next; //state transition reg rg1, rg2, rg3; //save d1, d2, d3 always@(posedge clk or negedge rst) begin if(~rst) begin rg1 &lt;= 0; rg2 &lt;= 0; rg3 &lt;= 0; end else begin rg1 &lt;= d1; rg2 &lt;= d2; rg3 &lt;= d3; end end always@(*) begin case(state) IDLE: begin if(rg3) next = S20; else if(rg2) next = S10; else if(rg1) next = S05; else next = IDLE; end S05: begin if(rg3) next = S25; else if(rg2) next = S15; else if(rg1) next = S10; else next = S05; end S10: begin if(rg3) next = S30; else if(rg2) next = S20; else if(rg1) next = S15; else next = S10; end S15: begin if(rg3) next = S20; else if(rg2) next = S10; else if(rg1) next = S05; else next = IDLE; end S20: begin if(rg3) next = S20; else if(rg2) next = S10; else if(rg1) next = S05; else next = IDLE; end S25: begin if(rg3) next = S20; else if(rg2) next = S10; else if(rg1) next = S05; else next = IDLE; end S30: begin if(rg3) next = S20; else if(rg2) next = S10; else if(rg1) next = S05; else next = IDLE; end endcase end //state flip-flps always@(posedge clk or negedge rst) begin if(~rst) state &lt;= IDLE; else state &lt;= next; end //output always@(posedge clk or negedge rst) begin if(~rst) begin out1 &lt;= 1&#x27;b0; out2 &lt;= 2&#x27;b0; end else case(next) S15: begin out1 &lt;= 1&#x27;b1; out2 &lt;= 2&#x27;b0; end S20: begin out1 &lt;= 1&#x27;b1; out2 &lt;= 2&#x27;b1; end S25: begin out1 &lt;= 1&#x27;b1; out2 &lt;= 2&#x27;d2; end S30: begin out1 &lt;= 1&#x27;b1; out2 &lt;= 2&#x27;d3; end default: begin out1 &lt;= 1&#x27;b0; out2 &lt;= 2&#x27;b0; end endcase end//*************code***********//endmodule从代码量来看都能看出比状态机方法简单一些 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657`timescale 1ns/1nsmodule seller1( input wire clk , input wire rst , input wire d1 , input wire d2 , input wire d3 , output reg out1, output reg [1:0]out2);//*************code***********// reg [2:0] money05; //accumulating money always@(posedge clk or negedge rst) begin if(~rst) money05 &lt;= 3&#x27;d0; else if((money05[2]==1) | (money05[1:0]==2&#x27;b11)) //此时累积金钱大于3 * 0.5元 money05 &lt;= 3&#x27;d0; else case(&#123;d3, d2, d1&#125;) 3&#x27;b001: money05 &lt;= money05 + 1&#x27;d1; 3&#x27;b010: money05 &lt;= money05 + 2&#x27;d2; 3&#x27;b100: money05 &lt;= money05 + 3&#x27;d4; default: money05 &lt;= money05; endcase end //output always@(posedge clk or negedge rst) begin if(~rst) begin out1 &lt;= 1&#x27;b0; out2 &lt;= 2&#x27;d0; end else case(money05) //根据累积金钱来判断输出 3&#x27;d3: begin out1 &lt;= 1&#x27;b1; out2 &lt;= 2&#x27;d0; end 3&#x27;d4: begin out1 &lt;= 1&#x27;b1; out2 &lt;= 2&#x27;d1; end 3&#x27;d5: begin out1 &lt;= 1&#x27;b1; out2 &lt;= 2&#x27;d2; end 3&#x27;d6: begin out1 &lt;= 1&#x27;b1; out2 &lt;= 2&#x27;d3; end default: begin out1 &lt;= 1&#x27;b0; out2 &lt;= 2&#x27;d0; end endcase end//*************code***********//endmodule VL15 自动贩售机2code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465`timescale 1ns/1nsmodule seller2( input wire clk , input wire rst , input wire d1 , input wire d2 , input wire sel , output reg out1, output reg out2, output reg out3);//*************code***********// reg [2:0] money05; //accumulating money always@(posedge clk or negedge rst) begin if(~rst) money05 &lt;= 3&#x27;d0; //判断是否满足出饮料的条件 else if(((money05[2] | (money05[1] &amp; money05[0])) &amp; ~sel) | (money05[2] &amp; (money05[1] | money05[0]) &amp; sel)) money05 &lt;= 3&#x27;d0; else case(&#123;d2, d1&#125;) 2&#x27;b01: money05 &lt;= money05 + 1&#x27;d1; 2&#x27;b10: money05 &lt;= money05 + 2&#x27;d2; default: money05 &lt;= money05; endcase end //output always@(posedge clk or negedge rst) begin if(~rst) begin out1 &lt;= 1&#x27;b0; out2 &lt;= 1&#x27;b0; out3 &lt;= 2&#x27;d0; end else case(money05) //根据累积金钱来判断输出 3&#x27;d3: begin out1 &lt;= sel ? 1&#x27;b0 : 1&#x27;b1; out2 &lt;= 1&#x27;b0; out3 &lt;= 2&#x27;d0; end 3&#x27;d4: begin out1 &lt;= sel ? 1&#x27;b0 : 1&#x27;b1; out2 &lt;= 1&#x27;b0; out3 &lt;= sel ? 2&#x27;d0 : 2&#x27;d1; end 3&#x27;d5: begin out1 &lt;= sel ? 1&#x27;b0 : 1&#x27;b1; out2 &lt;= sel ? 1&#x27;b1 : 1&#x27;b0; out3 &lt;= sel ? 2&#x27;d0 : 2&#x27;d2; end 3&#x27;d6: begin out1 &lt;= sel ? 1&#x27;b0 : 1&#x27;b1; out2 &lt;= sel ? 1&#x27;b1 : 1&#x27;b0; out3 &lt;= sel ? 2&#x27;d1 : 2&#x27;d3; end default: begin out1 &lt;= 1&#x27;b0; out2 &lt;= 1&#x27;b0; out3 &lt;= 2&#x27;d0; end endcase end//*************code***********//endmodule VL16 占空比50%的奇数分频 （有待复习，这题是重点！！）code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950`timescale 1ns/1nsmodule odo_div_or ( input wire rst, input wire clk_in, output wire clk_out7);//*************code***********// localparam N = 7; //counter_p reg [$clog(N)-1:0] cnt_p; always@(posedge clk_in or negedge rst) begin if(~rst) cnt_p &lt;= 0; else if(cnt_p == N-1) cnt_p &lt;= 0; else cnt_p &lt;= cnt_p + 1&#x27;b1; end //clk_p reg clk_p; always@(posedge clk_in or negedge rst) begin if(~rst) clk_p &lt;= 1&#x27;b0; else if((cnt_p == (N-1)/2) | (cnt_p == N-1)) //这里的除法可以换成移位，即cnt_p&gt;&gt;1 clk_p &lt;= ~clk_p; end //counter_n reg [$clog(N)-1:0] cnt_n; always@(negedge clk_in or negedge rst) begin if(~rst) cnt_n &lt;= 0; else if(cnt_n == N-1) cnt_n &lt;= 0; else cnt_n &lt;= cnt_n + 1&#x27;b1; end //clk_n reg clk_n; always@(negedge clk_in or negedge rst) begin if(~rst) clk_n &lt;= 1&#x27;b0; else if((cnt_n == (N-1)/2) | (cnt_n == N-1)) //这里的除法可以换成移位，即cnt_n&gt;&gt;1 clk_n &lt;= ~clk_n; end //output assign clk_out7 = clk_p | clk_n;//*************code***********//endmodule","categories":[],"tags":[{"name":"Verilog","slug":"Verilog","permalink":"http://example.com/tags/Verilog/"}]},{"title":"C++问题笔记","slug":"cpp/cpp-note","date":"2022-04-24T08:20:24.000Z","updated":"2022-04-30T06:52:48.374Z","comments":true,"path":"2022/04/24/cpp/cpp-note/","link":"","permalink":"http://example.com/2022/04/24/cpp/cpp-note/","excerpt":"启用括号包围在visual studio中，工具—&gt;选项—&gt;高级，可以启用括号包围，","text":"启用括号包围在visual studio中，工具—&gt;选项—&gt;高级，可以启用括号包围，","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++笔记（四）——自定义数据结构","slug":"cpp/cpp-note-4","date":"2022-04-23T12:58:08.000Z","updated":"2022-04-27T15:00:25.706Z","comments":true,"path":"2022/04/23/cpp/cpp-note-4/","link":"","permalink":"http://example.com/2022/04/23/cpp/cpp-note-4/","excerpt":"自定义数据结构数据结构是把一组相关的数据元素组织起来然后使用它们的策略和方法，如Sales_item类，把书本的ISBN编号、售出量和销售收入等数据组织在了一起，并且提供如isbn函数、&gt;&gt;、&lt;&lt;、+、+&#x3D;等运算在内的一系列操作，Sales_item类就是一个数据结构。 C++允许用户以类的形式自定义数据类型。 定义Sales_data类型在第七章之前，都使用struct（结构体）来自定义数据类型： 12345struct Sales_data&#123; std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;&#125;; //注意：类体右侧的表示结束的花括号后必须写一个分号，因为类体后面可以紧跟变量名以示对该类型对象的定义 {}中的三条语句定义了struct的数据成员(data member)，C++11新标准规定，可以为数据成员提供一个类内初始值(in-class initializer)，没有初始值的成员将被默认初始化。 千万牢记，定义数据类型的{}之后一定要有分号，而定义函数的{}之后则不需要分号。 定义该类型的对象： 1234struct Sales_data&#123;/*...*/&#125; accum, trans, *salesptr;//以下两条语句等同于上一条语句，但更易读一些struct Sales_data&#123;/*...*/&#125;;Sales_data accum, trans, *salesptr;","text":"自定义数据结构数据结构是把一组相关的数据元素组织起来然后使用它们的策略和方法，如Sales_item类，把书本的ISBN编号、售出量和销售收入等数据组织在了一起，并且提供如isbn函数、&gt;&gt;、&lt;&lt;、+、+&#x3D;等运算在内的一系列操作，Sales_item类就是一个数据结构。 C++允许用户以类的形式自定义数据类型。 定义Sales_data类型在第七章之前，都使用struct（结构体）来自定义数据类型： 12345struct Sales_data&#123; std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;&#125;; //注意：类体右侧的表示结束的花括号后必须写一个分号，因为类体后面可以紧跟变量名以示对该类型对象的定义 {}中的三条语句定义了struct的数据成员(data member)，C++11新标准规定，可以为数据成员提供一个类内初始值(in-class initializer)，没有初始值的成员将被默认初始化。 千万牢记，定义数据类型的{}之后一定要有分号，而定义函数的{}之后则不需要分号。 定义该类型的对象： 1234struct Sales_data&#123;/*...*/&#125; accum, trans, *salesptr;//以下两条语句等同于上一条语句，但更易读一些struct Sales_data&#123;/*...*/&#125;;Sales_data accum, trans, *salesptr; 补充：cout标准输出(standard output)，cerr标准错误(standard error)，clog用来输出程序运行时的一般性信息。 编写自己的头文件类一般都不定义在函数体内。为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在的头文件的名字应与类的名字一样。 头文件通常包含哪些只能被定义一次的实体(entity)，如类、const和constexpr变量（定义时添加extern关键字）等。 确保头文件多次包含仍能安全工作的常用技术是预处理器(preprocessor)，它由C++语言从C语言里继承而来。#include就是一项预处理功能，当预处理器看到#include标记时就会用指定的头文件内容代替#include。 C++还会用到一项预处理功能是头文件保护符(header guard)，依赖于预处理变量。预处理变量有两种状态：已定义和未定义。#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真。 如此可以有效防止重复包含： 123456789#ifndef SALES_DATA_H //变量未定义时检查结果为真，执行后续操作直到#endif为止#define SALES_DATA_H //把SALES_DATA_H设定为预处理变量#include &lt;string&gt;struct Sales_data&#123; std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;&#125;;#endif 头文件保护符必须唯一，通常是基于头文件中类的名字来构建保护符的名字。为了避免与程序中的其他实体发生名字冲突，一般吧预处理变量的名字全部大写。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++笔记（三）——处理类型","slug":"cpp/cpp-note-3","date":"2022-04-23T04:12:45.000Z","updated":"2022-04-25T14:10:11.305Z","comments":true,"path":"2022/04/23/cpp/cpp-note-3/","link":"","permalink":"http://example.com/2022/04/23/cpp/cpp-note-3/","excerpt":"常量表达式和constexpr常量表达式(const expression)1234const int max_files = 20; //max_files是常量表达式const int limit = max_filse + 1; //limit是常量表达式int staff_size = 27; //staff_size不是常量表达式const int sz = get_size(); //sz不是常量表达式，其具体值在程序运行时才能获得，而不是编译时获得 在复杂系统中，无法分辨一个初始值到底是不是常量表达式。这种情况下，对象的定义和使用根本就是两回事儿。 constexpr变量C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。 123constexpr int mf = 20;constexpr int limit = mf + 1;constexpr int sz = size(); //只有当size是一个constexpr函数时，这才是一条正确语句 同时C++11新标准也允许定义一种constexpr函数，这种函数必须简单到在编译时就可以计算其结果，这样就能用constexpr函数去初始化constexpr变量。 在声明constexpr时，用到的类型只能是字面值类型 字面值类型(literal type)","text":"常量表达式和constexpr常量表达式(const expression)1234const int max_files = 20; //max_files是常量表达式const int limit = max_filse + 1; //limit是常量表达式int staff_size = 27; //staff_size不是常量表达式const int sz = get_size(); //sz不是常量表达式，其具体值在程序运行时才能获得，而不是编译时获得 在复杂系统中，无法分辨一个初始值到底是不是常量表达式。这种情况下，对象的定义和使用根本就是两回事儿。 constexpr变量C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。 123constexpr int mf = 20;constexpr int limit = mf + 1;constexpr int sz = size(); //只有当size是一个constexpr函数时，这才是一条正确语句 同时C++11新标准也允许定义一种constexpr函数，这种函数必须简单到在编译时就可以计算其结果，这样就能用constexpr函数去初始化constexpr变量。 在声明constexpr时，用到的类型只能是字面值类型 字面值类型(literal type)目前接触过的数据类型中，算术类型、引用和指针都属于字面值类型，但被定义成constexpr的指针初值必须输nullptr或者0，或者存储于某个固定地址中的对象。 函数体内定义的变量一般并非存放在固定地址中，所有函数体之外的对象其地址固定不变。函数体内允许定义一类有效范围超出函数本身的变量，该变量夜游固定地址。 constexpr指针constexpr声明中定义了一个指针，限定符constexpr只对指针有效： 12const int* p = nullptr; //p是一个指向整型常量的指针constexpr int* q = nullptr; //q是一个指向整数的常量指针 处理类型类型别名(type alias)传统定义方法 12typedef double wages; //wages是double的同义词typedef wages base, * p; //base是double的同义词，p是double*的同义词 C++11新标准定义方法 1using SI = Sales_item; //SI是Sales_item的同义词 类型别名引入的易错点，从右向左读可以轻松理解以下语句 1234typedef char * pstring; //pstring是char*的同义词，此时pstring的基本数据类型是指针const pstring cstr = 0; //const限定了pstring，即基本数据类型是const pstring，指向char的常量指针const char * cstr = 0; //const限定了char，即基本数据类型是const char，指向char常量的指针const pstring * ps; //ps是一个指针，其所指对象是一个指向char的常量指针 auto类型说明符编程时常常需要把表达式的值赋给变量，这就要求声明变量时清楚地知道表达式的类型。C++11新标准引入了auto类型说明符，它可以分析表达式所属的类型 auto定义的变量必须有初始值，用以推断该变量的类型： 1auto item = val1 + val2; //item初始化为val1和val2相加的结果，由该结果可以推断出item的类型 auto可以在一条语句中定义多个变量，由于一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样： 12auto i = 0, * p = &amp;i; //正确：i是整数、p是整型指针auto sz = 0, pi = 3.14; //错误：sz和pi的类型不一致 auto一般会忽略顶层const，但保留底层const： 123456int i = 0;const int ci = i, &amp;cr = ci;auto b = ci; //b是一个普通整数auto c = cr; //c是一个普通整数（cr只是ci的别名，实际参与初始化的是被引用对象ci）auto d = &amp;i; //d是一个普通整型指针auto e = &amp;ci; //e是一个指向整数常量的指针（对常量对象取地址是一种底层const） 如果希望通过auto定义一个顶层const对象，则需要： 123const auto f = ci;auto&amp; r1 = 42; //错误：不能为非常量引用绑定字面值const auto&amp; r2 = 42; //正确：可以为常量引用绑定字面值 当设置一个类型为auto的引用时，顶层常量属性仍然保留，即得到的引用具有底层常量属性： 123const int i = 1; //i具有顶层常量属性auto&amp; r = i; //r是一个对整数常量的引用，此时r是一个对常量的引用r = 100; //错误：不可修改对常量的引用所引用的对象 切记，auto只是推断声明符的类型，而&amp;和*只是声明符的修饰符 在声明语句中，*声明一个指针变量，&amp;声明一个对象引用；在定义语句中，*取指针所指向的数据，&amp;取对象的地址。 decltype类型说明符C++11新标准引入了decltype，用于从表达式的类型推断出要定义的变量的类型，但是并不用该表达式的值初始化变量。 1decltype(f()) sum = x; //sum的类型就是f()的返回类型 decltype处理顶层const和引用的方式与auto不同： 1234const int ci = 0, &amp; cj = ci;decltype(ci) x = 0; //x的类型是const intdecltype(cj) y = x; //y的类型是const int&amp;，y绑定到常量xdecltype(cj) z; //错误：z是一个引用，必须初始化 上述例子中，在decltype()中ci和cj不是一个同义词，而在其他任何地方，cj都是ci的同义词 几个需要注意的点 123456int i = 42, * p = &amp;i, &amp; r = i;decltype(r + 0) b; //正确：尽管r是一个引用，但加法的结果是int而非一个引用，因此b是一个未初始化的intdecltype(*p) c; //错误：表达式内容是解引用操作，则decltype得到引用类型，故c是int&amp;，必须初始化decltype((i)) d; //错误：d是int&amp;，必须初始化decltype(i) e; //正确：e是一个未初始化的intdecltype((i + 0)) f; //正确：f是一个未初始化的int 上述例子中，当变量i被加上了一层括号时，编译器会把它当成一个表达式，而变量是一种可以作为赋值语句左值的特殊表达式，所以decltype((i))的结果类型是一个引用类型int&amp; 练习2.36 12345int a = 3, b = 4;decltype(a) c = a;decltype((b)) d = a; //d是一个引用，被引用的对象是a++c;++d; //d是a的同义词，实际进行操作时将d替换为a 上述代码中，c是int型，d是int&amp;型，最后a、b、c、d四个值都是4 练习2.37 如果i是int，则表达式i&#x3D;x的类型是int&amp; 123int a = 3, b = 4;decltype(a) c = a; //c是一个整数，初始化为adecltype(a = b) d = a; //d是一个引用，被引用的对象是a","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++笔记（二）——const限定符","slug":"cpp/cpp-note-2","date":"2022-04-20T09:47:51.000Z","updated":"2022-04-30T06:55:39.002Z","comments":true,"path":"2022/04/20/cpp/cpp-note-2/","link":"","permalink":"http://example.com/2022/04/20/cpp/cpp-note-2/","excerpt":"const限定符const对象const对象一旦创建后其值就不可改变，因此必须初始化； 123const int i = get_size(); //正确：运行时初始化，get_size()为有返回值的函数const int j = 42; //正确：编译时初始化const int k; //错误：k是一个未经初始化的常量 默认状态下，const对象仅在文件内有效，因为编译器将在编译过程中会把用到该变量的地方都替换成对应的值，每个用了const对象的文件都必须含有对它的定义而非声明；如：在test1中 12const int i = 1; //定义全局常量i，初始化为1int j = 2; //定义全局变量j，初始化为2 test2中 1234567#include &lt;iostream&gt;using namespace std;int main() &#123; extern int i; cout &lt;&lt; i &lt;&lt; endl; return 0;&#125; test3中 1234567#include &lt;iostream&gt;using namespace std;int main() &#123; extern int j; cout &lt;&lt; j &lt;&lt; endl; return 0;&#125;","text":"const限定符const对象const对象一旦创建后其值就不可改变，因此必须初始化； 123const int i = get_size(); //正确：运行时初始化，get_size()为有返回值的函数const int j = 42; //正确：编译时初始化const int k; //错误：k是一个未经初始化的常量 默认状态下，const对象仅在文件内有效，因为编译器将在编译过程中会把用到该变量的地方都替换成对应的值，每个用了const对象的文件都必须含有对它的定义而非声明；如：在test1中 12const int i = 1; //定义全局常量i，初始化为1int j = 2; //定义全局变量j，初始化为2 test2中 1234567#include &lt;iostream&gt;using namespace std;int main() &#123; extern int i; cout &lt;&lt; i &lt;&lt; endl; return 0;&#125; test3中 1234567#include &lt;iostream&gt;using namespace std;int main() &#123; extern int j; cout &lt;&lt; j &lt;&lt; endl; return 0;&#125; 其中test2会报错error LNK2001: 无法解析的外部符号 “int i”；而test3中能够得到输出2。对于一种const变量，它的初始值不是一个常量表达式，如果想只在一个文件中定义这类const对象，而且在其他多个文件中声明并使用它，方法如下： 1234//file_1.cpp中extern const int bufSize = fcn();//file_1.h中extern const int bufSize; //与file_1.cpp中定义的bufSize是同一个 对常量的引用(reference to const)“对常量的引用”可以简称为“常量引用”，因为引用不是一个对象，所以实际上不存在常量引用 对常量进行引用时，引用也必须为常量 12345const int ci = 1034;const int &amp;r1 = ci; //正确：引用及其对应的对象都是常量r1 = 42; //错误：r1是对常量的引用，不可改变其值int &amp;r2 = ci; //错误：试图让一个非常量引用指向一个常量对象 常量引用的两个例外（待补充） 初始化常量引用时允许用任意表达式作为初值，只要其结果能够转换成常量引用的类型即可 12345int i = 42;const int &amp;r1 = i; //允许将const int&amp;绑定到一个普通int对象上const int &amp;r2 = 42; //正确const int &amp;r3 = r1 * 2; //正确int &amp;r4 = r4 * 2; //错误：r4是一个普通的非常量引用 原因：在使用常量引用时，系编译器生成了一个与该常量引用同类型的临时量(temporary)对象，再将常量引用绑定在这个临时量对象上。 常量引用绑定的对象可以是非const对象 12345int i =42;int &amp;r1 = i; //引用ri绑定对象iconst int &amp;r2 = i; //r2也绑定对象i，当时不允许通过r2修改i的值r1 = 0; //r1并非常量，i的值修改为0r2 = 0; //错误：r2是一个常量引用，不可通过r2修改i的值 指向常量的指针(pointer to const)指向常量的指针不能用于改变其所指对象的值；要想存放常量对象的地址，只能使用指向常量的指针。 指向常量的指针的两个例外（待补充） 允许一个指向常量的指针指向一个非常量对象，指向常量的指针没有规定其所指对象必须是一个常量 1234const double pi = 3.14; double *ptr = &amp;pi; //错误：ptr是一个普通指针const double *cptr = &amp;pi; //正确：cptr可以指向一个双精度常量*cptr = 42; //错误：不能给*cptr赋值 原因同“对常量的引用” ps：所谓指向常量的指针或常量引用，不过是指针或引用“自以为是”罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象的值。 const指针引用不是对象，而指针是对象，因此允许把指针本身定义为常量，即常量指针(const pointer)。常量指针必须初始化，而且一旦初始化后，它的值（存放在指针中的地址）就不能再改变了。把*放在const关键字之前，这样书写说明不变的是指针而非指针指向的那个值。 12345678910#include &lt;iostream&gt;using namespace std;int main() &#123; int errNumb = 0; int* const curErr = &amp;errNumb; //curErr是一个常量指针 const double pi = 3.14159; const double* const pip1 = &amp;pi; //pip是一个指向常量的常量指针 double* const pip2 = &amp;pi; //错误：pip2并不是一个指向常量的指针，不能“const double*”类型的值不能用于初始化“double* const”类型的实体 return 0;&#125; 指针本身是常量，不代表不能通过指针修改其所指对象的值，能否这样做取决于所指对象的类型，即可以通过常量指针修改非常量对象的值。 1234567int i = 1;int j = 0;int k = 2;int* const p = &amp;i;*p = j; //正确：改变p的值（地址）存放的对象的值，即把i赋值为j，但并没有改变p的值（地址） //此操作后i = 0， j = 0， k = 2；p = &amp;k; //错误：此操作为把p赋值为k的地址，而p是一个常量指针，其值不可改变 建议：想要弄清这些声明的含义，最有效的方法是从右向左阅读 练习2.27 1const int &amp;const r2 = 0; //错误：引用不是对象，没有常量引用，只有对常量的引用 虽然有的编译器会自动忽略掉&amp;后的const，但切记不要这样做。 顶层const和底层const顶层const(top-level const)：表示指针本身是一个常量 底层const(low-level const)：表示指针所指对象是一个常量 更一般的，顶层const表示任意的对象是常量，底层const表示指针和引用等所指对象和所引用对象是常量。 123456789101112131415int i = 0;int* const p1 = &amp;i; //不能改变p1的值，这是一个顶层constconst int ci = 42; //不能改变ci的值，这是一个顶层constconst int* p2 = &amp;ci; //允许改变p2的值，但不能改变p2所指对象的值，这是一个底层constconst int* const p3 = p2; //靠近p3的const是顶层，远离p3的const是底层const int&amp; r1 = ci; //用于声明引用的const都是底层i = ci; //正确：拷贝ci的值，ci是一个顶层const，对此操作无影响p2 = p3; //正确：p2和p3所指对象类型相同，即两者都是底层常量，p2不是顶层const，其值可以改变，p3顶层const部分不影响int* p = p3; //错误：p3包含底层const对象，即p3所指对象为常量，而p所指对象不是，故不能将p3的值赋予pint* p = &amp; *p3; //该操作完全同上，&amp;和*互为逆操作p2 = &amp;i; //正确：int*能转换成const int*，即底层非常量可以转换为底层常量int&amp; r2 = ci; //错误：非常量int&amp;不能绑定到int常量上const int&amp; r3 = i; //正确：常量int&amp;可以绑定到int非常量上 提示：顶层const的对象初始化后不能被赋值，底层const的对象不能改变其所指或所引用对象的值，非底层const的对象不能拷贝底层const的对象。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++笔记（一）——变量和复合类型","slug":"cpp/cpp-note-1","date":"2022-04-18T04:07:01.000Z","updated":"2022-04-23T12:37:05.127Z","comments":true,"path":"2022/04/18/cpp/cpp-note-1/","link":"","permalink":"http://example.com/2022/04/18/cpp/cpp-note-1/","excerpt":"不同初始化方式的区别12345678910#include &lt;iostream&gt;using namespace std;int main() &#123; long double ld = 3.1415926536; int a&#123; ld &#125;, b = &#123; ld &#125;; //错误：会提示error C2397: 从“long double”转换到“int”需要收缩转换 int c(ld), d = ld;//能够完成编译，且确实丢失了部分值，c和d输出均为3 cout &lt;&lt; a &lt;&lt; &quot;\\t&quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; c &lt;&lt; &quot;\\t&quot; &lt;&lt; d &lt;&lt; endl; return 0;&#125; 对于局部变量来说，初始化很重要；在编写某个类的时候，尽量申明当该类的某个对象未被显式初始化时，生成一个合适的默认值。 声明和定义C++支持分离式编译(separate compilation) 声明(declaration)：使得某个名字为程序所知，即这个变量已经在别处定义了，我现在拿来用。（声明一个其他地方定义过的全局变量） 定义(definition)：创建与名字关联的实体。 123extern int i; //声明i而非定义i，但如果显式初始化后则会抵消了extern的作用int j; //定义jextern double pi = 3.1416; //定义pi，且初始化为3.1416 在函数内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。 ps: C++是一种静态类型（statically typed）语言，其含义是在编译阶段执行类型检查（type checking）。如果编译器发现数据类型不支持要执行的运算，则会报错且不会生成任何可执行的程序。程序越复杂，静态类型检查越有助于发现问题。这要求我们在使用某个变量之前必须声明其类型。","text":"不同初始化方式的区别12345678910#include &lt;iostream&gt;using namespace std;int main() &#123; long double ld = 3.1415926536; int a&#123; ld &#125;, b = &#123; ld &#125;; //错误：会提示error C2397: 从“long double”转换到“int”需要收缩转换 int c(ld), d = ld;//能够完成编译，且确实丢失了部分值，c和d输出均为3 cout &lt;&lt; a &lt;&lt; &quot;\\t&quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; c &lt;&lt; &quot;\\t&quot; &lt;&lt; d &lt;&lt; endl; return 0;&#125; 对于局部变量来说，初始化很重要；在编写某个类的时候，尽量申明当该类的某个对象未被显式初始化时，生成一个合适的默认值。 声明和定义C++支持分离式编译(separate compilation) 声明(declaration)：使得某个名字为程序所知，即这个变量已经在别处定义了，我现在拿来用。（声明一个其他地方定义过的全局变量） 定义(definition)：创建与名字关联的实体。 123extern int i; //声明i而非定义i，但如果显式初始化后则会抵消了extern的作用int j; //定义jextern double pi = 3.1416; //定义pi，且初始化为3.1416 在函数内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。 ps: C++是一种静态类型（statically typed）语言，其含义是在编译阶段执行类型检查（type checking）。如果编译器发现数据类型不支持要执行的运算，则会报错且不会生成任何可执行的程序。程序越复杂，静态类型检查越有助于发现问题。这要求我们在使用某个变量之前必须声明其类型。 标识符(identifier)变量命名规范： 标识符要体现实际含义； 变量名一般用小写字母，如index； 用户自定义的类名一般以大写字母开头，如Sales_item； 如果标识符由多个单词组成，则单词间要有明显区分，如student_loan或studentLoan； 建议：当第一次使用变量时再定义它，即随用随定义 有助于找到变量的定义； 可以赋予一个合理的初始值； 防止在程序一开始初始化一堆未用到的变量，从而拖慢运行速度； 作用域(scope)123456789#include &lt;iostream&gt;using namespace std;int i = 420, sum = 0;int main() &#123; for (int i = 0; i != 10; i++) //for()中的i作用域仅在()之中 sum += i; cout &lt;&lt; i &lt;&lt; &quot;\\t&quot; &lt;&lt; sum &lt;&lt; endl; //得到的输出为420 45 return 0;&#125; 12345678910#include &lt;iostream&gt;using namespace std;int i = 420, sum = 0;int main() &#123; int i = 100; //覆盖了全局变量i for (int i = 0; i != 10; i++) //for()中的i作用域仅在()之中 sum += i; cout &lt;&lt; ::i &lt;&lt; &quot;\\t&quot; &lt;&lt; i &lt;&lt; &quot;\\t&quot; &lt;&lt; sum &lt;&lt; endl; //得到的输出为420 100 45 return 0;&#125; 引用(reference)引用并非对象，而是为一个已经存在的对象所起的别名，不需要独立的内存空间； 引用初始化后，无法再令该引用重新绑定到另一个对象，因此引用必须初始化； 因为引用并非一个对象，所以不能定义引用的引用； 引用的类型必须与引用绑定的对象严格匹配。 12345678910111213#include &lt;iostream&gt;using namespace std;int main() &#123; int ival = 1024; int &amp;refVal0 = ival; //正确 int &amp;refVal1 = refVal; //正确：实际上是以与引用绑定的对象再定义了另一个引用 int &amp;refVal2; //错误：没有初始化引用 int &amp;refVal3 = &amp;refVal1; //错误：不能定义引用的引用 double dval = 3.14; int &amp;refVal4 = dval; //错误：类型不匹配 refVal = 0; return 0;&#125; 指针(pointer)指针本身就是一个对象，需要独立的内存空间; 指针初始化后，可以通过赋值来改变指针的值或指针指向的对象； 因为指针是一个对象，所以可以定义指针的指针； 指针的类型必须与指针的对象严格匹配。 指针的值（即地址）属于下列4中状态之一： 指向一个对象 指向紧邻对象所占空间的下一个位置 空指针，没有指向任何对象 无效指针，上述情况之外的其他值 建议： 初始化所有指针； 尽量定义了对象之后再定义指向它的指针； 如果实在不清楚指针应该指向何处，就先初始化为nullptr或者0； 1234int ival1 = 0, ival2 = 1;int *pi = &amp;ival1;pi = &amp;ival2; //pi的值被改变，现在pi指向了ival，或者说pi的值变成了存放ival的地址*pi = 0; //ival的值被改变，指针pi并没有改变 赋值改变的永远是&#x3D;左侧的对象！！！ void* 指针是一种特殊的指针类型，可以存放任意对象的地址。它可以用于和其他指针比较、作为函数的输入输出、赋值给另一个void* 指针。但是，不能对它所指向的对象进行操作，因为我们并不知道这个对象到底是什么类型。 概括来讲，void* 的视角来看，内存空间仅仅只是内存空间，没办法访问内存空间中所存的对象。 练习2.18 123456789101112131415#include &lt;iostream&gt;using namespace std;int main() &#123; int ival1 = 1, ival2 = 1, ival3 = 4; int* p1 = &amp;ival1, * p2 = &amp;ival2; //改变指针的值 cout &lt;&lt; p1 &lt;&lt; &quot;\\t&quot; &lt;&lt; ival1 &lt;&lt; &quot;\\t&quot; &lt;&lt; ival3 &lt;&lt; endl; p1 = &amp;ival3; cout &lt;&lt; p1 &lt;&lt; &quot;\\t&quot; &lt;&lt; ival1 &lt;&lt; &quot;\\t&quot; &lt;&lt; ival3 &lt;&lt; endl; //改变指针指向对象的值 cout &lt;&lt; p2 &lt;&lt; &quot;\\t&quot; &lt;&lt; *p2 &lt;&lt; &quot;\\t&quot; &lt;&lt; ival2 &lt;&lt; endl; *p2 = 100; cout &lt;&lt; p2 &lt;&lt; &quot;\\t&quot; &lt;&lt; *p2 &lt;&lt; &quot;\\t&quot; &lt;&lt; ival2 &lt;&lt; endl; return 0;&#125; 练习2.23 设给定指针为p 123int ival = 0;if(p) ival = 1;else ival = 2; //这个if...else...可以判断出p是否有一个合法的值（即合法地址）","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"学习FPGA（四）","slug":"FPGA/FPGA-4","date":"2022-04-17T02:57:24.000Z","updated":"2022-04-30T06:30:39.418Z","comments":true,"path":"2022/04/17/FPGA/FPGA-4/","link":"","permalink":"http://example.com/2022/04/17/FPGA/FPGA-4/","excerpt":"实现FPGA驱动数码管动态显示知识点： 数码管动态扫描实现。 In system sources and probes editor (ISSP)调试工具的使用。 工程代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//实现FPGA驱动数码管动态显示module digital_display(Clk, Rst_n, En, disp_data, sel, seg); input Clk; //50M，一个周期为20ns input Rst_n; input En; input [31:0] disp_data; //输入要求显示的内容 output reg [7:0] sel; //数码管位选（当前要显示的数码管） output reg [6:0] seg; //数码管段选（当前要显示的内容） //divider module reg [14:0] divider_cnt; //产生1ms的时钟，每0.5ms时钟信号需要翻转一次，0.5ms/20ns=25_000=16&#x27;b0110_0001_1010_1000，故需要15位计数器 reg Clk_1K; always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) divider_cnt &lt;= 15&#x27;d0; else if(~En) divider_cnt &lt;= 15&#x27;d0; else if(divider_cnt== 15&#x27;d24_999) divider_cnt &lt;= 15&#x27;d0; else divider_cnt &lt;= divider_cnt + 1&#x27;b1; end always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) Clk_1K &lt;= 1&#x27;b0; else if(~En) Clk_1K &lt;= 1&#x27;b0; else if(divider_cnt== 15&#x27;d24_999) Clk_1K &lt;= ~Clk_1K; else Clk_1K &lt;= Clk_1K; end //shift8 module reg [7:0] sel_r; always@(posedge Clk_1K or negedge Rst_n) begin //注意，分频器的输出信号作为D触发器的时钟信号，在大型设计中是不被允许的，此处设计为数码管驱动模块，影响不大，允许存在这样的毛刺 if(~Rst_n) sel_r &lt;= 8&#x27;b0000_0001; else if(sel_r == 8&#x27;b1000_0000) sel_r &lt;= 8&#x27;b0000_0001; else sel_r &lt;= &#123;sel_r[6:0],1&#x27;b0&#125;; //此句也可改为 sel_r &lt;= sel_r &lt;&lt; 1; end //MUX8 (combitional) reg [3:0] data_tmp; always@(*) begin case(sel_r) 8&#x27;b0000_0001: data_tmp = disp_data[3:0]; 8&#x27;b0000_0010: data_tmp = disp_data[7:4]; 8&#x27;b0000_0100: data_tmp = disp_data[11:8]; 8&#x27;b0000_1000: data_tmp = disp_data[15:12]; 8&#x27;b0001_0000: data_tmp = disp_data[19:16]; 8&#x27;b0010_0000: data_tmp = disp_data[23:20]; 8&#x27;b0100_0000: data_tmp = disp_data[27:24]; 8&#x27;b1000_0000: data_tmp = disp_data[31:28]; default: data_tmp = 4&#x27;b0000; endcase end //MUX2 (combitional) always@(*) begin if(~En) sel = 8&#x27;b0000_0000; else sel = sel_r; end //LUT (combitional) //注意：数码管灯段在输入为0时亮起，输入为1时熄灭； //h段为最高位，a段为最低位； always@(*) begin case(data_tmp) 4&#x27;b0000: seg = 7&#x27;b100_0000; //0 4&#x27;b0001: seg = 7&#x27;b111_1001; //1 4&#x27;b0010: seg = 7&#x27;b010_0100; //2 4&#x27;b0011: seg = 7&#x27;b011_0000; //3 4&#x27;b0100: seg = 7&#x27;b001_1001; //4 4&#x27;b0101: seg = 7&#x27;b001_0010; //5 4&#x27;b0110: seg = 7&#x27;b000_0010; //6 4&#x27;b0111: seg = 7&#x27;b111_1000; //7 4&#x27;b1000: seg = 7&#x27;b000_0000; //8 4&#x27;b1001: seg = 7&#x27;b001_0000; //9 4&#x27;b1010: seg = 7&#x27;b000_1000; //a 4&#x27;b1011: seg = 7&#x27;b000_0011; //b 4&#x27;b1100: seg = 7&#x27;b100_0110; //c 4&#x27;b1101: seg = 7&#x27;b010_0001; //d 4&#x27;b1110: seg = 7&#x27;b000_0110; //e 4&#x27;b1111: seg = 7&#x27;b000_1110; //f default: seg = 7&#x27;b111_1111; //全灭 endcase endendmodule TestBench1234567891011121314151617181920212223242526272829303132333435363738394041`timescale 1 ns/ 1 ps`define clk_period 20module digital_display_vlg_tst(); reg Clk; reg En; reg Rst_n; reg [31:0] disp_data; wire [6:0] seg; wire [7:0] sel; digital_display u1 ( .Clk(Clk), .En(En), .Rst_n(Rst_n), .disp_data(disp_data), .seg(seg), .sel(sel) ); initial begin Clk = 1&#x27;b1; forever #(`clk_period/2) Clk = ~Clk; end initial begin Rst_n = 1&#x27;b0; En = 1&#x27;b1; disp_data = 32&#x27;h12345678; #(`clk_period*20); Rst_n = 1&#x27;b1; #(`clk_period*20); #20_000_000; disp_data = 32&#x27;h87654321; #20_000_000; disp_data = 32&#x27;h89abcdef; #20_000_000; $stop; end endmodule 得到的仿真波形： ISSP","text":"实现FPGA驱动数码管动态显示知识点： 数码管动态扫描实现。 In system sources and probes editor (ISSP)调试工具的使用。 工程代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//实现FPGA驱动数码管动态显示module digital_display(Clk, Rst_n, En, disp_data, sel, seg); input Clk; //50M，一个周期为20ns input Rst_n; input En; input [31:0] disp_data; //输入要求显示的内容 output reg [7:0] sel; //数码管位选（当前要显示的数码管） output reg [6:0] seg; //数码管段选（当前要显示的内容） //divider module reg [14:0] divider_cnt; //产生1ms的时钟，每0.5ms时钟信号需要翻转一次，0.5ms/20ns=25_000=16&#x27;b0110_0001_1010_1000，故需要15位计数器 reg Clk_1K; always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) divider_cnt &lt;= 15&#x27;d0; else if(~En) divider_cnt &lt;= 15&#x27;d0; else if(divider_cnt== 15&#x27;d24_999) divider_cnt &lt;= 15&#x27;d0; else divider_cnt &lt;= divider_cnt + 1&#x27;b1; end always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) Clk_1K &lt;= 1&#x27;b0; else if(~En) Clk_1K &lt;= 1&#x27;b0; else if(divider_cnt== 15&#x27;d24_999) Clk_1K &lt;= ~Clk_1K; else Clk_1K &lt;= Clk_1K; end //shift8 module reg [7:0] sel_r; always@(posedge Clk_1K or negedge Rst_n) begin //注意，分频器的输出信号作为D触发器的时钟信号，在大型设计中是不被允许的，此处设计为数码管驱动模块，影响不大，允许存在这样的毛刺 if(~Rst_n) sel_r &lt;= 8&#x27;b0000_0001; else if(sel_r == 8&#x27;b1000_0000) sel_r &lt;= 8&#x27;b0000_0001; else sel_r &lt;= &#123;sel_r[6:0],1&#x27;b0&#125;; //此句也可改为 sel_r &lt;= sel_r &lt;&lt; 1; end //MUX8 (combitional) reg [3:0] data_tmp; always@(*) begin case(sel_r) 8&#x27;b0000_0001: data_tmp = disp_data[3:0]; 8&#x27;b0000_0010: data_tmp = disp_data[7:4]; 8&#x27;b0000_0100: data_tmp = disp_data[11:8]; 8&#x27;b0000_1000: data_tmp = disp_data[15:12]; 8&#x27;b0001_0000: data_tmp = disp_data[19:16]; 8&#x27;b0010_0000: data_tmp = disp_data[23:20]; 8&#x27;b0100_0000: data_tmp = disp_data[27:24]; 8&#x27;b1000_0000: data_tmp = disp_data[31:28]; default: data_tmp = 4&#x27;b0000; endcase end //MUX2 (combitional) always@(*) begin if(~En) sel = 8&#x27;b0000_0000; else sel = sel_r; end //LUT (combitional) //注意：数码管灯段在输入为0时亮起，输入为1时熄灭； //h段为最高位，a段为最低位； always@(*) begin case(data_tmp) 4&#x27;b0000: seg = 7&#x27;b100_0000; //0 4&#x27;b0001: seg = 7&#x27;b111_1001; //1 4&#x27;b0010: seg = 7&#x27;b010_0100; //2 4&#x27;b0011: seg = 7&#x27;b011_0000; //3 4&#x27;b0100: seg = 7&#x27;b001_1001; //4 4&#x27;b0101: seg = 7&#x27;b001_0010; //5 4&#x27;b0110: seg = 7&#x27;b000_0010; //6 4&#x27;b0111: seg = 7&#x27;b111_1000; //7 4&#x27;b1000: seg = 7&#x27;b000_0000; //8 4&#x27;b1001: seg = 7&#x27;b001_0000; //9 4&#x27;b1010: seg = 7&#x27;b000_1000; //a 4&#x27;b1011: seg = 7&#x27;b000_0011; //b 4&#x27;b1100: seg = 7&#x27;b100_0110; //c 4&#x27;b1101: seg = 7&#x27;b010_0001; //d 4&#x27;b1110: seg = 7&#x27;b000_0110; //e 4&#x27;b1111: seg = 7&#x27;b000_1110; //f default: seg = 7&#x27;b111_1111; //全灭 endcase endendmodule TestBench1234567891011121314151617181920212223242526272829303132333435363738394041`timescale 1 ns/ 1 ps`define clk_period 20module digital_display_vlg_tst(); reg Clk; reg En; reg Rst_n; reg [31:0] disp_data; wire [6:0] seg; wire [7:0] sel; digital_display u1 ( .Clk(Clk), .En(En), .Rst_n(Rst_n), .disp_data(disp_data), .seg(seg), .sel(sel) ); initial begin Clk = 1&#x27;b1; forever #(`clk_period/2) Clk = ~Clk; end initial begin Rst_n = 1&#x27;b0; En = 1&#x27;b1; disp_data = 32&#x27;h12345678; #(`clk_period*20); Rst_n = 1&#x27;b1; #(`clk_period*20); #20_000_000; disp_data = 32&#x27;h87654321; #20_000_000; disp_data = 32&#x27;h89abcdef; #20_000_000; $stop; end endmodule 得到的仿真波形： ISSP使用IP核 可以作为探针； 可以作为驱动源（数据源）； 本次实验需要用到的探针宽度为0，数据源宽度为32 完成后，将文件烧录到开发板上，在Tools中找到In-System Sources and Probes Editor 设置改成十六进制，之后直接在data里面设置需要的数据，就可以将数据输入到开发板上","categories":[],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"http://example.com/tags/FPGA/"},{"name":"Verilog","slug":"Verilog","permalink":"http://example.com/tags/Verilog/"}]},{"title":"学习FPGA（三）","slug":"FPGA/FPGA-3","date":"2022-04-15T07:39:43.000Z","updated":"2022-04-29T10:11:03.380Z","comments":true,"path":"2022/04/15/FPGA/FPGA-3/","link":"","permalink":"http://example.com/2022/04/15/FPGA/FPGA-3/","excerpt":"按键消抖主模块三段式状态机代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137//目的：设计一个按键消抖，滤波时间为20ms//晶振为50M，即一个时间周期为20ns//需要滤波1_000_000个时间周期`define filter_time 20&#x27;d1_000_000module key_filter(Clk, Rst_n, Key_in, Key_flag, Key_state); input Clk; //时钟输入 input Rst_n; //复位输入 input Key_in; //按键输入，按下时为0，断开时为1 output reg Key_flag; //按键输入变化后出现稳定状态时，显示为1（保持一个时钟周期），其余时候为0 output reg Key_state; //按键状态，按下时显示为0， 断开时为1 //set state(one-hot code) localparam IDLE = 4&#x27;b0001, FILTER0 = 4&#x27;b0010, DOWN = 4&#x27;b0100, FILTER1 = 4&#x27;b1000; reg [3:0] state, next; //edge check reg Key_tmp0, Key_tmp1; wire Key_posedge, Key_negedge; always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) begin Key_tmp0 &lt;= 1&#x27;b0; Key_tmp1 &lt;= 1&#x27;b0; end else begin Key_tmp0 &lt;= Key_in; //当Key_tmp0 = 1 且 Key_tmp1 = 0时即为一个上升沿 Key_tmp1 &lt;= Key_tmp0; //当Key_tmp0 = 0 且 Key_tmp1 = 1时即为一个下降沿 end end assign Key_posedge = ~Key_tmp1 &amp; Key_tmp0; assign Key_negedge = Key_tmp1 &amp; ~Key_tmp0; //filter counter reg [19:0] cnt; reg cnt_full; //计数器计满信号 reg en_cnt; //计数器使能信号 always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) begin cnt &lt;= &#x27;d0; cnt_full &lt;= 1&#x27;b0; end else if(en_cnt) begin if(cnt == (`filter_time - 1)) begin cnt &lt;= &#x27;d0; cnt_full &lt;= 1&#x27;b1; end else begin cnt &lt;= cnt + 1&#x27;b1; cnt_full &lt;= 1&#x27;b0; end end else begin cnt &lt;= &#x27;d0; cnt_full &lt;= 1&#x27;b0; end end //state transition(combinational) always@(*) begin case(state) IDLE: begin if(Key_negedge) next = FILTER0; else next = IDLE; end FILTER0: begin if(cnt_full) next = DOWN; else if(Key_posedge) next = IDLE; else next = FILTER0; end DOWN: begin if(Key_posedge) next = FILTER1; else next = DOWN; end FILTER1: begin if(cnt_full) next = IDLE; else if(Key_negedge) next = DOWN; else next = FILTER1; end default: next = IDLE; endcase end //state flip-flops(sequential) always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) state &lt;= IDLE; else state &lt;= next; end //output always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) Key_state &lt;= 1&#x27;b0; else case(next) IDLE: begin en_cnt &lt;= 1&#x27;b0; //IDLE状态下计数器不计数 Key_state &lt;= 1&#x27;b1; //此时Key未被按下 Key_flag &lt;= 1&#x27;b0; end FILTER0: begin en_cnt &lt;= 1&#x27;b1; //FILTER0状态下计数器开始计数 Key_state &lt;= 1&#x27;b1; //此时Key仍处于未被按下状态 Key_flag &lt;= 1&#x27;b0; end DOWN: begin en_cnt &lt;= 1&#x27;b0; //DOWN状态下计数器不计数 Key_state &lt;= 1&#x27;b0; //此时Key已被按下 Key_flag &lt;= cnt_full;//探测到Key被按下 end FILTER1: begin en_cnt &lt;= 1&#x27;b1; //FILTER0状态下计数器开始计数 Key_state &lt;= 1&#x27;b0; //此时Key仍处于被按下状态 Key_flag &lt;= 1&#x27;b0; end default: begin en_cnt &lt;= 1&#x27;b0; Key_state &lt;= 1&#x27;b1; Key_flag &lt;= 1&#x27;b0; end endcase end //assign Key_flag = Key_negedge; //组合逻辑输出方式来输出Key_flagendmodule Testbench12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091`timescale 1 ns/ 1 ns`define clk_period 20module key_filter_vlg_tst(); // test vector input registers reg Clk; reg Key_in; reg Rst_n; // wires wire Key_flag; wire Key_state; key_filter i1 ( // port map - connection between master ports and signals/registers .Clk(Clk), .Key_flag(Key_flag), .Key_in(Key_in), .Key_state(Key_state), .Rst_n(Rst_n) ); initial begin Clk = 1&#x27;b1; forever #(`clk_period/2) Clk = ~Clk; end initial begin Rst_n = 1&#x27;b0; Key_in = 1&#x27;b1; #(`clk_period*10) Rst_n = 1&#x27;b1; #(`clk_period*10 + 1); //按下一次 Key_in = 1&#x27;b0;#10000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#5_400_000; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#200; Key_in = 1&#x27;b0;#20_000_100; #10000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#20_000_100; #10_000_000; //second time Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#200; Key_in = 1&#x27;b0;#20_000_100; #10000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#20_000_100; #10000; //third time Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#200; Key_in = 1&#x27;b0;#20_000_100; #10000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#20_000_100; #10000; $stop; endendmodule 仿真模型随机数{$random}默认是32位的随机数，根据自己的需要来取余计算，例如：需要0 ~ 65535的随机数，则可： 12reg [15:0] myrand;initial myrand = &#123;$random&#125;%65536;","text":"按键消抖主模块三段式状态机代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137//目的：设计一个按键消抖，滤波时间为20ms//晶振为50M，即一个时间周期为20ns//需要滤波1_000_000个时间周期`define filter_time 20&#x27;d1_000_000module key_filter(Clk, Rst_n, Key_in, Key_flag, Key_state); input Clk; //时钟输入 input Rst_n; //复位输入 input Key_in; //按键输入，按下时为0，断开时为1 output reg Key_flag; //按键输入变化后出现稳定状态时，显示为1（保持一个时钟周期），其余时候为0 output reg Key_state; //按键状态，按下时显示为0， 断开时为1 //set state(one-hot code) localparam IDLE = 4&#x27;b0001, FILTER0 = 4&#x27;b0010, DOWN = 4&#x27;b0100, FILTER1 = 4&#x27;b1000; reg [3:0] state, next; //edge check reg Key_tmp0, Key_tmp1; wire Key_posedge, Key_negedge; always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) begin Key_tmp0 &lt;= 1&#x27;b0; Key_tmp1 &lt;= 1&#x27;b0; end else begin Key_tmp0 &lt;= Key_in; //当Key_tmp0 = 1 且 Key_tmp1 = 0时即为一个上升沿 Key_tmp1 &lt;= Key_tmp0; //当Key_tmp0 = 0 且 Key_tmp1 = 1时即为一个下降沿 end end assign Key_posedge = ~Key_tmp1 &amp; Key_tmp0; assign Key_negedge = Key_tmp1 &amp; ~Key_tmp0; //filter counter reg [19:0] cnt; reg cnt_full; //计数器计满信号 reg en_cnt; //计数器使能信号 always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) begin cnt &lt;= &#x27;d0; cnt_full &lt;= 1&#x27;b0; end else if(en_cnt) begin if(cnt == (`filter_time - 1)) begin cnt &lt;= &#x27;d0; cnt_full &lt;= 1&#x27;b1; end else begin cnt &lt;= cnt + 1&#x27;b1; cnt_full &lt;= 1&#x27;b0; end end else begin cnt &lt;= &#x27;d0; cnt_full &lt;= 1&#x27;b0; end end //state transition(combinational) always@(*) begin case(state) IDLE: begin if(Key_negedge) next = FILTER0; else next = IDLE; end FILTER0: begin if(cnt_full) next = DOWN; else if(Key_posedge) next = IDLE; else next = FILTER0; end DOWN: begin if(Key_posedge) next = FILTER1; else next = DOWN; end FILTER1: begin if(cnt_full) next = IDLE; else if(Key_negedge) next = DOWN; else next = FILTER1; end default: next = IDLE; endcase end //state flip-flops(sequential) always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) state &lt;= IDLE; else state &lt;= next; end //output always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) Key_state &lt;= 1&#x27;b0; else case(next) IDLE: begin en_cnt &lt;= 1&#x27;b0; //IDLE状态下计数器不计数 Key_state &lt;= 1&#x27;b1; //此时Key未被按下 Key_flag &lt;= 1&#x27;b0; end FILTER0: begin en_cnt &lt;= 1&#x27;b1; //FILTER0状态下计数器开始计数 Key_state &lt;= 1&#x27;b1; //此时Key仍处于未被按下状态 Key_flag &lt;= 1&#x27;b0; end DOWN: begin en_cnt &lt;= 1&#x27;b0; //DOWN状态下计数器不计数 Key_state &lt;= 1&#x27;b0; //此时Key已被按下 Key_flag &lt;= cnt_full;//探测到Key被按下 end FILTER1: begin en_cnt &lt;= 1&#x27;b1; //FILTER0状态下计数器开始计数 Key_state &lt;= 1&#x27;b0; //此时Key仍处于被按下状态 Key_flag &lt;= 1&#x27;b0; end default: begin en_cnt &lt;= 1&#x27;b0; Key_state &lt;= 1&#x27;b1; Key_flag &lt;= 1&#x27;b0; end endcase end //assign Key_flag = Key_negedge; //组合逻辑输出方式来输出Key_flagendmodule Testbench12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091`timescale 1 ns/ 1 ns`define clk_period 20module key_filter_vlg_tst(); // test vector input registers reg Clk; reg Key_in; reg Rst_n; // wires wire Key_flag; wire Key_state; key_filter i1 ( // port map - connection between master ports and signals/registers .Clk(Clk), .Key_flag(Key_flag), .Key_in(Key_in), .Key_state(Key_state), .Rst_n(Rst_n) ); initial begin Clk = 1&#x27;b1; forever #(`clk_period/2) Clk = ~Clk; end initial begin Rst_n = 1&#x27;b0; Key_in = 1&#x27;b1; #(`clk_period*10) Rst_n = 1&#x27;b1; #(`clk_period*10 + 1); //按下一次 Key_in = 1&#x27;b0;#10000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#5_400_000; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#200; Key_in = 1&#x27;b0;#20_000_100; #10000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#20_000_100; #10_000_000; //second time Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#200; Key_in = 1&#x27;b0;#20_000_100; #10000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#20_000_100; #10000; //third time Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#200; Key_in = 1&#x27;b0;#20_000_100; #10000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#20_000_100; #10000; $stop; endendmodule 仿真模型随机数{$random}默认是32位的随机数，根据自己的需要来取余计算，例如：需要0 ~ 65535的随机数，则可： 12reg [15:0] myrand;initial myrand = &#123;$random&#125;%65536; 其中，myrand就是所需的随机数。 task定义一个task如下所示 123456789101112131415161718reg [15:0] myrand;task press_key; begin repeat(50) begin myrand = &#123;$random&#125;%65536; #myrand key_in = ~key_in; end key_in = 0; #50_000_000; repeat(50) begin myrand = &#123;$random&#125;%65536; #myrand key_in = ~key_in; end key_in = 0; #50_000_000; endendtask 然后就可以直接在testbench中使用 1press_key; 仿真模型新建一个key_module文件 123456789101112131415161718192021222324252627282930313233`timescale 1 ns/1 psmodule key_module(key); output reg key; reg [15:0] myrand; initial begin key = 1&#x27;b1; press_key; #10000; press_key; #10000; press_key; $stop; end task press_key; begin repeat(50) begin myrand = &#123;$random&#125;%65536; #myrand key = ~key; end key = 0; #50_000_000; repeat(50) begin myrand = &#123;$random&#125;%65536; #myrand key = ~key; end key = 1; #50_000_000; end endtaskendmodule 使用时需将该文件添加到test bench中，test bench主文件为 12345678910111213141516171819202122232425262728293031323334`timescale 1 ns/ 1 ns`define clk_period 20module key_filter_vlg_tst(); // test vector input registers reg Clk; wire Key_in; reg Rst_n; // wires wire Key_flag; wire Key_state; key_filter i1 ( // port map - connection between master ports and signals/registers .Clk(Clk), .Key_flag(Key_flag), .Key_in(Key_in), .Key_state(Key_state), .Rst_n(Rst_n) ); initial begin Clk = 1&#x27;b1; forever #(`clk_period/2) Clk = ~Clk; end initial begin Rst_n = 1&#x27;b0; #(`clk_period*10) Rst_n = 1&#x27;b1; #(`clk_period*10 + 1) ; end key_module u1(.key(Key_in)); endmodule","categories":[],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"http://example.com/tags/FPGA/"},{"name":"Verilog","slug":"Verilog","permalink":"http://example.com/tags/Verilog/"}]},{"title":"学习FPGA（二）","slug":"FPGA/FPGA-2","date":"2022-04-14T01:38:13.000Z","updated":"2022-04-22T11:29:44.087Z","comments":true,"path":"2022/04/14/FPGA/FPGA-2/","link":"","permalink":"http://example.com/2022/04/14/FPGA/FPGA-2/","excerpt":"有限状态机状态的表示常用编码方法有二进制码、格雷码（Gray code）、独热码（one-hot code）。 二进制码即用二进制计数 优点：属于压缩状态编码，状态机所需的状态向量位数较少； 缺点：1、译码复杂；2、相邻状态变换时，会有多位发生改变，电噪声大、转换速度较慢、易出错；（实际电路中多位改变很难做到完全同时发生）； 格雷码（Gray code）在一组数的编码中，任意两个相邻的代码只有一位二进制数不同，且最大数与最小数之间也仅有一位数不同构造方法：1位格雷码有两个码字(n+1)位格雷码中的前2n个码字等于n位格雷码的码字，按顺序书写，加前缀0(n+1)位格雷码中的后2n个码字等于n位格雷码的码字，按逆序书写，加前缀1n+1位格雷码的集合 &#x3D; n位格雷码集合(顺序)加前缀0 + n位格雷码集合(逆序)加前缀1如：二进制码：000-001-010-011-100-101-110-111 相应的格雷码：000-001-011-010-110-111-101 优点：1、属于压缩状态编码，状态机所需的状态向量位数较少；2、相邻状态变换时，仅有一位发生改变，电噪声小、转换速度较快； 缺点：1、译码复杂；2、是一种变权码，每一位码没有固定的大小，难以直接比较大小和算术运算； 独热码（one-hot code）有多少个状态就有多少个比特，其中有且只有一个比特为1，其余为0用独热码表示三个状态可以写为：001，010，100","text":"有限状态机状态的表示常用编码方法有二进制码、格雷码（Gray code）、独热码（one-hot code）。 二进制码即用二进制计数 优点：属于压缩状态编码，状态机所需的状态向量位数较少； 缺点：1、译码复杂；2、相邻状态变换时，会有多位发生改变，电噪声大、转换速度较慢、易出错；（实际电路中多位改变很难做到完全同时发生）； 格雷码（Gray code）在一组数的编码中，任意两个相邻的代码只有一位二进制数不同，且最大数与最小数之间也仅有一位数不同构造方法：1位格雷码有两个码字(n+1)位格雷码中的前2n个码字等于n位格雷码的码字，按顺序书写，加前缀0(n+1)位格雷码中的后2n个码字等于n位格雷码的码字，按逆序书写，加前缀1n+1位格雷码的集合 &#x3D; n位格雷码集合(顺序)加前缀0 + n位格雷码集合(逆序)加前缀1如：二进制码：000-001-010-011-100-101-110-111 相应的格雷码：000-001-011-010-110-111-101 优点：1、属于压缩状态编码，状态机所需的状态向量位数较少；2、相邻状态变换时，仅有一位发生改变，电噪声小、转换速度较快； 缺点：1、译码复杂；2、是一种变权码，每一位码没有固定的大小，难以直接比较大小和算术运算； 独热码（one-hot code）有多少个状态就有多少个比特，其中有且只有一个比特为1，其余为0用独热码表示三个状态可以写为：001，010，100 优点：译码简单； 缺点：速度较慢，占用触发器资源较多，面积较大； 编写一个检测”Hello”序列的状态机设置状态时，常用localparam或者parameter。其中parameter可用作在顶层模块中例化底层模块时传递参数的接口；而localparam的作用域仅仅限于当前module，不能作为参数传递的接口。 状态机分为一段时状态机、两段式状态机、三段式状态机， 作者第一次写出的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374module state_machine (Clk, Rst_n, data, led); //Hello状态机 input Clk; //基准时钟信号50M input Rst_n; //输入异步复位信号 input [7:0] data; //输入数据 output reg led; //当前状态输入 //set state reg [2:0] state, next; localparam CHECK_H = &#x27;d0, CHECK_e = &#x27;d1, CHECK_la = &#x27;d2, CHECK_lb = &#x27;d3, CHECK_o = &#x27;d4; //state transition (combinational logic) always@(*) begin case(state) CHECK_H: begin if(data == &quot;H&quot;) next = CHECK_e; else next = CHECK_H; end CHECK_e: begin if(data == &quot;e&quot;) next = CHECK_la; else if(data == &quot;H&quot;) next = CHECK_e; else next = CHECK_H; end CHECK_la: begin if(data == &quot;l&quot;) next = CHECK_lb; else if(data == &quot;H&quot;) next = CHECK_e; else next = CHECK_H; end CHECK_lb: begin if(data == &quot;l&quot;) next = CHECK_o; else if(data == &quot;H&quot;) next = CHECK_e; else next = CHECK_H; end CHECK_o: begin if(data == &quot;o&quot;) next = CHECK_H; else if(data == &quot;H&quot;) next = CHECK_e; else next = CHECK_H; end default: next = CHECK_H;//默认状态下reset endcase end //state flip-flops (sequential logic) always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) state &lt;= CHECK_H; else state &lt;= next; end //output always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) led &lt;= 1&#x27;b1; //通常led低电平有效，高电平无效 else case(state) CHECK_o: led &lt;= 1&#x27;b0; default: led &lt;= 1&#x27;b1; endcase endendmodule","categories":[],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"http://example.com/tags/FPGA/"},{"name":"Verilog","slug":"Verilog","permalink":"http://example.com/tags/Verilog/"}]},{"title":"学习FPGA（一）","slug":"FPGA/FPGA-1","date":"2022-04-13T08:50:46.000Z","updated":"2022-05-01T09:14:10.419Z","comments":true,"path":"2022/04/13/FPGA/FPGA-1/","link":"","permalink":"http://example.com/2022/04/13/FPGA/FPGA-1/","excerpt":"刚好今天尝试使用hexo框架搭建了个人博客，索性记录一下自己学习FPGA的过程，方便日后查看和复习。 BCD计数器设计与验证目的是通过将三个BCD计数器级联来实现1000的计数单个BCD计数器的Verilog代码如下： 12345678910111213141516171819202122232425module bcd_counter(Clk, Cin, Rst_n, Cout, Q); input Clk;//时间基准信号 input Cin;//计数器进位输入 input Rst_n;//计数器复位输入 output reg Cout;//计数器进位输出 output reg [3:0] Q;//计数器计数输出 //产生输出进位信号 always@(posedge Clk or negedge Rst_n) begin if(Rst_n==1&#x27;b0) Cout = 1&#x27;b0; else if(Q==4&#x27;d9 &amp;&amp; Cin==1&#x27;b1) Cout = 1&#x27;b1; //此处的进位设置并不合理，级联后会发生错误 else Cout = 1&#x27;b0; end //执行计数过程 always@(posedge Clk or negedge Rst_n) begin if(Rst_n==1&#x27;b0) Q &lt;= 4&#x27;b0; else if(Cin==1&#x27;b1) begin if(Q==4&#x27;d9)Q &lt;= 4&#x27;b0; else Q &lt;= Q + 1&#x27;b1; end else Q &lt;= Q; endendmodule 使用modelsim分析时，先从sim中把子模块的输入输出信号全部添加到波形窗口中然后在波形窗口中选中所有信号（Ctrl+a） 再按下快捷键Ctrl+g，完成按模块分组 将”&#x2F;&#x2F;产生输出进位信号”部分修改为： 12345always@(*) begin if(Rst_n==1&#x27;b0) Cout = 1&#x27;b0; else if(Q==4&#x27;d9 &amp;&amp; Cin==1&#x27;b1) Cout = 1&#x27;b1; else Cout = 1&#x27;b0;end","text":"刚好今天尝试使用hexo框架搭建了个人博客，索性记录一下自己学习FPGA的过程，方便日后查看和复习。 BCD计数器设计与验证目的是通过将三个BCD计数器级联来实现1000的计数单个BCD计数器的Verilog代码如下： 12345678910111213141516171819202122232425module bcd_counter(Clk, Cin, Rst_n, Cout, Q); input Clk;//时间基准信号 input Cin;//计数器进位输入 input Rst_n;//计数器复位输入 output reg Cout;//计数器进位输出 output reg [3:0] Q;//计数器计数输出 //产生输出进位信号 always@(posedge Clk or negedge Rst_n) begin if(Rst_n==1&#x27;b0) Cout = 1&#x27;b0; else if(Q==4&#x27;d9 &amp;&amp; Cin==1&#x27;b1) Cout = 1&#x27;b1; //此处的进位设置并不合理，级联后会发生错误 else Cout = 1&#x27;b0; end //执行计数过程 always@(posedge Clk or negedge Rst_n) begin if(Rst_n==1&#x27;b0) Q &lt;= 4&#x27;b0; else if(Cin==1&#x27;b1) begin if(Q==4&#x27;d9)Q &lt;= 4&#x27;b0; else Q &lt;= Q + 1&#x27;b1; end else Q &lt;= Q; endendmodule 使用modelsim分析时，先从sim中把子模块的输入输出信号全部添加到波形窗口中然后在波形窗口中选中所有信号（Ctrl+a） 再按下快捷键Ctrl+g，完成按模块分组 将”&#x2F;&#x2F;产生输出进位信号”部分修改为： 12345always@(*) begin if(Rst_n==1&#x27;b0) Cout = 1&#x27;b0; else if(Q==4&#x27;d9 &amp;&amp; Cin==1&#x27;b1) Cout = 1&#x27;b1; else Cout = 1&#x27;b0;end 此即行为级建模实现的组合逻辑，但仿真的结果出现了奇怪的毛刺，这是rtl级仿真不该出现的 于是再将其改为： 1assign Cout = (Q==4&#x27;d9 &amp;&amp; Cin==1&#x27;b1); 此即数据流建模实现的组合逻辑。需要注意的是，此时应当将Cout的类型变更为wire型，否则会发生编译错误。 两种建模方式的资源占用率有所不同：","categories":[],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"http://example.com/tags/FPGA/"},{"name":"Verilog","slug":"Verilog","permalink":"http://example.com/tags/Verilog/"}]},{"title":"搭建博客相关问题","slug":"hexo-note","date":"2022-04-13T04:27:06.000Z","updated":"2022-04-30T06:49:59.391Z","comments":true,"path":"2022/04/13/hexo-note/","link":"","permalink":"http://example.com/2022/04/13/hexo-note/","excerpt":"【随时补充】搭建个人博客时遇到的一些问题如何解决无法访问Github在 C:\\Windows\\System32\\drivers\\etc\\hosts 文件中末尾添加两行 12140.82.113.4 github.com140.82.113.4 www.github.com 其中ip地址可在 https://github.com.ipaddress.com/www.github.com 中查询 若完成上述操作后仍无法访问，可以再添加两行 1269.171.224.40 github.global.ssl.fastly.net185.199.111.153 assets-cdn.github.com 其中ip地址可以在 http://tool.chinaz.com/dns 中输入网址查询，选取TTL值较低的ip地址即可 在修改hosts文件时，通常先将其复制到其他路径得到一个副本，将副本修改保存后替换原文件。（建议修改前备份一个hosts文件） 参考：https://www.cnblogs.com/yanch01/p/GitHub-access.html","text":"【随时补充】搭建个人博客时遇到的一些问题如何解决无法访问Github在 C:\\Windows\\System32\\drivers\\etc\\hosts 文件中末尾添加两行 12140.82.113.4 github.com140.82.113.4 www.github.com 其中ip地址可在 https://github.com.ipaddress.com/www.github.com 中查询 若完成上述操作后仍无法访问，可以再添加两行 1269.171.224.40 github.global.ssl.fastly.net185.199.111.153 assets-cdn.github.com 其中ip地址可以在 http://tool.chinaz.com/dns 中输入网址查询，选取TTL值较低的ip地址即可 在修改hosts文件时，通常先将其复制到其他路径得到一个副本，将副本修改保存后替换原文件。（建议修改前备份一个hosts文件） 参考：https://www.cnblogs.com/yanch01/p/GitHub-access.html 修改主题配置在hexo根目录下创建一个_config.[主题名].yml，例如：_config.next.yml，可以覆盖主题目录下_config.yml文件的作用。这样可以在不修改主题_config.yml文件的情况下，很方便的修改主题配置。 styles.styl文件在next 8.x版本中，用户需要自行创建styles.styl文件，放在[hexo根目录]\\source\\_data\\下，注意不是next主题目录下的source文件夹。如果你的source文件夹里没有_data文件夹，创建一个即可。 然后在_config.next.yml中，找到以下代码： 12345678910111213# Define custom file paths.# Create your custom files in site directory `source/_data` and uncomment needed files below.custom_file_path: #head: source/_data/head.njk #header: source/_data/header.njk #sidebar: source/_data/sidebar.njk #postMeta: source/_data/post-meta.njk #postBodyEnd: source/_data/post-body-end.njk #footer: source/_data/footer.njk #bodyEnd: source/_data/body-end.njk #variable: source/_data/variables.styl #mixin: source/_data/mixins.styl #style: source/_data/styles.styl 将其中的style项取消注释，即可通过修改styles.styl的方式来进行个性化设置 1style: source/_data/styles.styl //取消注释，即删去#号 参考：https://github.com/iissnan/hexo-theme-next/issues/680 首行缩进想要在远端部署时实现正文首行缩进2字符，可以在 styles.styl文件中添加： 12//仅正文首行缩进2字符.post-body p &#123; text-indent: 2em; &#125; 制作Table参考：https://theme-next.js.org/docs/tag-plugins/tabs.html 修改tab缩进距离在[hexo根目录]\\source\\_data\\styles.styl文件中添加： 1234567//设置tab-sizepre &#123; tab-size: 4; //数字即是tab的缩进距离&#125;.hljs &#123; tab-size: 4;&#125; 经过尝试后发现，pre对本地部署一定有效，对远端部署我也不知道哪个是有效的，所以就都加上了。 参考：https://github.com/blinkfox/hexo-theme-matery/issues/637 插入图片我用的是typora编辑markdown文件，为了更方便的插入图片，先修改一下typora的设置，在文件—&gt;偏好设置中设置为下图所示： 为hexo安装两个插件： 12npm install hexo-renderer-markednpm install hexo-image-link --save //该插件能够帮助实现路径转换，hexo部署后图片路径与md文件中不同 更改 _config.yml 配置 ： 1post_asset_folder: true //hexo会为文稿生成一个同名文件夹，文稿中所用图片存入文件夹中 参考：https://blog.csdn.net/rentonhe/article/details/123666769","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-04-13T04:19:46.145Z","updated":"2022-04-13T14:39:11.924Z","comments":true,"path":"2022/04/13/hello-world/","link":"","permalink":"http://example.com/2022/04/13/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"FPGA","slug":"FPGA","permalink":"http://example.com/tags/FPGA/"},{"name":"Verilog","slug":"Verilog","permalink":"http://example.com/tags/Verilog/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]}