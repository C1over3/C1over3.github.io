{"meta":{"title":"Clover's blog","subtitle":"迷途的旅人，这里并没有你所寻找的东西","description":"似乎还未到境界...","author":"Clover","url":"http://example.com","root":"/"},"pages":[{"title":"标签","date":"2022-04-22T10:44:58.000Z","updated":"2022-04-29T02:44:19.378Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-04-22T10:45:19.000Z","updated":"2022-04-29T02:44:39.885Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2022-04-22T10:43:37.000Z","updated":"2022-04-22T10:44:44.598Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"似乎是还未到境界…"}],"posts":[{"title":"C++笔记（五）——字符串、向量和数组","slug":"cpp/cpp-note-5","date":"2022-04-27T15:01:00.000Z","updated":"2022-04-28T16:03:03.126Z","comments":true,"path":"2022/04/27/cpp/cpp-note-5/","link":"","permalink":"http://example.com/2022/04/27/cpp/cpp-note-5/","excerpt":"字符串、向量和数组命名空间的using声明： 12using namespaece std; //using声明，获取std中的所有名字using std::cin; //using声明，当我们使用名字cin时，从std中获取它 标准库类型string12#include &lt;string&gt; //一定要包含string头文件using std::string; 定义和初始化string对象几个初始化方式： 1234567string s1; //默认初始化，s1是一个空串string s2(s1); //直接初始化(direct initialization)，s2是s1的副本string s2 = s1; //拷贝初始化(copy initialization)，s2是s1的副本string s3(&quot;value&quot;); //直接初始化，s3是字面值&quot;value&quot;的副本，除了字面值最后的那个空字符外string s3 = &quot;value&quot;; //拷贝初始化，s3是字面值&quot;value&quot;的副本string s4(n, &#x27;c&#x27;); //直接初始化，s4是由连续n个字符c组成的串string s5 = string(10,&#x27;c&#x27;) //拷贝初始化，创建了一个临时对象用于拷贝，s5内容是cccccccccc string对象上的操作读入数量未知的string对象：","text":"字符串、向量和数组命名空间的using声明： 12using namespaece std; //using声明，获取std中的所有名字using std::cin; //using声明，当我们使用名字cin时，从std中获取它 标准库类型string12#include &lt;string&gt; //一定要包含string头文件using std::string; 定义和初始化string对象几个初始化方式： 1234567string s1; //默认初始化，s1是一个空串string s2(s1); //直接初始化(direct initialization)，s2是s1的副本string s2 = s1; //拷贝初始化(copy initialization)，s2是s1的副本string s3(&quot;value&quot;); //直接初始化，s3是字面值&quot;value&quot;的副本，除了字面值最后的那个空字符外string s3 = &quot;value&quot;; //拷贝初始化，s3是字面值&quot;value&quot;的副本string s4(n, &#x27;c&#x27;); //直接初始化，s4是由连续n个字符c组成的串string s5 = string(10,&#x27;c&#x27;) //拷贝初始化，创建了一个临时对象用于拷贝，s5内容是cccccccccc string对象上的操作读入数量未知的string对象： 1234567int main()&#123; string word; while(cin &gt;&gt; word) //反复读取，直到输入文件结束标记 cout &lt;&lt; word &lt;&lt; endl; //逐个输出单词，每个单词之间有一个换行符 return 0;&#125; 读取整行： 1234567int main()&#123; string line; while(getline(cin, line)) //如果输入换行符，会直接结束读取，并返回结果（结果为空string） cout &lt;&lt; line &lt;&lt; endl; //触发getline的换行符被丢弃掉了，所以手动加上换行符 return 0;&#125; empty根据string是否为空返回一个布尔值，可以用来筛除空string 1234567int main() &#123; string line; while (getline(cin,line)) if(!line.empty()) //只有当line是非空string时，才会执行输出 cout &lt;&lt; line &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"牛客网Verilog刷题笔记","slug":"nowcoder-24","date":"2022-04-26T10:12:24.000Z","updated":"2022-04-28T16:05:14.239Z","comments":true,"path":"2022/04/26/nowcoder-24/","link":"","permalink":"http://example.com/2022/04/26/nowcoder-24/","excerpt":"VL24 边沿检测code 1234567891011121314151617181920212223242526272829`timescale 1ns/1nsmodule edge_detect( input clk, input rst_n, input a, output reg rise, output reg down); reg past; always@(posedge clk or negedge rst_n) begin if(~rst_n) past &lt;= 1&#x27;b0; else past &lt;= a; end always@(posedge clk or negedge rst_n) begin if(~rst_n) begin rise &lt;= 1&#x27;b0; down &lt;= 1&#x27;b0; end else begin rise &lt;= ((~past &amp; a) === 1&#x27;b1)? 1 : 0; //使用全等于，避免未知态带来的影响 down &lt;= ((past &amp; ~a) === 1&#x27;b1)? 1 : 0; end endendmodule 进阶挑战VL2 含有无关项的序列检测code 123456789101112131415161718192021222324252627`timescale 1ns/1nsmodule sequence_detect( input clk, input rst_n, input a, output reg match ); //因为存在三位无关项，用状态机需要用到太多状态了，实现起来较为困难 //故使用9位移位寄存器实现 reg [8:0] data; always @(posedge clk or negedge rst_n) begin if (~rst_n) data &lt;= 9&#x27;d0; else data &lt;=&#123;data[7:0], a&#125;; end always @(posedge clk or negedge rst_n) begin if (~rst_n) match &lt;= 1&#x27;b0; else if ((data[8:6]==3&#x27;b011)&amp;(data[2:0]==3&#x27;b110)) //中间三项为无关项 match &lt;= 1&#x27;b1; else match &lt;= 1&#x27;b0; endendmodule VL3 不重叠序列检测移位寄存器方法code 123456789101112131415161718192021222324252627282930313233343536373839404142434445`timescale 1ns/1nsmodule sequence_detect( input clk, input rst_n, input data, output reg match, output reg not_match ); //counter reg [2:0] cnt; always@(posedge clk or negedge rst_n) begin if(~rst_n) cnt &lt;= 3&#x27;d0; else if(cnt == 3&#x27;d6) cnt &lt;= 3&#x27;d1; else cnt &lt;= cnt + 1&#x27;b1; end //shifting register reg [5:0] data_in; always@(posedge clk or negedge rst_n) begin if(~rst_n) data_in &lt;= 6&#x27;d0; else data_in &lt;= &#123;data_in[4:0], data&#125;; end //output always@(*) begin if(cnt == 3&#x27;d6) case(data_in) 6&#x27;b011100: begin match &lt;= 1&#x27;b1; not_match &lt;= 1&#x27;b0; end default: begin match &lt;= 1&#x27;b0; not_match &lt;= 1&#x27;b1; end endcase else begin match &lt;= 1&#x27;b0; not_match &lt;= 1&#x27;b0; end endendmodule 状态机方法code 用状态机方法还是会用到计数器，个人感觉移位寄存器方法要更简单一点，以下是状态机方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667`timescale 1ns/1nsmodule sequence_detect( input clk, input rst_n, input data, output reg match, output reg not_match ); //state machine //counter reg [2:0] cnt; always@(posedge clk or negedge rst_n) begin if(~rst_n) cnt &lt;= 3&#x27;d0; else if(cnt == 3&#x27;d6) cnt &lt;= 3&#x27;d1; else cnt &lt;= cnt + 1&#x27;b1; end //set state localparam IDLE = 0, S0 = 1, S01 = 2, S011 = 3, S0111 = 4, S01110 = 5, S011100 = 6, SErro = 7; reg [2:0] state , next; //state transition always@(*) begin case(state) IDLE : next = data ? SErro : S0; SErro : begin if(cnt == 3&#x27;d6) next = data ? SErro : S0; else next = SErro; end S0 : next = data ? S01 : SErro; S01 : next = data ? S011 : SErro; S011 : next = data ? S0111: SErro; S0111 : next = data ? SErro: S01110; S01110 : next = data ? SErro: S011100; S011100: next = data ? SErro: S0; endcase end //state flip-flops always@(posedge clk or negedge rst_n) begin if(~rst_n) state &lt;= IDLE; else state &lt;= next; end //output always@(*) begin if(~rst_n) begin match &lt;= 1&#x27;b0; not_match &lt;= 1&#x27;b0; end else if(state == S011100) begin match &lt;= 1&#x27;b1; not_match &lt;= 1&#x27;b0; end else if ((state == SErro)&amp;(cnt == 3&#x27;d6)) begin match &lt;= 1&#x27;b0; not_match &lt;= 1&#x27;b1; end else begin match &lt;= 1&#x27;b0; not_match &lt;= 1&#x27;b0; end endendmodule","text":"VL24 边沿检测code 1234567891011121314151617181920212223242526272829`timescale 1ns/1nsmodule edge_detect( input clk, input rst_n, input a, output reg rise, output reg down); reg past; always@(posedge clk or negedge rst_n) begin if(~rst_n) past &lt;= 1&#x27;b0; else past &lt;= a; end always@(posedge clk or negedge rst_n) begin if(~rst_n) begin rise &lt;= 1&#x27;b0; down &lt;= 1&#x27;b0; end else begin rise &lt;= ((~past &amp; a) === 1&#x27;b1)? 1 : 0; //使用全等于，避免未知态带来的影响 down &lt;= ((past &amp; ~a) === 1&#x27;b1)? 1 : 0; end endendmodule 进阶挑战VL2 含有无关项的序列检测code 123456789101112131415161718192021222324252627`timescale 1ns/1nsmodule sequence_detect( input clk, input rst_n, input a, output reg match ); //因为存在三位无关项，用状态机需要用到太多状态了，实现起来较为困难 //故使用9位移位寄存器实现 reg [8:0] data; always @(posedge clk or negedge rst_n) begin if (~rst_n) data &lt;= 9&#x27;d0; else data &lt;=&#123;data[7:0], a&#125;; end always @(posedge clk or negedge rst_n) begin if (~rst_n) match &lt;= 1&#x27;b0; else if ((data[8:6]==3&#x27;b011)&amp;(data[2:0]==3&#x27;b110)) //中间三项为无关项 match &lt;= 1&#x27;b1; else match &lt;= 1&#x27;b0; endendmodule VL3 不重叠序列检测移位寄存器方法code 123456789101112131415161718192021222324252627282930313233343536373839404142434445`timescale 1ns/1nsmodule sequence_detect( input clk, input rst_n, input data, output reg match, output reg not_match ); //counter reg [2:0] cnt; always@(posedge clk or negedge rst_n) begin if(~rst_n) cnt &lt;= 3&#x27;d0; else if(cnt == 3&#x27;d6) cnt &lt;= 3&#x27;d1; else cnt &lt;= cnt + 1&#x27;b1; end //shifting register reg [5:0] data_in; always@(posedge clk or negedge rst_n) begin if(~rst_n) data_in &lt;= 6&#x27;d0; else data_in &lt;= &#123;data_in[4:0], data&#125;; end //output always@(*) begin if(cnt == 3&#x27;d6) case(data_in) 6&#x27;b011100: begin match &lt;= 1&#x27;b1; not_match &lt;= 1&#x27;b0; end default: begin match &lt;= 1&#x27;b0; not_match &lt;= 1&#x27;b1; end endcase else begin match &lt;= 1&#x27;b0; not_match &lt;= 1&#x27;b0; end endendmodule 状态机方法code 用状态机方法还是会用到计数器，个人感觉移位寄存器方法要更简单一点，以下是状态机方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667`timescale 1ns/1nsmodule sequence_detect( input clk, input rst_n, input data, output reg match, output reg not_match ); //state machine //counter reg [2:0] cnt; always@(posedge clk or negedge rst_n) begin if(~rst_n) cnt &lt;= 3&#x27;d0; else if(cnt == 3&#x27;d6) cnt &lt;= 3&#x27;d1; else cnt &lt;= cnt + 1&#x27;b1; end //set state localparam IDLE = 0, S0 = 1, S01 = 2, S011 = 3, S0111 = 4, S01110 = 5, S011100 = 6, SErro = 7; reg [2:0] state , next; //state transition always@(*) begin case(state) IDLE : next = data ? SErro : S0; SErro : begin if(cnt == 3&#x27;d6) next = data ? SErro : S0; else next = SErro; end S0 : next = data ? S01 : SErro; S01 : next = data ? S011 : SErro; S011 : next = data ? S0111: SErro; S0111 : next = data ? SErro: S01110; S01110 : next = data ? SErro: S011100; S011100: next = data ? SErro: S0; endcase end //state flip-flops always@(posedge clk or negedge rst_n) begin if(~rst_n) state &lt;= IDLE; else state &lt;= next; end //output always@(*) begin if(~rst_n) begin match &lt;= 1&#x27;b0; not_match &lt;= 1&#x27;b0; end else if(state == S011100) begin match &lt;= 1&#x27;b1; not_match &lt;= 1&#x27;b0; end else if ((state == SErro)&amp;(cnt == 3&#x27;d6)) begin match &lt;= 1&#x27;b0; not_match &lt;= 1&#x27;b1; end else begin match &lt;= 1&#x27;b0; not_match &lt;= 1&#x27;b0; end endendmodule VL4 输入序列不连续的序列检测code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364`timescale 1ns/1nsmodule sequence_detect( input clk, input rst_n, input data, input data_valid, output reg match ); //state machine //set state localparam IDLE = 0, S0 = 1, S01 = 2, S011 = 3, S0110 = 4; reg [2:0] state, next; //state transition always@(*) begin case(state) IDLE: begin if(data_valid) next = data ? IDLE : S0; else next = IDLE; end S0: begin if(data_valid) next = data ? S01 : S0; else next = IDLE; end S01: begin if(data_valid) next = data ? S011 : S0; else next = IDLE; end S011: begin if(data_valid) next = data ? IDLE : S0110; else next = IDLE; end S0110: begin if(data_valid) next = data ? S01 : S0; else next = IDLE; end endcase end //state flip-flops always@(posedge clk or negedge rst_n) begin if(~rst_n) state &lt;= IDLE; else state &lt;= next; end //output always@(posedge clk or negedge rst_n) begin if(~rst_n) match &lt;= 1&#x27;b0; else case(next) S0110: match &lt;= 1&#x27;b1; default: match &lt;= 1&#x27;b0; endcase endendmodule VL5 信号发生器 （这道题蛮难的）code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758`timescale 1ns/1nsmodule signal_generator( input clk, input rst_n, input [1:0] wave_choise, output reg [4:0]wave ); //counter (only for retangular wave) reg [4:0] cnt; always@(posedge clk or negedge rst_n) begin if(~rst_n | (wave_choise != 2&#x27;b00)) cnt &lt;= 5&#x27;d0; else if(cnt == 5&#x27;d19) cnt &lt;= 5&#x27;d0; else cnt &lt;= cnt + 1&#x27;b1; end //delta wave flag (only for delta wave) reg flag; always@(posedge clk or negedge rst_n) begin if(~rst_n | (wave_choise != 2&#x27;b10)) flag &lt;= 1&#x27;b1; else if(wave == 5&#x27;d1) flag &lt;= 1&#x27;b0; else if(wave == 5&#x27;d19) flag &lt;= 1&#x27;b1; end //output always@(posedge clk or negedge rst_n) begin if(~rst_n) wave &lt;= 5&#x27;d0; else case(wave_choise) 2&#x27;b00: begin if(cnt == 5&#x27;d19) wave &lt;= 5&#x27;d0; else if(cnt == 5&#x27;d9) wave &lt;= 5&#x27;d20; end 2&#x27;b01: begin if(wave == 5&#x27;d20) wave &lt;= 5&#x27;d0; else wave &lt;= wave + 1&#x27;b1; end 2&#x27;b10: begin if(wave == 5&#x27;d20) //考虑到刚好在wave=20以及wave=0时发生波形变化 wave &lt;= wave - 1&#x27;b1; // else if(wave == 5&#x27;d0) // wave &lt;= wave + 1&#x27;b1; // else if(flag) wave &lt;= wave - 1&#x27;b1; else wave &lt;= wave + 1&#x27;b1; end default: wave &lt;= 5&#x27;d0; endcase endendmodule VL6 数据串转并电路code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657`timescale 1ns/1nsmodule s_to_p( input clk , input rst_n , input valid_a , input data_a , output reg ready_a , output reg valid_b , output reg [5:0] data_b); //根据题意，一直拉高ready_a always@(posedge clk or negedge rst_n) begin if(~rst_n) ready_a &lt;= 1&#x27;b0; else ready_a &lt;= 1&#x27;b1; end //counter reg [2:0] cnt; always@(posedge clk or negedge rst_n) begin if(~rst_n) cnt &lt;= 3&#x27;d0; else if(valid_a &amp; ready_a) begin //输入数据有效时，counter才开始计数 if(cnt == 3&#x27;d5) cnt &lt;= 3&#x27;d0; else cnt &lt;= cnt + 1&#x27;b1; end else cnt &lt;= cnt; end //6-bit shifting register reg [5:0] data_temp; always@(posedge clk or negedge rst_n) begin if(~rst_n) data_temp &lt;= 6&#x27;b0; else if(valid_a &amp; ready_a) data_temp &lt;= &#123;data_a, data_temp[5:1]&#125;; //最新的输入数据存放在最高位 end //output always@(posedge clk or negedge rst_n) begin if(~rst_n) begin valid_b &lt;= 1&#x27;b0; data_b &lt;= 6&#x27;b000000; end else if(cnt == 3&#x27;d5) begin valid_b &lt;= 1&#x27;b1; data_b &lt;= &#123;data_a, data_temp[5:1]&#125;; //此时的输出应当是最新的1位输入和计数时暂存的5位拼接而成 end else begin valid_b &lt;= 1&#x27;b0; data_b &lt;= data_b; end endendmodule VL7 数据累加输出 （抄的答案，这题还需加深理解）code 1234567891011121314151617181920212223242526272829303132333435363738394041`timescale 1ns/1nsmodule valid_ready( input clk , input rst_n , input [7:0] data_in , input valid_a , input ready_b , output ready_a , output reg valid_b , output reg [9:0] data_out); reg [1:0] data_cnt; assign ready_a = ~valid_b | ready_b; //表示下游准备好接受本模块的输出或者本模块还没有产生有效输出时，本模块可以接受上游的输出。如此保证不会产生数据丢失，且保持本模块保持满速。 always @(posedge clk or negedge rst_n ) begin if(~rst_n) data_cnt &lt;= &#x27;d0; else if(valid_a &amp;&amp; ready_a) data_cnt &lt;= (data_cnt == 2&#x27;d3) ? &#x27;d0 : (data_cnt + 1&#x27;d1); end always @(posedge clk or negedge rst_n ) begin if(~rst_n) valid_b &lt;= &#x27;d0; else if(data_cnt == 2&#x27;d3 &amp;&amp; valid_a &amp;&amp; ready_a) valid_b &lt;= 1&#x27;d1; else if(valid_b &amp;&amp; ready_b) valid_b &lt;= 1&#x27;d0; end always @(posedge clk or negedge rst_n ) begin if(~rst_n) data_out &lt;= &#x27;d0; else if(ready_b &amp;&amp; valid_a &amp;&amp; ready_a &amp;&amp; (data_cnt == 2&#x27;d0)) data_out &lt;= data_in; else if(valid_a &amp;&amp; ready_a) data_out &lt;= data_out + data_in; endendmodule VL8 非整数倍数据位宽转换24to128 （看懂了VL7，这题就感觉蛮简单了）Solution 1Solution2折叠表格123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566`timescale 1ns/1nsmodule width_24to128( input clk , input rst_n , input valid_in , input [23:0] data_in , output reg valid_out , output reg [127:0] data_out); //16-counter reg [3:0] cnt; always@(posedge clk or negedge rst_n) begin if(~rst_n) cnt &lt;= 4&#x27;b0; else if(valid_in) cnt &lt;= cnt + 1&#x27;b1; end //output valid_out always@(posedge clk or negedge rst_n) begin if(~rst_n) valid_out &lt;= 1&#x27;b0; else if((cnt == 4&#x27;d5)|(cnt == 4&#x27;d10)|(cnt == 4&#x27;d15)) valid_out &lt;= 1&#x27;b1; else valid_out &lt;= 1&#x27;b0; end //output data reg [23:0] data_temp1; //设置data_temp1用以缓存一个data_in always@(posedge clk or negedge rst_n) begin if(~rst_n) data_temp1 &lt;= 24&#x27;b0; else if(valid_in) data_temp1 &lt;= data_in; end reg [128:0] data_temp2; //设置data_temp2只是为了迎合牛客网的tb，它的tb要求在输出无效时，输出必须为0，故用data_temp2作为移位寄存器 always@(posedge clk or negedge rst_n) begin if(~rst_n) data_temp2 &lt;= 128&#x27;b0; else if(valid_in) begin if(cnt == 4&#x27;d5) data_temp2 &lt;= &#123;data_temp2[119:0], data_in[23:16]&#125;; //5*24 + 8 = 128 else if(cnt == 4&#x27;d6) data_temp2 &lt;= &#123;data_temp2[87:0], data_temp1[15:0], data_in&#125;; else if(cnt == 4&#x27;d10) data_temp2 &lt;= &#123;data_temp2[111:0], data_in[23:8]&#125;; //16 + 24*4 + 16 = 128 else if(cnt == 4&#x27;d11) data_temp2 &lt;= &#123;data_temp2[95:0], data_temp1[7:0], data_in&#125;; else data_temp2 &lt;= &#123;data_temp2[103:0], data_in&#125;; //8 + 24*5 = 128 end end always@(posedge clk or negedge rst_n) begin if(~rst_n) data_out &lt;= 128&#x27;b0; else if(valid_in) begin if(cnt == 4&#x27;d5) data_out &lt;= &#123;data_temp2[119:0], data_in[23:16]&#125;; //5*24 + 8 = 128 else if(cnt == 4&#x27;d10) data_out &lt;= &#123;data_temp2[111:0], data_in[23:8]&#125;; //16 + 24*4 + 16 = 128 else if(cnt == 4&#x27;d15) data_out &lt;= &#123;data_temp2[103:0], data_in&#125;; //8 + 24*5 = 128 end endendmodule修改后占用资源更少： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152`timescale 1ns/1nsmodule width_24to128( input clk , input rst_n , input valid_in , input [23:0] data_in , output reg valid_out , output reg [127:0] data_out); //16-counter reg [3:0] cnt; always@(posedge clk or negedge rst_n) begin if(~rst_n) cnt &lt;= 4&#x27;b0; else if(valid_in) cnt &lt;= cnt + 1&#x27;b1; end //output valid_out always@(posedge clk or negedge rst_n) begin if(~rst_n) valid_out &lt;= 1&#x27;b0; else if((cnt == 4&#x27;d5)|(cnt == 4&#x27;d10)|(cnt == 4&#x27;d15)&amp;valid_in) valid_out &lt;= 1&#x27;b1; else valid_out &lt;= 1&#x27;b0; end //output data //cnt==5时，data_temp的值为&#123;data_in_0[7:0],data_in_1,data_in_2,data_in_3,data_in_4,data_in_5&#125;； //cnt==9时，data_temp的值为&#123;data_in_4[7:0],data_in_5,data_in_6,data_in_7,data_in_8,data_in_9&#125;； //cnt==14时，data_temp的值为&#123;data_in_9[7:0],data_in_10,data_in_11,data_in_12,data_in_13,data_in_14&#125; reg [128:0] data_temp; always@(posedge clk or negedge rst_n) begin if(~rst_n) data_temp &lt;= 128&#x27;b0; else if(valid_in) data_temp &lt;= &#123;data_temp[103:0], data_in&#125;; end always@(posedge clk or negedge rst_n) begin if(~rst_n) data_out &lt;= 128&#x27;b0; else if(valid_in) begin if(cnt == 4&#x27;d5) data_out &lt;= &#123;data_temp[119:0], data_in[23:16]&#125;; //5*24 + 8 = 128 else if(cnt == 4&#x27;d10) data_out &lt;= &#123;data_temp[111:0], data_in[23:8]&#125;; //16 + 24*4 + 16 = 128 else if(cnt == 4&#x27;d15) data_out &lt;= &#123;data_temp[103:0], data_in&#125;; //8 + 24*5 = 128 end endendmodule VL9 非整数倍数据位宽转换8to12Solution 1Solution2折叠表格123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566`timescale 1ns/1nsmodule width_8to12( input clk , input rst_n , input valid_in , input [7:0] data_in , output reg valid_out, output reg [11:0] data_out); //counter reg [1:0] cnt; always@(posedge clk or negedge rst_n) begin if(~rst_n) cnt &lt;= 2&#x27;b0; else if(valid_in) begin if(cnt == 2&#x27;b10) cnt &lt;= 2&#x27;b0; else cnt &lt;= cnt + 1&#x27;b1; end end //output valid_out always@(posedge clk or negedge rst_n) begin if(~rst_n) valid_out &lt;= 1&#x27;b0; else if(((cnt == 2&#x27;b01) | (cnt == 2&#x27;b10)) &amp; valid_in) valid_out &lt;= 1&#x27;b1; else valid_out &lt;= 1&#x27;b0; end //shifting register reg [7:0] data_temp1; reg [11:0] data_temp2; always@(posedge clk or negedge rst_n) begin if(~rst_n) data_temp1 &lt;= 8&#x27;b0; else if(valid_in) data_temp1 &lt;= data_in; end always@(posedge clk or negedge rst_n) begin if(~rst_n) data_temp2 &lt;= 8&#x27;b0; else if(valid_in) begin if(cnt == 2&#x27;b01) data_temp2 &lt;= &#123;data_temp2[7:0], data_in[7:4]&#125;; else if(cnt == 2&#x27;b10) data_temp2 &lt;= &#123;data_temp1[3:0], data_in&#125;; else data_temp2 &lt;= &#123;data_temp2[3:0], data_in&#125;; end end always@(posedge clk or negedge rst_n) begin if(~rst_n) data_out &lt;= 12&#x27;b0; else if(valid_in) begin if(cnt == 2&#x27;b01) data_out &lt;= &#123;data_temp2[7:0], data_in[7:4]&#125;; else if(cnt == 2&#x27;b10) data_out &lt;= &#123;data_temp1[3:0], data_in&#125;; end endendmodule修改后资源占用更少： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152`timescale 1ns/1nsmodule test( input clk , input rst_n , input valid_in , input [7:0] data_in , output reg valid_out, output reg [11:0] data_out); //counter reg [1:0] cnt; always@(posedge clk or negedge rst_n) begin if(~rst_n) cnt &lt;= 2&#x27;b0; else if(valid_in) begin if(cnt == 2&#x27;b10) cnt &lt;= 2&#x27;b0; else cnt &lt;= cnt + 1&#x27;b1; end end //output valid_out always@(posedge clk or negedge rst_n) begin if(~rst_n) valid_out &lt;= 1&#x27;b0; else if(((cnt == 2&#x27;b01) | (cnt == 2&#x27;b10)) &amp; valid_in) valid_out &lt;= 1&#x27;b1; else valid_out &lt;= 1&#x27;b0; end //shifting register reg [11:0] data_temp; always@(posedge clk or negedge rst_n) begin if(~rst_n) data_temp &lt;= 12&#x27;b0; else if(valid_in) data_temp &lt;= &#123;data_temp[3:0], data_in&#125;; end always@(posedge clk or negedge rst_n) begin if(~rst_n) data_out &lt;= 12&#x27;b0; else if(valid_in) begin if(cnt == 2&#x27;b01) data_out &lt;= &#123;data_temp[7:0], data_in[7:4]&#125;; else if(cnt == 2&#x27;b10) data_out &lt;= &#123;data_temp[3:0], data_in&#125;; end endendmodule VL10 整数倍数据位宽转换8to16code 1234567891011121314151617181920212223242526272829303132333435363738394041424344`timescale 1ns/1nsmodule width_8to16( input clk, input rst_n, input valid_in, input [7:0] data_in, output reg valid_out, output reg [15:0] data_out); //counter reg cnt; always@(posedge clk or negedge rst_n) begin if(~rst_n) cnt &lt;= 1&#x27;b0; else if(valid_in) cnt &lt;= cnt + 1&#x27;b1; end //output valid_out always@(posedge clk or negedge rst_n) begin if(~rst_n) valid_out &lt;= 1&#x27;b0; else if((cnt == 1&#x27;b1) &amp; valid_in) valid_out &lt;= 1&#x27;b1; else valid_out &lt;= 1&#x27;b0; end //shifting register reg [7:0] data_temp; //整数倍转换只需要一个寄存器 always@(posedge clk or negedge rst_n) begin if(~rst_n) data_temp &lt;= 8&#x27;b0; else if(valid_in) data_temp &lt;= data_in; end always@(posedge clk or negedge rst_n) begin if(~rst_n) data_out &lt;= 16&#x27;b0; else if((cnt== 1&#x27;b1) &amp; valid_in) data_out &lt;= &#123;data_temp, data_in&#125;; endendmodule VL11 状态机-非重叠的序列检测code 用了一个很常规的三段式状态机： 1234567891011121314151617181920212223242526272829303132333435363738394041`timescale 1ns/1nsmodule sequence_test1( input wire clk , input wire rst , //这里的rst其实是低电平有效，但是题目给的名字时rst input wire data , output reg flag);//*************code***********// //set state localparam IDLE = 0, S1 = 1, S10 = 2, S101 = 3, S1011 = 4, S10111 = 5; reg [2:0] state, next; //state transition always@(*) begin case(state) IDLE: next = data ? S1 : IDLE ; S1: next = data ? S1 : S10 ; S10: next = data ? S101 : IDLE ; S101: next = data ? S1011 : S10 ; S1011: next = data ? S10111: S10 ; S10111: next = data ? S1 : IDLE ; endcase end //state flip-flops always@(posedge clk or negedge rst) begin if(~rst) state &lt;= IDLE; else state &lt;= next; end //output always@(posedge clk or negedge rst) begin if(~rst) flag &lt;= 1&#x27;b0; else case(next) S10111: flag &lt;= 1&#x27;b1; default: flag &lt;= 1&#x27;b0; endcase end//*************code***********//endmodule VL12 状态机-重叠序列检测code 12345678910111213141516171819202122232425262728293031323334353637383940`timescale 1ns/1nsmodule sequence_test2( input wire clk , input wire rst , //这里的rst其实是低电平有效，但是题目给的名字时rst input wire data , output reg flag);//*************code***********// //set state localparam IDLE = 0, S1 = 1, S10 = 2, S101 = 3, S1011 = 4; reg [2:0] state, next; //state transition always@(*) begin case(state) IDLE: next = data ? S1 : IDLE ; S1: next = data ? S1 : S10 ; S10: next = data ? S101 : IDLE ; S101: next = data ? S1011 : S10 ; S1011: next = data ? S1 : S10 ; endcase end //state flip-flops always@(posedge clk or negedge rst) begin if(~rst) state &lt;= IDLE; else state &lt;= next; end //output always@(posedge clk or negedge rst) begin if(~rst) flag &lt;= 1&#x27;b0; else case(state) S1011: flag &lt;= 1&#x27;b1; default: flag &lt;= 1&#x27;b0; endcase end//*************code***********//endmodule VL13 时钟分频（偶数）有计数器无计数器折叠表格123456789101112131415161718192021222324252627282930313233343536373839404142`timescale 1ns/1nsmodule even_div ( input wire rst , //这里的rst其实是低电平有效，但是题目给的名字时rst input wire clk_in, output reg clk_out2, output reg clk_out4, output reg clk_out8 );//*************code***********// //counter reg [1:0] cnt; always@(posedge clk_in or negedge rst) begin if(~rst) cnt &lt;= 3&#x27;d0; else cnt &lt;= cnt + 1&#x27;b1; end //clk_out2 always@(posedge clk_in or negedge rst) begin if(~rst) clk_out2 &lt;= 1&#x27;b0; else clk_out2 &lt;= ~clk_out2; end //clk_out4 always@(posedge clk_in or negedge rst) begin if(~rst) clk_out4 &lt;= 1&#x27;b0; else if((cnt == 2&#x27;d0) | (cnt == 2&#x27;d2)) clk_out4 &lt;= ~clk_out4; end //clk_out8 always@(posedge clk_in or negedge rst) begin if(~rst) clk_out8 &lt;= 1&#x27;b0; else if(cnt == 2&#x27;d0) clk_out8 &lt;= ~clk_out8; end//*************code***********//endmodule不含计数器的做法，实际使用时不推荐： 12345678910111213141516171819202122232425262728293031323334`timescale 1ns/1nsmodule even_div ( input wire rst , //这里的rst其实是低电平有效，但是题目给的名字时rst input wire clk_in, output reg clk_out2, output reg clk_out4, output reg clk_out8 );//*************code***********// //clk_out2 always@(posedge clk_in or negedge rst) begin if(~rst) clk_out2 &lt;= 1&#x27;b0; else clk_out2 &lt;= ~clk_out2; end //clk_out4 always@(posedge clk_out2 or negedge rst) begin if(~rst) clk_out4 &lt;= 1&#x27;b0; else clk_out4 &lt;= ~clk_out4; end //clk_out8 always@(posedge clk_out4 or negedge rst) begin if(~rst) clk_out8 &lt;= 1&#x27;b0; else clk_out8 &lt;= ~clk_out8; end//*************code***********//endmodule 此方法在低频信号中可以使用，但是在高频时钟下会出现失误， 在FPGA中所有的时钟都要连接到全局时钟网络中去，又叫全局时钟数，其目的是为了保证时钟信号到达每一个器件的时间都尽可能相同，而这种方法并没有连接到全局时钟网络中 。 想要改进，可以使用脉冲标志信号，即在每个所需周期末尾输出一个clk_flag脉冲信号，利用always@(posedge clk or negedge rst_n) 和if(clk_flag = 1&#39;b1)达到分频的目的。 VL14 自动贩售机1状态机方法非状态机方法折叠表格因为题目中的d1，d2，d3只输入半个周期高电平，所以需要增加3个寄存器来存放输入，写出来的代码有点笨重： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142`timescale 1ns/1nsmodule seller1( input wire clk , input wire rst , input wire d1 , input wire d2 , input wire d3 , output reg out1, output reg [1:0]out2);//*************code***********// //state machine //set state localparam IDLE = 0, S05 = 1, S10 = 2, S15 = 3, S20 = 4, S25 = 5, S30 = 6; reg [2:0] state, next; //state transition reg rg1, rg2, rg3; //save d1, d2, d3 always@(posedge clk or negedge rst) begin if(~rst) begin rg1 &lt;= 0; rg2 &lt;= 0; rg3 &lt;= 0; end else begin rg1 &lt;= d1; rg2 &lt;= d2; rg3 &lt;= d3; end end always@(*) begin case(state) IDLE: begin if(rg3) next = S20; else if(rg2) next = S10; else if(rg1) next = S05; else next = IDLE; end S05: begin if(rg3) next = S25; else if(rg2) next = S15; else if(rg1) next = S10; else next = S05; end S10: begin if(rg3) next = S30; else if(rg2) next = S20; else if(rg1) next = S15; else next = S10; end S15: begin if(rg3) next = S20; else if(rg2) next = S10; else if(rg1) next = S05; else next = IDLE; end S20: begin if(rg3) next = S20; else if(rg2) next = S10; else if(rg1) next = S05; else next = IDLE; end S25: begin if(rg3) next = S20; else if(rg2) next = S10; else if(rg1) next = S05; else next = IDLE; end S30: begin if(rg3) next = S20; else if(rg2) next = S10; else if(rg1) next = S05; else next = IDLE; end endcase end //state flip-flps always@(posedge clk or negedge rst) begin if(~rst) state &lt;= IDLE; else state &lt;= next; end //output always@(posedge clk or negedge rst) begin if(~rst) begin out1 &lt;= 1&#x27;b0; out2 &lt;= 2&#x27;b0; end else case(next) S15: begin out1 &lt;= 1&#x27;b1; out2 &lt;= 2&#x27;b0; end S20: begin out1 &lt;= 1&#x27;b1; out2 &lt;= 2&#x27;b1; end S25: begin out1 &lt;= 1&#x27;b1; out2 &lt;= 2&#x27;d2; end S30: begin out1 &lt;= 1&#x27;b1; out2 &lt;= 2&#x27;d3; end default: begin out1 &lt;= 1&#x27;b0; out2 &lt;= 2&#x27;b0; end endcase end//*************code***********//endmodule从代码量来看都能看出比状态机方法简单一些 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657`timescale 1ns/1nsmodule seller1( input wire clk , input wire rst , input wire d1 , input wire d2 , input wire d3 , output reg out1, output reg [1:0]out2);//*************code***********// reg [2:0] money05; //accumulating money always@(posedge clk or negedge rst) begin if(~rst) money05 &lt;= 3&#x27;d0; else if((money05[2]==1) | (money05[1:0]==2&#x27;b11)) //此时累积金钱大于3 * 0.5元 money05 &lt;= 3&#x27;d0; else case(&#123;d3, d2, d1&#125;) 3&#x27;b001: money05 &lt;= money05 + 1&#x27;d1; 3&#x27;b010: money05 &lt;= money05 + 2&#x27;d2; 3&#x27;b100: money05 &lt;= money05 + 3&#x27;d4; default: money05 &lt;= money05; endcase end //output always@(posedge clk or negedge rst) begin if(~rst) begin out1 &lt;= 1&#x27;b0; out2 &lt;= 2&#x27;d0; end else case(money05) //根据累积金钱来判断输出 3&#x27;d3: begin out1 &lt;= 1&#x27;b1; out2 &lt;= 2&#x27;d0; end 3&#x27;d4: begin out1 &lt;= 1&#x27;b1; out2 &lt;= 2&#x27;d1; end 3&#x27;d5: begin out1 &lt;= 1&#x27;b1; out2 &lt;= 2&#x27;d2; end 3&#x27;d6: begin out1 &lt;= 1&#x27;b1; out2 &lt;= 2&#x27;d3; end default: begin out1 &lt;= 1&#x27;b0; out2 &lt;= 2&#x27;d0; end endcase end//*************code***********//endmodule VL15 自动贩售机2code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465`timescale 1ns/1nsmodule seller2( input wire clk , input wire rst , input wire d1 , input wire d2 , input wire sel , output reg out1, output reg out2, output reg out3);//*************code***********// reg [2:0] money05; //accumulating money always@(posedge clk or negedge rst) begin if(~rst) money05 &lt;= 3&#x27;d0; //判断是否满足出饮料的条件 else if(((money05[2] | (money05[1] &amp; money05[0])) &amp; ~sel) | (money05[2] &amp; (money05[1] | money05[0]) &amp; sel)) money05 &lt;= 3&#x27;d0; else case(&#123;d2, d1&#125;) 2&#x27;b01: money05 &lt;= money05 + 1&#x27;d1; 2&#x27;b10: money05 &lt;= money05 + 2&#x27;d2; default: money05 &lt;= money05; endcase end //output always@(posedge clk or negedge rst) begin if(~rst) begin out1 &lt;= 1&#x27;b0; out2 &lt;= 1&#x27;b0; out3 &lt;= 2&#x27;d0; end else case(money05) //根据累积金钱来判断输出 3&#x27;d3: begin out1 &lt;= sel ? 1&#x27;b0 : 1&#x27;b1; out2 &lt;= 1&#x27;b0; out3 &lt;= 2&#x27;d0; end 3&#x27;d4: begin out1 &lt;= sel ? 1&#x27;b0 : 1&#x27;b1; out2 &lt;= 1&#x27;b0; out3 &lt;= sel ? 2&#x27;d0 : 2&#x27;d1; end 3&#x27;d5: begin out1 &lt;= sel ? 1&#x27;b0 : 1&#x27;b1; out2 &lt;= sel ? 1&#x27;b1 : 1&#x27;b0; out3 &lt;= sel ? 2&#x27;d0 : 2&#x27;d2; end 3&#x27;d6: begin out1 &lt;= sel ? 1&#x27;b0 : 1&#x27;b1; out2 &lt;= sel ? 1&#x27;b1 : 1&#x27;b0; out3 &lt;= sel ? 2&#x27;d1 : 2&#x27;d3; end default: begin out1 &lt;= 1&#x27;b0; out2 &lt;= 1&#x27;b0; out3 &lt;= 2&#x27;d0; end endcase end//*************code***********//endmodule VL16 占空比50%的奇数分频 （这题是重点！！）code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950`timescale 1ns/1nsmodule odo_div_or ( input wire rst, input wire clk_in, output wire clk_out7);//*************code***********// localparam N = 7; //counter_p reg [2:0] cnt_p; always@(posedge clk_in or negedge rst) begin if(~rst) cnt_p &lt;= 3&#x27;b0; else if(cnt_p == N-1) cnt_p &lt;= 3&#x27;b0; else cnt_p &lt;= cnt_p + 1&#x27;b1; end //clk_p reg clk_p; always@(posedge clk_in or negedge rst) begin if(~rst) clk_p &lt;= 1&#x27;b0; else if((cnt_p == (N-1)/2) | (cnt_p == N-1)) clk_p &lt;= ~clk_p; end //counter_n reg [2:0] cnt_n; always@(negedge clk_in or negedge rst) begin if(~rst) cnt_n &lt;= 3&#x27;b0; else if(cnt_n == N-1) cnt_n &lt;= 3&#x27;b0; else cnt_n &lt;= cnt_n + 1&#x27;b1; end //clk_n reg clk_n; always@(negedge clk_in or negedge rst) begin if(~rst) clk_n &lt;= 1&#x27;b0; else if((cnt_n == (N-1)/2) | (cnt_n == N-1)) clk_n &lt;= ~clk_n; end //output assign clk_out7 = clk_p | clk_n;//*************code***********//endmodule","categories":[],"tags":[{"name":"Verilog","slug":"Verilog","permalink":"http://example.com/tags/Verilog/"}]},{"title":"C++问题笔记","slug":"cpp-note","date":"2022-04-24T08:20:24.000Z","updated":"2022-04-29T02:30:39.983Z","comments":true,"path":"2022/04/24/cpp-note/","link":"","permalink":"http://example.com/2022/04/24/cpp-note/","excerpt":"启用括号包围在visual studio中，工具—&gt;选项—&gt;高级，可以启用括号包围，","text":"启用括号包围在visual studio中，工具—&gt;选项—&gt;高级，可以启用括号包围，","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++笔记（四）——自定义数据结构","slug":"cpp/cpp-note-4","date":"2022-04-23T12:58:08.000Z","updated":"2022-04-27T15:00:25.706Z","comments":true,"path":"2022/04/23/cpp/cpp-note-4/","link":"","permalink":"http://example.com/2022/04/23/cpp/cpp-note-4/","excerpt":"自定义数据结构数据结构是把一组相关的数据元素组织起来然后使用它们的策略和方法，如Sales_item类，把书本的ISBN编号、售出量和销售收入等数据组织在了一起，并且提供如isbn函数、&gt;&gt;、&lt;&lt;、+、+&#x3D;等运算在内的一系列操作，Sales_item类就是一个数据结构。 C++允许用户以类的形式自定义数据类型。 定义Sales_data类型在第七章之前，都使用struct（结构体）来自定义数据类型： 12345struct Sales_data&#123; std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;&#125;; //注意：类体右侧的表示结束的花括号后必须写一个分号，因为类体后面可以紧跟变量名以示对该类型对象的定义 {}中的三条语句定义了struct的数据成员(data member)，C++11新标准规定，可以为数据成员提供一个类内初始值(in-class initializer)，没有初始值的成员将被默认初始化。 千万牢记，定义数据类型的{}之后一定要有分号，而定义函数的{}之后则不需要分号。 定义该类型的对象： 1234struct Sales_data&#123;/*...*/&#125; accum, trans, *salesptr;//以下两条语句等同于上一条语句，但更易读一些struct Sales_data&#123;/*...*/&#125;;Sales_data accum, trans, *salesptr;","text":"自定义数据结构数据结构是把一组相关的数据元素组织起来然后使用它们的策略和方法，如Sales_item类，把书本的ISBN编号、售出量和销售收入等数据组织在了一起，并且提供如isbn函数、&gt;&gt;、&lt;&lt;、+、+&#x3D;等运算在内的一系列操作，Sales_item类就是一个数据结构。 C++允许用户以类的形式自定义数据类型。 定义Sales_data类型在第七章之前，都使用struct（结构体）来自定义数据类型： 12345struct Sales_data&#123; std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;&#125;; //注意：类体右侧的表示结束的花括号后必须写一个分号，因为类体后面可以紧跟变量名以示对该类型对象的定义 {}中的三条语句定义了struct的数据成员(data member)，C++11新标准规定，可以为数据成员提供一个类内初始值(in-class initializer)，没有初始值的成员将被默认初始化。 千万牢记，定义数据类型的{}之后一定要有分号，而定义函数的{}之后则不需要分号。 定义该类型的对象： 1234struct Sales_data&#123;/*...*/&#125; accum, trans, *salesptr;//以下两条语句等同于上一条语句，但更易读一些struct Sales_data&#123;/*...*/&#125;;Sales_data accum, trans, *salesptr; 补充：cout标准输出(standard output)，cerr标准错误(standard error)，clog用来输出程序运行时的一般性信息。 编写自己的头文件类一般都不定义在函数体内。为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在的头文件的名字应与类的名字一样。 头文件通常包含哪些只能被定义一次的实体(entity)，如类、const和constexpr变量（定义时添加extern关键字）等。 确保头文件多次包含仍能安全工作的常用技术是预处理器(preprocessor)，它由C++语言从C语言里继承而来。#include就是一项预处理功能，当预处理器看到#include标记时就会用指定的头文件内容代替#include。 C++还会用到一项预处理功能是头文件保护符(header guard)，依赖于预处理变量。预处理变量有两种状态：已定义和未定义。#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真。 如此可以有效防止重复包含： 123456789#ifndef SALES_DATA_H //变量未定义时检查结果为真，执行后续操作直到#endif为止#define SALES_DATA_H //把SALES_DATA_H设定为预处理变量#include &lt;string&gt;struct Sales_data&#123; std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;&#125;;#endif 头文件保护符必须唯一，通常是基于头文件中类的名字来构建保护符的名字。为了避免与程序中的其他实体发生名字冲突，一般吧预处理变量的名字全部大写。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++笔记（三）——处理类型","slug":"cpp/cpp-note-3","date":"2022-04-23T04:12:45.000Z","updated":"2022-04-25T14:10:11.305Z","comments":true,"path":"2022/04/23/cpp/cpp-note-3/","link":"","permalink":"http://example.com/2022/04/23/cpp/cpp-note-3/","excerpt":"常量表达式和constexpr常量表达式(const expression)1234const int max_files = 20; //max_files是常量表达式const int limit = max_filse + 1; //limit是常量表达式int staff_size = 27; //staff_size不是常量表达式const int sz = get_size(); //sz不是常量表达式，其具体值在程序运行时才能获得，而不是编译时获得 在复杂系统中，无法分辨一个初始值到底是不是常量表达式。这种情况下，对象的定义和使用根本就是两回事儿。 constexpr变量C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。 123constexpr int mf = 20;constexpr int limit = mf + 1;constexpr int sz = size(); //只有当size是一个constexpr函数时，这才是一条正确语句 同时C++11新标准也允许定义一种constexpr函数，这种函数必须简单到在编译时就可以计算其结果，这样就能用constexpr函数去初始化constexpr变量。 在声明constexpr时，用到的类型只能是字面值类型 字面值类型(literal type)","text":"常量表达式和constexpr常量表达式(const expression)1234const int max_files = 20; //max_files是常量表达式const int limit = max_filse + 1; //limit是常量表达式int staff_size = 27; //staff_size不是常量表达式const int sz = get_size(); //sz不是常量表达式，其具体值在程序运行时才能获得，而不是编译时获得 在复杂系统中，无法分辨一个初始值到底是不是常量表达式。这种情况下，对象的定义和使用根本就是两回事儿。 constexpr变量C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。 123constexpr int mf = 20;constexpr int limit = mf + 1;constexpr int sz = size(); //只有当size是一个constexpr函数时，这才是一条正确语句 同时C++11新标准也允许定义一种constexpr函数，这种函数必须简单到在编译时就可以计算其结果，这样就能用constexpr函数去初始化constexpr变量。 在声明constexpr时，用到的类型只能是字面值类型 字面值类型(literal type)目前接触过的数据类型中，算术类型、引用和指针都属于字面值类型，但被定义成constexpr的指针初值必须输nullptr或者0，或者存储于某个固定地址中的对象。 函数体内定义的变量一般并非存放在固定地址中，所有函数体之外的对象其地址固定不变。函数体内允许定义一类有效范围超出函数本身的变量，该变量夜游固定地址。 constexpr指针constexpr声明中定义了一个指针，限定符constexpr只对指针有效： 12const int* p = nullptr; //p是一个指向整型常量的指针constexpr int* q = nullptr; //q是一个指向整数的常量指针 处理类型类型别名(type alias)传统定义方法 12typedef double wages; //wages是double的同义词typedef wages base, * p; //base是double的同义词，p是double*的同义词 C++11新标准定义方法 1using SI = Sales_item; //SI是Sales_item的同义词 类型别名引入的易错点，从右向左读可以轻松理解以下语句 1234typedef char * pstring; //pstring是char*的同义词，此时pstring的基本数据类型是指针const pstring cstr = 0; //const限定了pstring，即基本数据类型是const pstring，指向char的常量指针const char * cstr = 0; //const限定了char，即基本数据类型是const char，指向char常量的指针const pstring * ps; //ps是一个指针，其所指对象是一个指向char的常量指针 auto类型说明符编程时常常需要把表达式的值赋给变量，这就要求声明变量时清楚地知道表达式的类型。C++11新标准引入了auto类型说明符，它可以分析表达式所属的类型 auto定义的变量必须有初始值，用以推断该变量的类型： 1auto item = val1 + val2; //item初始化为val1和val2相加的结果，由该结果可以推断出item的类型 auto可以在一条语句中定义多个变量，由于一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样： 12auto i = 0, * p = &amp;i; //正确：i是整数、p是整型指针auto sz = 0, pi = 3.14; //错误：sz和pi的类型不一致 auto一般会忽略顶层const，但保留底层const： 123456int i = 0;const int ci = i, &amp;cr = ci;auto b = ci; //b是一个普通整数auto c = cr; //c是一个普通整数（cr只是ci的别名，实际参与初始化的是被引用对象ci）auto d = &amp;i; //d是一个普通整型指针auto e = &amp;ci; //e是一个指向整数常量的指针（对常量对象取地址是一种底层const） 如果希望通过auto定义一个顶层const对象，则需要： 123const auto f = ci;auto&amp; r1 = 42; //错误：不能为非常量引用绑定字面值const auto&amp; r2 = 42; //正确：可以为常量引用绑定字面值 当设置一个类型为auto的引用时，顶层常量属性仍然保留，即得到的引用具有底层常量属性： 123const int i = 1; //i具有顶层常量属性auto&amp; r = i; //r是一个对整数常量的引用，此时r是一个对常量的引用r = 100; //错误：不可修改对常量的引用所引用的对象 切记，auto只是推断声明符的类型，而&amp;和*只是声明符的修饰符 在声明语句中，*声明一个指针变量，&amp;声明一个对象引用；在定义语句中，*取指针所指向的数据，&amp;取对象的地址。 decltype类型说明符C++11新标准引入了decltype，用于从表达式的类型推断出要定义的变量的类型，但是并不用该表达式的值初始化变量。 1decltype(f()) sum = x; //sum的类型就是f()的返回类型 decltype处理顶层const和引用的方式与auto不同： 1234const int ci = 0, &amp; cj = ci;decltype(ci) x = 0; //x的类型是const intdecltype(cj) y = x; //y的类型是const int&amp;，y绑定到常量xdecltype(cj) z; //错误：z是一个引用，必须初始化 上述例子中，在decltype()中ci和cj不是一个同义词，而在其他任何地方，cj都是ci的同义词 几个需要注意的点 123456int i = 42, * p = &amp;i, &amp; r = i;decltype(r + 0) b; //正确：尽管r是一个引用，但加法的结果是int而非一个引用，因此b是一个未初始化的intdecltype(*p) c; //错误：表达式内容是解引用操作，则decltype得到引用类型，故c是int&amp;，必须初始化decltype((i)) d; //错误：d是int&amp;，必须初始化decltype(i) e; //正确：e是一个未初始化的intdecltype((i + 0)) f; //正确：f是一个未初始化的int 上述例子中，当变量i被加上了一层括号时，编译器会把它当成一个表达式，而变量是一种可以作为赋值语句左值的特殊表达式，所以decltype((i))的结果类型是一个引用类型int&amp; 练习2.36 12345int a = 3, b = 4;decltype(a) c = a;decltype((b)) d = a; //d是一个引用，被引用的对象是a++c;++d; //d是a的同义词，实际进行操作时将d替换为a 上述代码中，c是int型，d是int&amp;型，最后a、b、c、d四个值都是4 练习2.37 如果i是int，则表达式i&#x3D;x的类型是int&amp; 123int a = 3, b = 4;decltype(a) c = a; //c是一个整数，初始化为adecltype(a = b) d = a; //d是一个引用，被引用的对象是a","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++笔记（二）——const限定符","slug":"cpp/cpp-note-2","date":"2022-04-20T09:47:51.000Z","updated":"2022-04-23T12:37:31.137Z","comments":true,"path":"2022/04/20/cpp/cpp-note-2/","link":"","permalink":"http://example.com/2022/04/20/cpp/cpp-note-2/","excerpt":"const限定符const对象const对象一旦创建后其值就不可改变，因此必须初始化； 123const int i = get_size(); //正确：运行时初始化，get_size()为有返回值的函数const int j = 42; //正确：编译时初始化const int k; //错误：k是一个未经初始化的常量 默认状态下，const对象仅在文件内有效，因为编译器将在编译过程中会把用到该变量的地方都替换成对应的值，每个用了const对象的文件都必须含有对它的定义而非声明；如：在test1中 12const int i = 1; //定义全局常量i，初始化为1int j = 2; //定义全局变量j，初始化为2 test2中 1234567#include &lt;iostream&gt;using namespace std;int main() &#123; extern int i; cout &lt;&lt; i &lt;&lt; endl; return 0;&#125; test3中 1234567#include &lt;iostream&gt;using namespace std;int main() &#123; extern int j; cout &lt;&lt; j &lt;&lt; endl; return 0;&#125;","text":"const限定符const对象const对象一旦创建后其值就不可改变，因此必须初始化； 123const int i = get_size(); //正确：运行时初始化，get_size()为有返回值的函数const int j = 42; //正确：编译时初始化const int k; //错误：k是一个未经初始化的常量 默认状态下，const对象仅在文件内有效，因为编译器将在编译过程中会把用到该变量的地方都替换成对应的值，每个用了const对象的文件都必须含有对它的定义而非声明；如：在test1中 12const int i = 1; //定义全局常量i，初始化为1int j = 2; //定义全局变量j，初始化为2 test2中 1234567#include &lt;iostream&gt;using namespace std;int main() &#123; extern int i; cout &lt;&lt; i &lt;&lt; endl; return 0;&#125; test3中 1234567#include &lt;iostream&gt;using namespace std;int main() &#123; extern int j; cout &lt;&lt; j &lt;&lt; endl; return 0;&#125; 其中test2会报错error LNK2001: 无法解析的外部符号 “int i”；而test3中能够得到输出2。对于一种const变量，它的初始值不是一个常量表达式，如果想只在一个文件中定义这类const对象，而且在其他多个文件中声明并使用它，方法如下： 1234//file_1.cpp中extern const int bufSize = fcn();//file_1.h中extern const int bufSize; //与file_1.cpp中定义的bufSize是同一个 对常量的引用(reference to const)“对常量的引用”可以简称为“常量引用”，因为引用不是一个对象，所以实际上不存在常量引用 对常量进行引用时，引用也必须为常量 12345const int ci = 1034;const int &amp;r1 = ci; //正确：引用及其对应的对象都是常量r1 = 42; //错误：r1是对常量的引用，不可改变其值int &amp;r2 = ci; //错误：试图让一个非常量引用指向一个常量对象 常量引用的两个例外（待补充） 初始化常量引用时允许用任意表达式作为初值，只要其结果能够转换成常量引用的类型即可 12345int i = 42;const int &amp;r1 = i; //允许将const int&amp;绑定到一个普通int对象上const int &amp;r2 = 42; //正确const int &amp;r3 = r1 * 2; //正确int &amp;r4 = r4 * 2; //错误：r4是一个普通的非常量引用 原因：在使用常量引用时，系编译器生成了一个与该常量引用同类型的临时量(temporary)对象，再将常量引用绑定在这个临时量对象上。 常量引用绑定的对象可以是非const对象 12345int i =42;int &amp;r1 = i; //引用ri绑定对象iconst int &amp;r2 = i; //r2也绑定对象i，当时不允许通过r2修改i的值r1 = 0; //r1并非常量，i的值修改为0r2 = 0; //错误：r2是一个常量引用，不可通过r2修改i的值 指向常量的指针(pointer to const)指向常量的指针不能用于改变其所指对象的值；要想存放常量对象的地址，只能使用指向常量的指针。 指向常量的指针的两个例外（待补充） 允许一个指向常量的指针指向一个非常量对象，指向常量的指针没有规定其所指对象必须是一个常量 1234const double pi = 3.14; double *ptr = &amp;pi; //错误：ptr是一个普通指针const double *cptr = &amp;pi; //正确：cptr可以指向一个双精度常量*cptr = 42; //错误：不能给*cptr赋值 原因同“对常量的引用” ps：所谓指向常量的指针或常量引用，不过是指针或引用“自以为是”罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象的值。 const指针引用不是对象，而指针是对象，因此允许把指针本身定义为常量，即常量指针(const pointer)。常量指针必须初始化，而且一旦初始化后，它的值（存放在指针中的地址）就不能再改变了。把*放在const关键字之前，这样书写说明不变的是指针而非指针指向的那个值。 12345678910#include &lt;iostream&gt;using namespace std;int main() &#123; int errNumb = 0; int* const curErr = &amp;errNumb; //curErr是一个常量指针 const double pi = 3.14159; const double* const pip1 = &amp;pi; //pip是一个指向常量的常量指针 double* const pip2 = &amp;pi; //错误：pip2并不是一个指向常量的指针，不能“const double*”类型的值不能用于初始化“double* const”类型的实体 return 0;&#125; 指针本身是常量，不代表不能通过指针修改其所指对象的值，能否这样做取决于所指对象的类型，即可以通过常量指针修改非常量对象的值。 1234567int i = 1;int j = 0;int k = 2;int* const p = &amp;i;*p = j; //正确：改变p的值（地址）存放的对象的值，即把i赋值为j，但并没有改变p的值（地址） //此操作后i = 0， j = 0， k = 2；p = &amp;k; //错误：此操作为把p赋值为k的地址，而p是一个常量指针，其值不可改变 建议：想要弄清这些声明的含义，最有效的方法是从右向左阅读 练习2.27 1const int &amp;const r2 = 0; //错误：引用不是对象，没有常量引用，只有对常量的引用 虽然有的编译器会自动忽略掉&amp;后的const，但切记不要这样做。 顶层const和底层const顶层const(top-level const)：表示指针本身是一个常量 底层const(low-level const)：表示指针所指对象是一个常量 更一般的，顶层const表示任意的对象是常量，底层const表示指针和引用等所指对象和所引用对象是常量。 123456789101112131415int i = 0;int* const p1 = &amp;i; //不能改变p1的值，这是一个顶层constconst int ci = 42; //不能改变ci的值，这是一个顶层constconst int* p2 = &amp;ci; //允许改变p2的值，但不能改变p2所指对象的值，这是一个底层constconst int* const p3 = p2; //靠近p3的const是顶层，远离p3的const是底层const int&amp; r1 = ci; //用于声明引用的const都是底层i = ci; //正确：拷贝ci的值，ci是一个顶层const，对此操作无影响p2 = p3; //正确：p2和p3所指对象类型相同，即两者都是底层常量，p2不是顶层const，其值可以改变，p3顶层const部分不影响int* p = p3; //错误：p3包含底层const对象，即p3所指对象为常量，而p所指对象不是，故不能将p3的值赋予pint* p = &amp; *p3; //该操作完全同上，&amp;和*互为逆操作p2 = &amp;i; //正确：int*能转换成const int*，即底层非常量可以转换为底层常量int&amp; r2 = ci; //错误：非常量int&amp;不能绑定到int常量上const int&amp; r3 = i; //正确：常量int&amp;可以绑定到int非常量上 提示：顶层const的对象初始化后不能被赋值，底层const的对象不能改变其所指或所引用对象的值，非底层const的对象不能拷贝底层const的对象。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++笔记（一）——变量和复合类型","slug":"cpp/cpp-note-1","date":"2022-04-18T04:07:01.000Z","updated":"2022-04-23T12:37:05.127Z","comments":true,"path":"2022/04/18/cpp/cpp-note-1/","link":"","permalink":"http://example.com/2022/04/18/cpp/cpp-note-1/","excerpt":"不同初始化方式的区别12345678910#include &lt;iostream&gt;using namespace std;int main() &#123; long double ld = 3.1415926536; int a&#123; ld &#125;, b = &#123; ld &#125;; //错误：会提示error C2397: 从“long double”转换到“int”需要收缩转换 int c(ld), d = ld;//能够完成编译，且确实丢失了部分值，c和d输出均为3 cout &lt;&lt; a &lt;&lt; &quot;\\t&quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; c &lt;&lt; &quot;\\t&quot; &lt;&lt; d &lt;&lt; endl; return 0;&#125; 对于局部变量来说，初始化很重要；在编写某个类的时候，尽量申明当该类的某个对象未被显式初始化时，生成一个合适的默认值。 声明和定义C++支持分离式编译(separate compilation) 声明(declaration)：使得某个名字为程序所知，即这个变量已经在别处定义了，我现在拿来用。（声明一个其他地方定义过的全局变量） 定义(definition)：创建与名字关联的实体。 123extern int i; //声明i而非定义i，但如果显式初始化后则会抵消了extern的作用int j; //定义jextern double pi = 3.1416; //定义pi，且初始化为3.1416 在函数内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。 ps: C++是一种静态类型（statically typed）语言，其含义是在编译阶段执行类型检查（type checking）。如果编译器发现数据类型不支持要执行的运算，则会报错且不会生成任何可执行的程序。程序越复杂，静态类型检查越有助于发现问题。这要求我们在使用某个变量之前必须声明其类型。","text":"不同初始化方式的区别12345678910#include &lt;iostream&gt;using namespace std;int main() &#123; long double ld = 3.1415926536; int a&#123; ld &#125;, b = &#123; ld &#125;; //错误：会提示error C2397: 从“long double”转换到“int”需要收缩转换 int c(ld), d = ld;//能够完成编译，且确实丢失了部分值，c和d输出均为3 cout &lt;&lt; a &lt;&lt; &quot;\\t&quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; c &lt;&lt; &quot;\\t&quot; &lt;&lt; d &lt;&lt; endl; return 0;&#125; 对于局部变量来说，初始化很重要；在编写某个类的时候，尽量申明当该类的某个对象未被显式初始化时，生成一个合适的默认值。 声明和定义C++支持分离式编译(separate compilation) 声明(declaration)：使得某个名字为程序所知，即这个变量已经在别处定义了，我现在拿来用。（声明一个其他地方定义过的全局变量） 定义(definition)：创建与名字关联的实体。 123extern int i; //声明i而非定义i，但如果显式初始化后则会抵消了extern的作用int j; //定义jextern double pi = 3.1416; //定义pi，且初始化为3.1416 在函数内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。 ps: C++是一种静态类型（statically typed）语言，其含义是在编译阶段执行类型检查（type checking）。如果编译器发现数据类型不支持要执行的运算，则会报错且不会生成任何可执行的程序。程序越复杂，静态类型检查越有助于发现问题。这要求我们在使用某个变量之前必须声明其类型。 标识符(identifier)变量命名规范： 标识符要体现实际含义； 变量名一般用小写字母，如index； 用户自定义的类名一般以大写字母开头，如Sales_item； 如果标识符由多个单词组成，则单词间要有明显区分，如student_loan或studentLoan； 建议：当第一次使用变量时再定义它，即随用随定义 有助于找到变量的定义； 可以赋予一个合理的初始值； 防止在程序一开始初始化一堆未用到的变量，从而拖慢运行速度； 作用域(scope)123456789#include &lt;iostream&gt;using namespace std;int i = 420, sum = 0;int main() &#123; for (int i = 0; i != 10; i++) //for()中的i作用域仅在()之中 sum += i; cout &lt;&lt; i &lt;&lt; &quot;\\t&quot; &lt;&lt; sum &lt;&lt; endl; //得到的输出为420 45 return 0;&#125; 12345678910#include &lt;iostream&gt;using namespace std;int i = 420, sum = 0;int main() &#123; int i = 100; //覆盖了全局变量i for (int i = 0; i != 10; i++) //for()中的i作用域仅在()之中 sum += i; cout &lt;&lt; ::i &lt;&lt; &quot;\\t&quot; &lt;&lt; i &lt;&lt; &quot;\\t&quot; &lt;&lt; sum &lt;&lt; endl; //得到的输出为420 100 45 return 0;&#125; 引用(reference)引用并非对象，而是为一个已经存在的对象所起的别名，不需要独立的内存空间； 引用初始化后，无法再令该引用重新绑定到另一个对象，因此引用必须初始化； 因为引用并非一个对象，所以不能定义引用的引用； 引用的类型必须与引用绑定的对象严格匹配。 12345678910111213#include &lt;iostream&gt;using namespace std;int main() &#123; int ival = 1024; int &amp;refVal0 = ival; //正确 int &amp;refVal1 = refVal; //正确：实际上是以与引用绑定的对象再定义了另一个引用 int &amp;refVal2; //错误：没有初始化引用 int &amp;refVal3 = &amp;refVal1; //错误：不能定义引用的引用 double dval = 3.14; int &amp;refVal4 = dval; //错误：类型不匹配 refVal = 0; return 0;&#125; 指针(pointer)指针本身就是一个对象，需要独立的内存空间; 指针初始化后，可以通过赋值来改变指针的值或指针指向的对象； 因为指针是一个对象，所以可以定义指针的指针； 指针的类型必须与指针的对象严格匹配。 指针的值（即地址）属于下列4中状态之一： 指向一个对象 指向紧邻对象所占空间的下一个位置 空指针，没有指向任何对象 无效指针，上述情况之外的其他值 建议： 初始化所有指针； 尽量定义了对象之后再定义指向它的指针； 如果实在不清楚指针应该指向何处，就先初始化为nullptr或者0； 1234int ival1 = 0, ival2 = 1;int *pi = &amp;ival1;pi = &amp;ival2; //pi的值被改变，现在pi指向了ival，或者说pi的值变成了存放ival的地址*pi = 0; //ival的值被改变，指针pi并没有改变 赋值改变的永远是&#x3D;左侧的对象！！！ void* 指针是一种特殊的指针类型，可以存放任意对象的地址。它可以用于和其他指针比较、作为函数的输入输出、赋值给另一个void* 指针。但是，不能对它所指向的对象进行操作，因为我们并不知道这个对象到底是什么类型。 概括来讲，void* 的视角来看，内存空间仅仅只是内存空间，没办法访问内存空间中所存的对象。 练习2.18 123456789101112131415#include &lt;iostream&gt;using namespace std;int main() &#123; int ival1 = 1, ival2 = 1, ival3 = 4; int* p1 = &amp;ival1, * p2 = &amp;ival2; //改变指针的值 cout &lt;&lt; p1 &lt;&lt; &quot;\\t&quot; &lt;&lt; ival1 &lt;&lt; &quot;\\t&quot; &lt;&lt; ival3 &lt;&lt; endl; p1 = &amp;ival3; cout &lt;&lt; p1 &lt;&lt; &quot;\\t&quot; &lt;&lt; ival1 &lt;&lt; &quot;\\t&quot; &lt;&lt; ival3 &lt;&lt; endl; //改变指针指向对象的值 cout &lt;&lt; p2 &lt;&lt; &quot;\\t&quot; &lt;&lt; *p2 &lt;&lt; &quot;\\t&quot; &lt;&lt; ival2 &lt;&lt; endl; *p2 = 100; cout &lt;&lt; p2 &lt;&lt; &quot;\\t&quot; &lt;&lt; *p2 &lt;&lt; &quot;\\t&quot; &lt;&lt; ival2 &lt;&lt; endl; return 0;&#125; 练习2.23 设给定指针为p 123int ival = 0;if(p) ival = 1;else ival = 2; //这个if...else...可以判断出p是否有一个合法的值（即合法地址）","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"学习FPGA（四）","slug":"FPGA/FPGA-4","date":"2022-04-17T02:57:24.000Z","updated":"2022-04-26T08:09:33.929Z","comments":true,"path":"2022/04/17/FPGA/FPGA-4/","link":"","permalink":"http://example.com/2022/04/17/FPGA/FPGA-4/","excerpt":"实现FPGA驱动数码管动态显示知识点： 数码管动态扫描实现。 In system sources and probes editor (ISSP)调试工具的使用。 工程代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//实现FPGA驱动数码管动态显示module digital_display(Clk, Rst_n, En, disp_data, sel, seg); input Clk; //50M，一个周期为20ns input Rst_n; input En; input [31:0] disp_data; //输入要求显示的内容 output reg [7:0] sel; //数码管位选（当前要显示的数码管） output reg [6:0] seg; //数码管段选（当前要显示的内容） //divider module reg [14:0] divider_cnt; //产生1ms的时钟，每0.5ms时钟信号需要翻转一次，0.5ms/20ns=25_000=16&#x27;b0110_0001_1010_1000，故需要15位计数器 reg Clk_1K; always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) divider_cnt &lt;= 15&#x27;d0; else if(~En) divider_cnt &lt;= 15&#x27;d0; else if(divider_cnt== 15&#x27;d24_999) divider_cnt &lt;= 15&#x27;d0; else divider_cnt &lt;= divider_cnt + 1&#x27;b1; end always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) Clk_1K &lt;= 1&#x27;b0; else if(~En) Clk_1K &lt;= 1&#x27;b0; else if(divider_cnt== 15&#x27;d24_999) Clk_1K &lt;= ~Clk_1K; else Clk_1K &lt;= Clk_1K; end //shift8 module reg [7:0] sel_r; always@(posedge Clk_1K or negedge Rst_n) begin //注意，分频器的输出信号作为D触发器的时钟信号，在大型设计中是不被允许的，此处设计为数码管驱动模块，影响不大，允许存在这样的毛刺 if(~Rst_n) sel_r &lt;= 8&#x27;b0000_0001; else if(sel_r == 8&#x27;b1000_0000) sel_r &lt;= 8&#x27;b0000_0001; else sel_r &lt;= &#123;sel_r[6:0],1&#x27;b0&#125;; //此句也可改为 sel_r &lt;= sel_r &lt;&lt; 1; end //MUX8 (combitional) reg [3:0] data_tmp; always@(*) begin case(sel_r) 8&#x27;b0000_0001: data_tmp = disp_data[3:0]; 8&#x27;b0000_0010: data_tmp = disp_data[7:4]; 8&#x27;b0000_0100: data_tmp = disp_data[11:8]; 8&#x27;b0000_1000: data_tmp = disp_data[15:12]; 8&#x27;b0001_0000: data_tmp = disp_data[19:16]; 8&#x27;b0010_0000: data_tmp = disp_data[23:20]; 8&#x27;b0100_0000: data_tmp = disp_data[27:24]; 8&#x27;b1000_0000: data_tmp = disp_data[31:28]; default: data_tmp = 4&#x27;b0000; endcase end //MUX2 (combitional) always@(*) begin if(~En) sel = 8&#x27;b0000_0000; else sel = sel_r; end //LUT (combitional) //注意：数码管灯段在输入为0时亮起，输入为1时熄灭； //h段为最高位，a段为最低位； always@(*) begin case(data_tmp) 4&#x27;b0000: seg = 7&#x27;b100_0000; //0 4&#x27;b0001: seg = 7&#x27;b111_1001; //1 4&#x27;b0010: seg = 7&#x27;b010_0100; //2 4&#x27;b0011: seg = 7&#x27;b011_0000; //3 4&#x27;b0100: seg = 7&#x27;b001_1001; //4 4&#x27;b0101: seg = 7&#x27;b001_0010; //5 4&#x27;b0110: seg = 7&#x27;b000_0010; //6 4&#x27;b0111: seg = 7&#x27;b111_1000; //7 4&#x27;b1000: seg = 7&#x27;b000_0000; //8 4&#x27;b1001: seg = 7&#x27;b001_0000; //9 4&#x27;b1010: seg = 7&#x27;b000_1000; //a 4&#x27;b1011: seg = 7&#x27;b000_0011; //b 4&#x27;b1100: seg = 7&#x27;b100_0110; //c 4&#x27;b1101: seg = 7&#x27;b010_0001; //d 4&#x27;b1110: seg = 7&#x27;b000_0110; //e 4&#x27;b1111: seg = 7&#x27;b000_1110; //f default: seg = 7&#x27;b111_1111; //全灭 endcase endendmodule TestBench1234567891011121314151617181920212223242526272829303132333435363738394041`timescale 1 ns/ 1 ps`define clk_period 20module digital_display_vlg_tst(); reg Clk; reg En; reg Rst_n; reg [31:0] disp_data; wire [6:0] seg; wire [7:0] sel; digital_display u1 ( .Clk(Clk), .En(En), .Rst_n(Rst_n), .disp_data(disp_data), .seg(seg), .sel(sel) ); initial begin Clk = 1&#x27;b1; forever #(`clk_period/2) Clk = ~Clk; end initial begin Rst_n = 1&#x27;b0; En = 1&#x27;b1; disp_data = 32&#x27;h12345678; #(`clk_period*20); Rst_n = 1&#x27;b1; #(`clk_period*20); #20_000_000; disp_data = 32&#x27;h87654321; #20_000_000; disp_data = 32&#x27;h89abcdef; #20_000_000; $stop; end endmodule 得到的仿真波形： ISSP","text":"实现FPGA驱动数码管动态显示知识点： 数码管动态扫描实现。 In system sources and probes editor (ISSP)调试工具的使用。 工程代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//实现FPGA驱动数码管动态显示module digital_display(Clk, Rst_n, En, disp_data, sel, seg); input Clk; //50M，一个周期为20ns input Rst_n; input En; input [31:0] disp_data; //输入要求显示的内容 output reg [7:0] sel; //数码管位选（当前要显示的数码管） output reg [6:0] seg; //数码管段选（当前要显示的内容） //divider module reg [14:0] divider_cnt; //产生1ms的时钟，每0.5ms时钟信号需要翻转一次，0.5ms/20ns=25_000=16&#x27;b0110_0001_1010_1000，故需要15位计数器 reg Clk_1K; always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) divider_cnt &lt;= 15&#x27;d0; else if(~En) divider_cnt &lt;= 15&#x27;d0; else if(divider_cnt== 15&#x27;d24_999) divider_cnt &lt;= 15&#x27;d0; else divider_cnt &lt;= divider_cnt + 1&#x27;b1; end always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) Clk_1K &lt;= 1&#x27;b0; else if(~En) Clk_1K &lt;= 1&#x27;b0; else if(divider_cnt== 15&#x27;d24_999) Clk_1K &lt;= ~Clk_1K; else Clk_1K &lt;= Clk_1K; end //shift8 module reg [7:0] sel_r; always@(posedge Clk_1K or negedge Rst_n) begin //注意，分频器的输出信号作为D触发器的时钟信号，在大型设计中是不被允许的，此处设计为数码管驱动模块，影响不大，允许存在这样的毛刺 if(~Rst_n) sel_r &lt;= 8&#x27;b0000_0001; else if(sel_r == 8&#x27;b1000_0000) sel_r &lt;= 8&#x27;b0000_0001; else sel_r &lt;= &#123;sel_r[6:0],1&#x27;b0&#125;; //此句也可改为 sel_r &lt;= sel_r &lt;&lt; 1; end //MUX8 (combitional) reg [3:0] data_tmp; always@(*) begin case(sel_r) 8&#x27;b0000_0001: data_tmp = disp_data[3:0]; 8&#x27;b0000_0010: data_tmp = disp_data[7:4]; 8&#x27;b0000_0100: data_tmp = disp_data[11:8]; 8&#x27;b0000_1000: data_tmp = disp_data[15:12]; 8&#x27;b0001_0000: data_tmp = disp_data[19:16]; 8&#x27;b0010_0000: data_tmp = disp_data[23:20]; 8&#x27;b0100_0000: data_tmp = disp_data[27:24]; 8&#x27;b1000_0000: data_tmp = disp_data[31:28]; default: data_tmp = 4&#x27;b0000; endcase end //MUX2 (combitional) always@(*) begin if(~En) sel = 8&#x27;b0000_0000; else sel = sel_r; end //LUT (combitional) //注意：数码管灯段在输入为0时亮起，输入为1时熄灭； //h段为最高位，a段为最低位； always@(*) begin case(data_tmp) 4&#x27;b0000: seg = 7&#x27;b100_0000; //0 4&#x27;b0001: seg = 7&#x27;b111_1001; //1 4&#x27;b0010: seg = 7&#x27;b010_0100; //2 4&#x27;b0011: seg = 7&#x27;b011_0000; //3 4&#x27;b0100: seg = 7&#x27;b001_1001; //4 4&#x27;b0101: seg = 7&#x27;b001_0010; //5 4&#x27;b0110: seg = 7&#x27;b000_0010; //6 4&#x27;b0111: seg = 7&#x27;b111_1000; //7 4&#x27;b1000: seg = 7&#x27;b000_0000; //8 4&#x27;b1001: seg = 7&#x27;b001_0000; //9 4&#x27;b1010: seg = 7&#x27;b000_1000; //a 4&#x27;b1011: seg = 7&#x27;b000_0011; //b 4&#x27;b1100: seg = 7&#x27;b100_0110; //c 4&#x27;b1101: seg = 7&#x27;b010_0001; //d 4&#x27;b1110: seg = 7&#x27;b000_0110; //e 4&#x27;b1111: seg = 7&#x27;b000_1110; //f default: seg = 7&#x27;b111_1111; //全灭 endcase endendmodule TestBench1234567891011121314151617181920212223242526272829303132333435363738394041`timescale 1 ns/ 1 ps`define clk_period 20module digital_display_vlg_tst(); reg Clk; reg En; reg Rst_n; reg [31:0] disp_data; wire [6:0] seg; wire [7:0] sel; digital_display u1 ( .Clk(Clk), .En(En), .Rst_n(Rst_n), .disp_data(disp_data), .seg(seg), .sel(sel) ); initial begin Clk = 1&#x27;b1; forever #(`clk_period/2) Clk = ~Clk; end initial begin Rst_n = 1&#x27;b0; En = 1&#x27;b1; disp_data = 32&#x27;h12345678; #(`clk_period*20); Rst_n = 1&#x27;b1; #(`clk_period*20); #20_000_000; disp_data = 32&#x27;h87654321; #20_000_000; disp_data = 32&#x27;h89abcdef; #20_000_000; $stop; end endmodule 得到的仿真波形： ISSP使用IP核 可以作为探针； 可以作为驱动源（数据源）； 本次实验需要用到的探针宽度为0，数据源宽度为32 完成后，将文件烧录到开发板上，在Tools中找到In-System Sources and Probes Editor 设置改成十六进制，之后直接在data里面设置需要的数据，就可以将数据输入到开发板上","categories":[],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"http://example.com/tags/FPGA/"},{"name":"Verilog","slug":"Verilog","permalink":"http://example.com/tags/Verilog/"}]},{"title":"学习FPGA（三）","slug":"FPGA/FPGA-3","date":"2022-04-15T07:39:43.000Z","updated":"2022-04-27T06:03:39.891Z","comments":true,"path":"2022/04/15/FPGA/FPGA-3/","link":"","permalink":"http://example.com/2022/04/15/FPGA/FPGA-3/","excerpt":"按键消抖主模块三段式状态机代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137//目的：设计一个按键消抖，滤波时间为20ms//晶振为50M，即一个时间周期为20ns//需要滤波1_000_000个时间周期`define filter_time 20&#x27;d1_000_000module key_filter(Clk, Rst_n, Key_in, Key_flag, Key_state); input Clk; //时钟输入 input Rst_n; //复位输入 input Key_in; //按键输入，按下时为0，断开时为1 output reg Key_flag; //按键输入变化后出现稳定状态时，显示为1（保持一个时钟周期），其余时候为0 output reg Key_state; //按键状态，按下时显示为0， 断开时为1 //set state(one-hot code) localparam IDLE = 4&#x27;b0001, FILTER0 = 4&#x27;b0010, DOWN = 4&#x27;b0100, FILTER1 = 4&#x27;b1000; reg [3:0] state, next; //edge check reg Key_tmp0, Key_tmp1; wire Key_posedge, Key_negedge; always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) begin Key_tmp0 &lt;= 1&#x27;b0; Key_tmp1 &lt;= 1&#x27;b0; end else begin Key_tmp0 &lt;= Key_in; //当Key_tmp0 = 1 且 Key_tmp1 = 0时即为一个上升沿 Key_tmp1 &lt;= Key_tmp0; //当Key_tmp0 = 0 且 Key_tmp1 = 1时即为一个下降沿 end end assign Key_posedge = ~Key_tmp1 &amp; Key_tmp0; assign Key_negedge = Key_tmp1 &amp; ~Key_tmp0; //filter counter reg [19:0] cnt; reg cnt_full; //计数器计满信号 reg en_cnt; //计数器使能信号 always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) begin cnt &lt;= &#x27;d0; cnt_full &lt;= 1&#x27;b0; end else if(en_cnt) begin if(cnt == (`filter_time - 1)) begin cnt &lt;= &#x27;d0; cnt_full &lt;= 1&#x27;b1; end else begin cnt &lt;= cnt + 1&#x27;b1; cnt_full &lt;= 1&#x27;b0; end end else begin cnt &lt;= &#x27;d0; cnt_full &lt;= 1&#x27;b0; end end //state transition(combinational) always@(*) begin case(state) IDLE: begin if(Key_negedge) next = FILTER0; else next = IDLE; end FILTER0: begin if(cnt_full) next = DOWN; else if(Key_posedge) next = IDLE; else next = FILTER0; end DOWN: begin if(Key_posedge) next = FILTER1; else next = DOWN; end FILTER1: begin if(cnt_full) next = IDLE; else if(Key_negedge) next = DOWN; else next = FILTER1; end default: next = IDLE; endcase end //state flip-flops(sequential) always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) state &lt;= IDLE; else state &lt;= next; end //output always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) Key_state &lt;= 1&#x27;b0; else case(next) IDLE: begin en_cnt &lt;= 1&#x27;b0; //IDLE状态下计数器不计数 Key_state &lt;= 1&#x27;b1; //此时Key未被按下 Key_flag &lt;= 1&#x27;b0; end FILTER0: begin en_cnt &lt;= 1&#x27;b1; //FILTER0状态下计数器开始计数 Key_state &lt;= 1&#x27;b1; //此时Key仍处于未被按下状态 Key_flag &lt;= 1&#x27;b0; end DOWN: begin en_cnt &lt;= 1&#x27;b0; //DOWN状态下计数器不计数 Key_state &lt;= 1&#x27;b0; //此时Key已被按下 Key_flag &lt;= cnt_full;//探测到Key被按下 end FILTER1: begin en_cnt &lt;= 1&#x27;b1; //FILTER0状态下计数器开始计数 Key_state &lt;= 1&#x27;b0; //此时Key仍处于被按下状态 Key_flag &lt;= 1&#x27;b0; end default: begin en_cnt &lt;= 1&#x27;b0; Key_state &lt;= 1&#x27;b1; Key_flag &lt;= 1&#x27;b0; end endcase end //assign Key_flag = Key_negedge; //组合逻辑输出方式来输出Key_flagendmodule Testbench12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091`timescale 1 ns/ 1 ns`define clk_period 20module key_filter_vlg_tst(); // test vector input registers reg Clk; reg Key_in; reg Rst_n; // wires wire Key_flag; wire Key_state; key_filter i1 ( // port map - connection between master ports and signals/registers .Clk(Clk), .Key_flag(Key_flag), .Key_in(Key_in), .Key_state(Key_state), .Rst_n(Rst_n) ); initial begin Clk = 1&#x27;b1; forever #(`clk_period/2) Clk = ~Clk; end initial begin Rst_n = 1&#x27;b0; Key_in = 1&#x27;b1; #(`clk_period*10) Rst_n = 1&#x27;b1; #(`clk_period*10 + 1); //按下一次 Key_in = 1&#x27;b0;#10000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#5_400_000; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#200; Key_in = 1&#x27;b0;#20_000_100; #10000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#20_000_100; #10_000_000; //second time Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#200; Key_in = 1&#x27;b0;#20_000_100; #10000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#20_000_100; #10000; //third time Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#200; Key_in = 1&#x27;b0;#20_000_100; #10000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#20_000_100; #10000; $stop; endendmodule 仿真模型随机数{$random}默认是32位的随机数，根据自己的需要来取余计算，例如：需要0 ~ 65535的随机数，则可： 12reg [15:0] myrand;initial myrand = &#123;$random&#125;%65536;","text":"按键消抖主模块三段式状态机代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137//目的：设计一个按键消抖，滤波时间为20ms//晶振为50M，即一个时间周期为20ns//需要滤波1_000_000个时间周期`define filter_time 20&#x27;d1_000_000module key_filter(Clk, Rst_n, Key_in, Key_flag, Key_state); input Clk; //时钟输入 input Rst_n; //复位输入 input Key_in; //按键输入，按下时为0，断开时为1 output reg Key_flag; //按键输入变化后出现稳定状态时，显示为1（保持一个时钟周期），其余时候为0 output reg Key_state; //按键状态，按下时显示为0， 断开时为1 //set state(one-hot code) localparam IDLE = 4&#x27;b0001, FILTER0 = 4&#x27;b0010, DOWN = 4&#x27;b0100, FILTER1 = 4&#x27;b1000; reg [3:0] state, next; //edge check reg Key_tmp0, Key_tmp1; wire Key_posedge, Key_negedge; always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) begin Key_tmp0 &lt;= 1&#x27;b0; Key_tmp1 &lt;= 1&#x27;b0; end else begin Key_tmp0 &lt;= Key_in; //当Key_tmp0 = 1 且 Key_tmp1 = 0时即为一个上升沿 Key_tmp1 &lt;= Key_tmp0; //当Key_tmp0 = 0 且 Key_tmp1 = 1时即为一个下降沿 end end assign Key_posedge = ~Key_tmp1 &amp; Key_tmp0; assign Key_negedge = Key_tmp1 &amp; ~Key_tmp0; //filter counter reg [19:0] cnt; reg cnt_full; //计数器计满信号 reg en_cnt; //计数器使能信号 always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) begin cnt &lt;= &#x27;d0; cnt_full &lt;= 1&#x27;b0; end else if(en_cnt) begin if(cnt == (`filter_time - 1)) begin cnt &lt;= &#x27;d0; cnt_full &lt;= 1&#x27;b1; end else begin cnt &lt;= cnt + 1&#x27;b1; cnt_full &lt;= 1&#x27;b0; end end else begin cnt &lt;= &#x27;d0; cnt_full &lt;= 1&#x27;b0; end end //state transition(combinational) always@(*) begin case(state) IDLE: begin if(Key_negedge) next = FILTER0; else next = IDLE; end FILTER0: begin if(cnt_full) next = DOWN; else if(Key_posedge) next = IDLE; else next = FILTER0; end DOWN: begin if(Key_posedge) next = FILTER1; else next = DOWN; end FILTER1: begin if(cnt_full) next = IDLE; else if(Key_negedge) next = DOWN; else next = FILTER1; end default: next = IDLE; endcase end //state flip-flops(sequential) always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) state &lt;= IDLE; else state &lt;= next; end //output always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) Key_state &lt;= 1&#x27;b0; else case(next) IDLE: begin en_cnt &lt;= 1&#x27;b0; //IDLE状态下计数器不计数 Key_state &lt;= 1&#x27;b1; //此时Key未被按下 Key_flag &lt;= 1&#x27;b0; end FILTER0: begin en_cnt &lt;= 1&#x27;b1; //FILTER0状态下计数器开始计数 Key_state &lt;= 1&#x27;b1; //此时Key仍处于未被按下状态 Key_flag &lt;= 1&#x27;b0; end DOWN: begin en_cnt &lt;= 1&#x27;b0; //DOWN状态下计数器不计数 Key_state &lt;= 1&#x27;b0; //此时Key已被按下 Key_flag &lt;= cnt_full;//探测到Key被按下 end FILTER1: begin en_cnt &lt;= 1&#x27;b1; //FILTER0状态下计数器开始计数 Key_state &lt;= 1&#x27;b0; //此时Key仍处于被按下状态 Key_flag &lt;= 1&#x27;b0; end default: begin en_cnt &lt;= 1&#x27;b0; Key_state &lt;= 1&#x27;b1; Key_flag &lt;= 1&#x27;b0; end endcase end //assign Key_flag = Key_negedge; //组合逻辑输出方式来输出Key_flagendmodule Testbench12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091`timescale 1 ns/ 1 ns`define clk_period 20module key_filter_vlg_tst(); // test vector input registers reg Clk; reg Key_in; reg Rst_n; // wires wire Key_flag; wire Key_state; key_filter i1 ( // port map - connection between master ports and signals/registers .Clk(Clk), .Key_flag(Key_flag), .Key_in(Key_in), .Key_state(Key_state), .Rst_n(Rst_n) ); initial begin Clk = 1&#x27;b1; forever #(`clk_period/2) Clk = ~Clk; end initial begin Rst_n = 1&#x27;b0; Key_in = 1&#x27;b1; #(`clk_period*10) Rst_n = 1&#x27;b1; #(`clk_period*10 + 1); //按下一次 Key_in = 1&#x27;b0;#10000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#5_400_000; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#200; Key_in = 1&#x27;b0;#20_000_100; #10000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#20_000_100; #10_000_000; //second time Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#200; Key_in = 1&#x27;b0;#20_000_100; #10000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#20_000_100; #10000; //third time Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#200; Key_in = 1&#x27;b0;#20_000_100; #10000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#20_000_100; #10000; $stop; endendmodule 仿真模型随机数{$random}默认是32位的随机数，根据自己的需要来取余计算，例如：需要0 ~ 65535的随机数，则可： 12reg [15:0] myrand;initial myrand = &#123;$random&#125;%65536; 其中，myrand就是所需的随机数。 task定义一个task如下所示 123456789101112131415161718reg [15:0] myrand;task press_key; begin repeat(50) begin myrand = &#123;$random&#125;%65536; #myrand key_in = ~key_in; end key_in = 0; #50_000_000; repeat(50) begin myrand = &#123;$random&#125;%65536; #myrand key_in = ~key_in; end key_in = 0; #50_000_000; endendtask 然后就可以直接在testbench中使用 1press_key; 仿真模型新建一个key_module文件 123456789101112131415161718192021222324252627282930313233`timescale 1 ns/1 psmodule key_module(key); output reg key; reg [15:0] myrand; initial begin key = 1&#x27;b1; press_key; #10000; press_key; #10000; press_key; $stop; end task press_key; begin repeat(50) begin myrand = &#123;$random&#125;%65536; #myrand key = ~key; end key = 0; #50_000_000; repeat(50) begin myrand = &#123;$random&#125;%65536; #myrand key = ~key; end key = 1; #50_000_000; end endtaskendmodule 使用时需将该文件添加到test bench中，test bench主文件为 12345678910111213141516171819202122232425262728293031323334`timescale 1 ns/ 1 ns`define clk_period 20module key_filter_vlg_tst(); // test vector input registers reg Clk; wire Key_in; reg Rst_n; // wires wire Key_flag; wire Key_state; key_filter i1 ( // port map - connection between master ports and signals/registers .Clk(Clk), .Key_flag(Key_flag), .Key_in(Key_in), .Key_state(Key_state), .Rst_n(Rst_n) ); initial begin Clk = 1&#x27;b1; forever #(`clk_period/2) Clk = ~Clk; end initial begin Rst_n = 1&#x27;b0; #(`clk_period*10) Rst_n = 1&#x27;b1; #(`clk_period*10 + 1) ; end key_module u1(.key(Key_in)); endmodule","categories":[],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"http://example.com/tags/FPGA/"},{"name":"Verilog","slug":"Verilog","permalink":"http://example.com/tags/Verilog/"}]},{"title":"学习FPGA（二）","slug":"FPGA/FPGA-2","date":"2022-04-14T01:38:13.000Z","updated":"2022-04-22T11:29:44.087Z","comments":true,"path":"2022/04/14/FPGA/FPGA-2/","link":"","permalink":"http://example.com/2022/04/14/FPGA/FPGA-2/","excerpt":"有限状态机状态的表示常用编码方法有二进制码、格雷码（Gray code）、独热码（one-hot code）。 二进制码即用二进制计数 优点：属于压缩状态编码，状态机所需的状态向量位数较少； 缺点：1、译码复杂；2、相邻状态变换时，会有多位发生改变，电噪声大、转换速度较慢、易出错；（实际电路中多位改变很难做到完全同时发生）； 格雷码（Gray code）在一组数的编码中，任意两个相邻的代码只有一位二进制数不同，且最大数与最小数之间也仅有一位数不同构造方法：1位格雷码有两个码字(n+1)位格雷码中的前2n个码字等于n位格雷码的码字，按顺序书写，加前缀0(n+1)位格雷码中的后2n个码字等于n位格雷码的码字，按逆序书写，加前缀1n+1位格雷码的集合 &#x3D; n位格雷码集合(顺序)加前缀0 + n位格雷码集合(逆序)加前缀1如：二进制码：000-001-010-011-100-101-110-111 相应的格雷码：000-001-011-010-110-111-101 优点：1、属于压缩状态编码，状态机所需的状态向量位数较少；2、相邻状态变换时，仅有一位发生改变，电噪声小、转换速度较快； 缺点：1、译码复杂；2、是一种变权码，每一位码没有固定的大小，难以直接比较大小和算术运算； 独热码（one-hot code）有多少个状态就有多少个比特，其中有且只有一个比特为1，其余为0用独热码表示三个状态可以写为：001，010，100","text":"有限状态机状态的表示常用编码方法有二进制码、格雷码（Gray code）、独热码（one-hot code）。 二进制码即用二进制计数 优点：属于压缩状态编码，状态机所需的状态向量位数较少； 缺点：1、译码复杂；2、相邻状态变换时，会有多位发生改变，电噪声大、转换速度较慢、易出错；（实际电路中多位改变很难做到完全同时发生）； 格雷码（Gray code）在一组数的编码中，任意两个相邻的代码只有一位二进制数不同，且最大数与最小数之间也仅有一位数不同构造方法：1位格雷码有两个码字(n+1)位格雷码中的前2n个码字等于n位格雷码的码字，按顺序书写，加前缀0(n+1)位格雷码中的后2n个码字等于n位格雷码的码字，按逆序书写，加前缀1n+1位格雷码的集合 &#x3D; n位格雷码集合(顺序)加前缀0 + n位格雷码集合(逆序)加前缀1如：二进制码：000-001-010-011-100-101-110-111 相应的格雷码：000-001-011-010-110-111-101 优点：1、属于压缩状态编码，状态机所需的状态向量位数较少；2、相邻状态变换时，仅有一位发生改变，电噪声小、转换速度较快； 缺点：1、译码复杂；2、是一种变权码，每一位码没有固定的大小，难以直接比较大小和算术运算； 独热码（one-hot code）有多少个状态就有多少个比特，其中有且只有一个比特为1，其余为0用独热码表示三个状态可以写为：001，010，100 优点：译码简单； 缺点：速度较慢，占用触发器资源较多，面积较大； 编写一个检测”Hello”序列的状态机设置状态时，常用localparam或者parameter。其中parameter可用作在顶层模块中例化底层模块时传递参数的接口；而localparam的作用域仅仅限于当前module，不能作为参数传递的接口。 状态机分为一段时状态机、两段式状态机、三段式状态机， 作者第一次写出的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374module state_machine (Clk, Rst_n, data, led); //Hello状态机 input Clk; //基准时钟信号50M input Rst_n; //输入异步复位信号 input [7:0] data; //输入数据 output reg led; //当前状态输入 //set state reg [2:0] state, next; localparam CHECK_H = &#x27;d0, CHECK_e = &#x27;d1, CHECK_la = &#x27;d2, CHECK_lb = &#x27;d3, CHECK_o = &#x27;d4; //state transition (combinational logic) always@(*) begin case(state) CHECK_H: begin if(data == &quot;H&quot;) next = CHECK_e; else next = CHECK_H; end CHECK_e: begin if(data == &quot;e&quot;) next = CHECK_la; else if(data == &quot;H&quot;) next = CHECK_e; else next = CHECK_H; end CHECK_la: begin if(data == &quot;l&quot;) next = CHECK_lb; else if(data == &quot;H&quot;) next = CHECK_e; else next = CHECK_H; end CHECK_lb: begin if(data == &quot;l&quot;) next = CHECK_o; else if(data == &quot;H&quot;) next = CHECK_e; else next = CHECK_H; end CHECK_o: begin if(data == &quot;o&quot;) next = CHECK_H; else if(data == &quot;H&quot;) next = CHECK_e; else next = CHECK_H; end default: next = CHECK_H;//默认状态下reset endcase end //state flip-flops (sequential logic) always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) state &lt;= CHECK_H; else state &lt;= next; end //output always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) led &lt;= 1&#x27;b1; //通常led低电平有效，高电平无效 else case(state) CHECK_o: led &lt;= 1&#x27;b0; default: led &lt;= 1&#x27;b1; endcase endendmodule","categories":[],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"http://example.com/tags/FPGA/"},{"name":"Verilog","slug":"Verilog","permalink":"http://example.com/tags/Verilog/"}]},{"title":"学习FPGA（一）","slug":"FPGA/FPGA-1","date":"2022-04-13T08:50:46.000Z","updated":"2022-04-22T11:37:40.104Z","comments":true,"path":"2022/04/13/FPGA/FPGA-1/","link":"","permalink":"http://example.com/2022/04/13/FPGA/FPGA-1/","excerpt":"刚好今天尝试使用hexo框架搭建了个人博客，索性记录一下自己学习FPGA的过程，方便日后查看和复习。 BCD计数器设计与验证目的是通过将三个BCD计数器级联来实现1000的计数单个BCD计数器的Verilog代码如下： 12345678910111213141516171819202122232425module bcd_counter(Clk, Cin, Rst_n, Cout, Q); input Clk;//时间基准信号 input Cin;//计数器进位输入 input Rst_n;//计数器复位输入 output reg Cout;//计数器进位输出 output reg [3:0] Q;//计数器计数输出 //产生输出进位信号 always@(posedge Clk or negedge Rst_n) begin if(Rst_n==1&#x27;b0) Cout = 1&#x27;b0; else if(Q==4&#x27;d9 &amp;&amp; Cin==1&#x27;b1) Cout = 1&#x27;b1; //此处的进位设置并不合理，级联后会发生错误 else Cout = 1&#x27;b0; end //执行计数过程 always@(posedge Clk or negedge Rst_n) begin if(Rst_n==1&#x27;b0) Q &lt;= 4&#x27;b0; else if(Cin==1&#x27;b1) begin if(Q==4&#x27;d9)Q &lt;= 4&#x27;b0; else Q &lt;= Q + 1&#x27;b1; end else Q &lt;= Q; endendmodule 使用modelsim分析时，先从sim中把子模块的输入输出信号全部添加到波形窗口中然后在波形窗口中选中所有信号（Ctrl+a），再按下快捷键Ctrl+g，完成按模块分组 将”&#x2F;&#x2F;产生输出进位信号”部分修改为： 12345always@(*) begin if(Rst_n==1&#x27;b0) Cout = 1&#x27;b0; else if(Q==4&#x27;d9 &amp;&amp; Cin==1&#x27;b1) Cout = 1&#x27;b1; else Cout = 1&#x27;b0;end 此即行为级建模实现的组合逻辑，但仿真的结果出现了奇怪的毛刺，这是rtl级仿真不该出现的 于是再将其改为： 1assign Cout = (Q==4&#x27;d9 &amp;&amp; Cin==1&#x27;b1);","text":"刚好今天尝试使用hexo框架搭建了个人博客，索性记录一下自己学习FPGA的过程，方便日后查看和复习。 BCD计数器设计与验证目的是通过将三个BCD计数器级联来实现1000的计数单个BCD计数器的Verilog代码如下： 12345678910111213141516171819202122232425module bcd_counter(Clk, Cin, Rst_n, Cout, Q); input Clk;//时间基准信号 input Cin;//计数器进位输入 input Rst_n;//计数器复位输入 output reg Cout;//计数器进位输出 output reg [3:0] Q;//计数器计数输出 //产生输出进位信号 always@(posedge Clk or negedge Rst_n) begin if(Rst_n==1&#x27;b0) Cout = 1&#x27;b0; else if(Q==4&#x27;d9 &amp;&amp; Cin==1&#x27;b1) Cout = 1&#x27;b1; //此处的进位设置并不合理，级联后会发生错误 else Cout = 1&#x27;b0; end //执行计数过程 always@(posedge Clk or negedge Rst_n) begin if(Rst_n==1&#x27;b0) Q &lt;= 4&#x27;b0; else if(Cin==1&#x27;b1) begin if(Q==4&#x27;d9)Q &lt;= 4&#x27;b0; else Q &lt;= Q + 1&#x27;b1; end else Q &lt;= Q; endendmodule 使用modelsim分析时，先从sim中把子模块的输入输出信号全部添加到波形窗口中然后在波形窗口中选中所有信号（Ctrl+a），再按下快捷键Ctrl+g，完成按模块分组 将”&#x2F;&#x2F;产生输出进位信号”部分修改为： 12345always@(*) begin if(Rst_n==1&#x27;b0) Cout = 1&#x27;b0; else if(Q==4&#x27;d9 &amp;&amp; Cin==1&#x27;b1) Cout = 1&#x27;b1; else Cout = 1&#x27;b0;end 此即行为级建模实现的组合逻辑，但仿真的结果出现了奇怪的毛刺，这是rtl级仿真不该出现的 于是再将其改为： 1assign Cout = (Q==4&#x27;d9 &amp;&amp; Cin==1&#x27;b1); 此即数据流建模实现的组合逻辑。需要注意的是，此时应当将Cout的类型变更为wire型，否则会发生编译错误。 他们占用的逻辑资源也出现了不同","categories":[],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"http://example.com/tags/FPGA/"},{"name":"Verilog","slug":"Verilog","permalink":"http://example.com/tags/Verilog/"}]},{"title":"搭建博客相关问题","slug":"hexo-note","date":"2022-04-13T04:27:06.000Z","updated":"2022-04-29T02:11:20.119Z","comments":true,"path":"2022/04/13/hexo-note/","link":"","permalink":"http://example.com/2022/04/13/hexo-note/","excerpt":"【随时补充】搭建个人博客时遇到的一些问题如何解决无法访问Github在 C:\\Windows\\System32\\drivers\\etc\\hosts 文件中末尾添加两行 12140.82.113.4 github.com140.82.113.4 www.github.com 其中ip地址可在 https://github.com.ipaddress.com/www.github.com 中查询 若完成上述操作后仍无法访问，可以再添加两行 1269.171.224.40 github.global.ssl.fastly.net185.199.111.153 assets-cdn.github.com 其中ip地址可以在 http://tool.chinaz.com/dns 中输入网址查询，选取TTL值较低的ip地址即可 在修改hosts文件时，通常先将其复制到其他路径得到一个副本，将副本修改保存后替换原文件。（建议修改前备份一个hosts文件） 参考：https://www.cnblogs.com/yanch01/p/GitHub-access.html","text":"【随时补充】搭建个人博客时遇到的一些问题如何解决无法访问Github在 C:\\Windows\\System32\\drivers\\etc\\hosts 文件中末尾添加两行 12140.82.113.4 github.com140.82.113.4 www.github.com 其中ip地址可在 https://github.com.ipaddress.com/www.github.com 中查询 若完成上述操作后仍无法访问，可以再添加两行 1269.171.224.40 github.global.ssl.fastly.net185.199.111.153 assets-cdn.github.com 其中ip地址可以在 http://tool.chinaz.com/dns 中输入网址查询，选取TTL值较低的ip地址即可 在修改hosts文件时，通常先将其复制到其他路径得到一个副本，将副本修改保存后替换原文件。（建议修改前备份一个hosts文件） 参考：https://www.cnblogs.com/yanch01/p/GitHub-access.html 修改主题配置在hexo根目录下创建一个_config.[主题名].yml，例如：_config.next.yml，可以覆盖主题目录下_config.yml文件的作用。这样可以在不修改主题_config.yml文件的情况下，很方便的修改主题配置。 styles.styl文件在next 8.x版本中，用户需要自行创建styles.styl文件，放在[hexo根目录]\\source\\_data\\下，注意不是next主题目录下的source文件夹。如果你的source文件夹里没有_data文件夹，创建一个即可。 然后在_config.next.yml中，找到以下代码： 12345678910111213# Define custom file paths.# Create your custom files in site directory `source/_data` and uncomment needed files below.custom_file_path: #head: source/_data/head.njk #header: source/_data/header.njk #sidebar: source/_data/sidebar.njk #postMeta: source/_data/post-meta.njk #postBodyEnd: source/_data/post-body-end.njk #footer: source/_data/footer.njk #bodyEnd: source/_data/body-end.njk #variable: source/_data/variables.styl #mixin: source/_data/mixins.styl #style: source/_data/styles.styl 将其中的style项取消注释，即可通过修改styles.styl的方式来进行个性化设置 1style: source/_data/styles.styl //取消注释，即删去#号 参考：https://github.com/iissnan/hexo-theme-next/issues/680 首行缩进想要在远端部署时实现正文首行缩进2字符，可以在 styles.styl文件中添加： 12//仅正文首行缩进2字符.post-body p &#123; text-indent: 2em; &#125; 制作Table参考：https://theme-next.js.org/docs/tag-plugins/tabs.html 修改tab缩进距离在[hexo根目录]\\source\\_data\\styles.styl文件中添加： 1234//设置tab-sizepre &#123; tab-size: 4; //数字即是tab的缩进距离&#125; 参考：https://github.com/blinkfox/hexo-theme-matery/issues/637","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-04-13T04:19:46.145Z","updated":"2022-04-13T14:39:11.924Z","comments":true,"path":"2022/04/13/hello-world/","link":"","permalink":"http://example.com/2022/04/13/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Verilog","slug":"Verilog","permalink":"http://example.com/tags/Verilog/"},{"name":"FPGA","slug":"FPGA","permalink":"http://example.com/tags/FPGA/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]}