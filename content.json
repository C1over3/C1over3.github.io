{"meta":{"title":"Clover的blog","subtitle":"","description":"","author":"Clover","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"学习FPGA（四）","slug":"FPGA-4","date":"2022-04-17T02:57:24.000Z","updated":"2022-04-17T02:57:09.691Z","comments":true,"path":"2022/04/17/FPGA-4/","link":"","permalink":"http://example.com/2022/04/17/FPGA-4/","excerpt":"","text":"","categories":[],"tags":[{"name":"FPGA, Verilog","slug":"FPGA-Verilog","permalink":"http://example.com/tags/FPGA-Verilog/"}]},{"title":"学习FPGA（三）","slug":"FPGA-3","date":"2022-04-15T07:39:43.000Z","updated":"2022-04-15T08:56:42.066Z","comments":true,"path":"2022/04/15/FPGA-3/","link":"","permalink":"http://example.com/2022/04/15/FPGA-3/","excerpt":"","text":"按键消抖 主模块 三段式状态机代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137//目的：设计一个按键消抖，滤波时间为20ms//晶振为50M，即一个时间周期为20ns//需要滤波1_000_000个时间周期`define filter_time 20&#x27;d1_000_000module key_filter(Clk, Rst_n, Key_in, Key_flag, Key_state); input Clk; //时钟输入 input Rst_n; //复位输入 input Key_in; //按键输入，按下时为0，断开时为1 output reg Key_flag; //按键输入变化后出现稳定状态时，显示为1（保持一个时钟周期），其余时候为0 output reg Key_state; //按键状态，按下时显示为1， 断开时为0 //set state(one-hot code) localparam IDLE = 4&#x27;b0001, FILTER0 = 4&#x27;b0010, DOWN = 4&#x27;b0100, FILTER1 = 4&#x27;b1000; reg [3:0] state, next; //edge check reg Key_tmp0, Key_tmp1; wire Key_posedge, Key_negedge; always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) begin Key_tmp0 &lt;= 1&#x27;b0; Key_tmp1 &lt;= 1&#x27;b0; end else begin Key_tmp0 &lt;= Key_in; //当Key_tmp0 = 1 且 Key_tmp1 = 0时即为一个上升沿 Key_tmp1 &lt;= Key_tmp0; //当Key_tmp0 = 0 且 Key_tmp1 = 1时即为一个下降沿 end end assign Key_posedge = ~Key_tmp1 &amp; Key_tmp0; assign Key_negedge = Key_tmp1 &amp; ~Key_tmp0; //filter counter reg [19:0] cnt; reg cnt_full; //计数器计满信号 reg en_cnt; //计数器使能信号 always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) begin cnt &lt;= &#x27;d0; cnt_full &lt;= 1&#x27;b0; end else if(en_cnt) begin if(cnt == (`filter_time - 1)) begin cnt &lt;= &#x27;d0; cnt_full &lt;= 1&#x27;b1; end else begin cnt &lt;= cnt + 1&#x27;b1; cnt_full &lt;= 1&#x27;b0; end end else begin cnt &lt;= &#x27;d0; cnt_full &lt;= 1&#x27;b0; end end //state transition(combinational) always@(*) begin case(state) IDLE: begin if(Key_negedge) next = FILTER0; else next = IDLE; end FILTER0: begin if(cnt_full) next = DOWN; else if(Key_posedge) next = IDLE; else next = FILTER0; end DOWN: begin if(Key_posedge) next = FILTER1; else next = DOWN; end FILTER1: begin if(cnt_full) next = IDLE; else if(Key_negedge) next = DOWN; else next = FILTER1; end default: next = IDLE; endcase end //state flip-flops(sequential) always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) state &lt;= IDLE; else state &lt;= next; end //output always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) Key_state &lt;= 1&#x27;b0; else case(next) IDLE: begin en_cnt &lt;= 1&#x27;b0; //IDLE状态下计数器不计数 Key_state &lt;= 1&#x27;b0; //此时Key未被按下 Key_flag &lt;= 1&#x27;b0; end FILTER0: begin en_cnt &lt;= 1&#x27;b1; //FILTER0状态下计数器开始计数 Key_state &lt;= 1&#x27;b0; //此时Key仍处于未被按下状态 Key_flag &lt;= 1&#x27;b0; end DOWN: begin en_cnt &lt;= 1&#x27;b0; //DOWN状态下计数器不计数 Key_state &lt;= 1&#x27;b1; //此时Key已被按下 Key_flag &lt;= cnt_full;//探测到Key被按下 end FILTER1: begin en_cnt &lt;= 1&#x27;b1; //FILTER0状态下计数器开始计数 Key_state &lt;= 1&#x27;b1; //此时Key仍处于被按下状态 Key_flag &lt;= 1&#x27;b0; end default: begin en_cnt &lt;= 1&#x27;b0; Key_state &lt;= 1&#x27;b0; Key_flag &lt;= 1&#x27;b0; end endcase end //assign Key_flag = Key_negedge; //组合逻辑输出方式来输出Key_flagendmodule Testbench 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091`timescale 1 ns/ 1 ns`define clk_period 20module key_filter_vlg_tst(); // test vector input registers reg Clk; reg Key_in; reg Rst_n; // wires wire Key_flag; wire Key_state; key_filter i1 ( // port map - connection between master ports and signals/registers .Clk(Clk), .Key_flag(Key_flag), .Key_in(Key_in), .Key_state(Key_state), .Rst_n(Rst_n) ); initial begin Clk = 1&#x27;b1; forever #(`clk_period/2) Clk = ~Clk; end initial begin Rst_n = 1&#x27;b0; Key_in = 1&#x27;b1; #(`clk_period*10) Rst_n = 1&#x27;b1; #(`clk_period*10 + 1); //按下一次 Key_in = 1&#x27;b0;#10000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#5_400_000; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#200; Key_in = 1&#x27;b0;#20_000_100; #10000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#20_000_100; #10_000_000; //second time Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#200; Key_in = 1&#x27;b0;#20_000_100; #10000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#20_000_100; #10000; //third time Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#200; Key_in = 1&#x27;b0;#20_000_100; #10000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#20_000_100; #10000; $stop; endendmodule 仿真模型 随机数$random默认是32位的随机数，根据自己的需要来取余计算例如：需要0 ~ 65535的随机数，则可 12reg [15:0] myrand;initial myrand = &#123;$random&#125;%65536; 其中，myrand就是所需的随机数。 task定义一个task如下所示 123456789101112131415161718reg [15:0] myrand;task press_key; begin repeat(50) begin myrand = &#123;$random&#125;%65536; #myrand key_in = ~key_in; end key_in = 0; #50_000_000; repeat(50) begin myrand = &#123;$random&#125;%65536; #myrand key_in = ~key_in; end key_in = 0; #50_000_000; endendtask 然后就可以直接使用 1press_key; 仿真模型新建一个key_module文件 123456789101112131415161718192021222324252627282930313233`timescale 1 ns/1 psmodule key_module(key); output reg key; reg [15:0] myrand; initial begin key = 1&#x27;b1; press_key; #10000; press_key; #10000; press_key; $stop; end task press_key; begin repeat(50) begin myrand = &#123;$random&#125;%65536; #myrand key = ~key; end key = 0; #50_000_000; repeat(50) begin myrand = &#123;$random&#125;%65536; #myrand key = ~key; end key = 1; #50_000_000; end endtaskendmodule 使用时需将该文件添加到test bench中test bench主文件为 12345678910111213141516171819202122232425262728293031323334`timescale 1 ns/ 1 ns`define clk_period 20module key_filter_vlg_tst(); // test vector input registers reg Clk; wire Key_in; reg Rst_n; // wires wire Key_flag; wire Key_state; key_filter i1 ( // port map - connection between master ports and signals/registers .Clk(Clk), .Key_flag(Key_flag), .Key_in(Key_in), .Key_state(Key_state), .Rst_n(Rst_n) ); initial begin Clk = 1&#x27;b1; forever #(`clk_period/2) Clk = ~Clk; end initial begin Rst_n = 1&#x27;b0; #(`clk_period*10) Rst_n = 1&#x27;b1; #(`clk_period*10 + 1) ; end key_module u1(.key(Key_in)); endmodule","categories":[],"tags":[{"name":"FPGA, Verilog","slug":"FPGA-Verilog","permalink":"http://example.com/tags/FPGA-Verilog/"}]},{"title":"学习FPGA（二）","slug":"FPGA-2","date":"2022-04-14T01:38:13.000Z","updated":"2022-04-14T09:41:03.998Z","comments":true,"path":"2022/04/14/FPGA-2/","link":"","permalink":"http://example.com/2022/04/14/FPGA-2/","excerpt":"","text":"有限状态机 状态的表示常用编码方法有二进制码、格雷码（Gray code）、独热码（one-hot code） 二进制码 即用二进制计数 优点：属于压缩状态编码，状态机所需的状态向量位数较少； 缺点：1、译码复杂；2、相邻状态变换时，会有多位发生改变，电噪声大、转换速度较慢、易出错；（实际电路中多位改变很难做到完全同时发生）； 格雷码 在一组数的编码中，任意两个相邻的代码只有一位二进制数不同，且最大数与最小数之间也仅有一位数不同构造方法：1位格雷码有两个码字(n+1)位格雷码中的前2n个码字等于n位格雷码的码字，按顺序书写，加前缀0(n+1)位格雷码中的后2n个码字等于n位格雷码的码字，按逆序书写，加前缀1n+1位格雷码的集合 &#x3D; n位格雷码集合(顺序)加前缀0 + n位格雷码集合(逆序)加前缀1如：二进制码：000-001-010-011-100-101-110-111 相应的格雷码：000-001-011-010-110-111-101 优点：1、属于压缩状态编码，状态机所需的状态向量位数较少；2、相邻状态变换时，仅有一位发生改变，电噪声小、转换速度较快； 缺点：1、译码复杂；2、是一种变权码，每一位码没有固定的大小，难以直接比较大小和算术运算； 独热码 有多少个状态就有多少个比特，其中有且只有一个比特为1，其余为0用独热码表示三个状态可以写为：001，010，100 优点：译码简单； 缺点：速度较慢，占用触发器资源较多，面积较大； 设置状态时，常用localparam或者parameter。其中parameter可用作在顶层模块中例化底层模块时传递参数的接口；而localparam的作用域仅仅限于当前module，不能作为参数传递的接口。 状态机分为一段时状态机、两段式状态机、三段式状态机， 编写一个检测”Hello”序列的状态机作者第一次写出的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374module state_machine (Clk, Rst_n, data, led); //Hello状态机 input Clk; //基准时钟信号50M input Rst_n; //输入异步复位信号 input [7:0] data; //输入数据 output reg led; //当前状态输入 //set state reg [2:0] state, next; localparam CHECK_H = &#x27;d0, CHECK_e = &#x27;d1, CHECK_la = &#x27;d2, CHECK_lb = &#x27;d3, CHECK_o = &#x27;d4; //state transition (combinational logic) always@(*) begin case(state) CHECK_H: begin if(data == &quot;H&quot;) next = CHECK_e; else next = CHECK_H; end CHECK_e: begin if(data == &quot;e&quot;) next = CHECK_la; else if(data == &quot;H&quot;) next = CHECK_e; else next = CHECK_H; end CHECK_la: begin if(data == &quot;l&quot;) next = CHECK_lb; else if(data == &quot;H&quot;) next = CHECK_e; else next = CHECK_H; end CHECK_lb: begin if(data == &quot;l&quot;) next = CHECK_o; else if(data == &quot;H&quot;) next = CHECK_e; else next = CHECK_H; end CHECK_o: begin if(data == &quot;o&quot;) next = CHECK_H; else if(data == &quot;H&quot;) next = CHECK_e; else next = CHECK_H; end default: next = CHECK_H;//默认状态下reset endcase end //state flip-flops (sequential logic) always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) state &lt;= CHECK_H; else state &lt;= next; end //output always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) led &lt;= 1&#x27;b1; //通常led低电平有效，高电平无效 else case(state) CHECK_o: led &lt;= 1&#x27;b0; default: led &lt;= 1&#x27;b1; endcase endendmodule","categories":[],"tags":[{"name":"FPGA, Verilog","slug":"FPGA-Verilog","permalink":"http://example.com/tags/FPGA-Verilog/"}]},{"title":"学习FPGA（一）","slug":"FPGA-1","date":"2022-04-13T08:50:46.000Z","updated":"2022-04-13T10:27:18.823Z","comments":true,"path":"2022/04/13/FPGA-1/","link":"","permalink":"http://example.com/2022/04/13/FPGA-1/","excerpt":"","text":"刚好今天尝试使用hexo框架搭建了个人博客，索性记录一下自己学习FPGA的过程，方便日后查看和复习。 BCD计数器设计与验证 目的是通过将三个BCD计数器级联来实现1000的计数单个BCD计数器的Verilog代码如下： 12345678910111213141516171819202122232425module bcd_counter(Clk, Cin, Rst_n, Cout, Q); input Clk;//时间基准信号 input Cin;//计数器进位输入 input Rst_n;//计数器复位输入 output reg Cout;//计数器进位输出 output reg [3:0] Q;//计数器计数输出 //产生输出进位信号 always@(posedge Clk or negedge Rst_n) begin if(Rst_n==1&#x27;b0) Cout = 1&#x27;b0; else if(Q==4&#x27;d9 &amp;&amp; Cin==1&#x27;b1) Cout = 1&#x27;b1; //此处的进位设置并不合理，级联后会发生错误 else Cout = 1&#x27;b0; end //执行计数过程 always@(posedge Clk or negedge Rst_n) begin if(Rst_n==1&#x27;b0) Q &lt;= 4&#x27;b0; else if(Cin==1&#x27;b1) begin if(Q==4&#x27;d9)Q &lt;= 4&#x27;b0; else Q &lt;= Q + 1&#x27;b1; end else Q &lt;= Q; endendmodule 使用modelsim分析时，先从sim中把子模块的输入输出信号全部添加到波形窗口中然后在波形窗口中选中所有信号（Ctrl+a）再按下快捷键Ctrl+g，完成按模块分组 将”&#x2F;&#x2F;产生输出进位信号”部分修改为： 12345always@(*) begin if(Rst_n==1&#x27;b0) Cout = 1&#x27;b0; else if(Q==4&#x27;d9 &amp;&amp; Cin==1&#x27;b1) Cout = 1&#x27;b1; else Cout = 1&#x27;b0;end 此即行为级建模实现的组合逻辑，但仿真的结果出现了奇怪的毛刺，这是rtl级仿真不该出现的 于是再将其改为： 1assign Cout = (Q==4&#x27;d9 &amp;&amp; Cin==1&#x27;b1); 此即数据流建模实现的组合逻辑。需要注意的是，此时应当将Cout的类型变更为wire型，否则会发生编译错误。 他们占用的逻辑资源也出现了不同","categories":[],"tags":[{"name":"FPGA, Verilog","slug":"FPGA-Verilog","permalink":"http://example.com/tags/FPGA-Verilog/"}]},{"title":"如何搭建自己的博客","slug":"How-to-build-a-blog","date":"2022-04-13T07:30:55.000Z","updated":"2022-04-13T14:39:09.471Z","comments":true,"path":"2022/04/13/How-to-build-a-blog/","link":"","permalink":"http://example.com/2022/04/13/How-to-build-a-blog/","excerpt":"","text":"准备部分 今天作者恰好学习了如何搭建博客，于是想先写一篇笔记，便于自己查看。作者在搭建博客时，全程在windows10系统上进行，使用的框架为hexo框架 1、安装Git从Git的官网直接下载，记得在下载前注册一个github账号，下载过程中会要求你登录。 2、","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"My first blog","slug":"My-first-blog","date":"2022-04-13T04:27:06.000Z","updated":"2022-04-15T09:51:39.383Z","comments":true,"path":"2022/04/13/My-first-blog/","link":"","permalink":"http://example.com/2022/04/13/My-first-blog/","excerpt":"","text":"【转载】如何解决无法访问Github在 C:\\Windows\\System32\\drivers\\etc\\hosts 文件中末尾添加两行 12140.82.113.4 github.com140.82.113.4 www.github.com 其中ip地址可在 https://github.com.ipaddress.com/www.github.com 中查询 若完成上述操作后仍无法访问，可以再添加两行 1269.171.224.40 github.global.ssl.fastly.net185.199.111.153 assets-cdn.github.com 其中ip地址可以在 http://tool.chinaz.com/dns 中输入网址查询，选取TTL值较低的ip地址即可 在修改hosts文件时，通常先将其复制到其他路径得到一个副本，将副本修改保存后替换原文件。（建议修改前备份一个hosts文件） 转载自 https://www.cnblogs.com/yanch01/p/GitHub-access.html","categories":[],"tags":[{"name":"test","slug":"test","permalink":"http://example.com/tags/test/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-04-13T04:19:46.145Z","updated":"2022-04-13T14:39:11.924Z","comments":true,"path":"2022/04/13/hello-world/","link":"","permalink":"http://example.com/2022/04/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"FPGA, Verilog","slug":"FPGA-Verilog","permalink":"http://example.com/tags/FPGA-Verilog/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"test","slug":"test","permalink":"http://example.com/tags/test/"}]}