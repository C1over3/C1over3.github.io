{"meta":{"title":"Clover's blog","subtitle":"什么，您是哪里来的闯入者？","description":"这个少年还在迷茫...","author":"Clover","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2022-04-22T10:43:37.000Z","updated":"2022-04-22T10:44:44.598Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"似乎是还未到境界…"},{"title":"categories","date":"2022-04-22T10:45:19.000Z","updated":"2022-04-22T10:45:19.222Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-04-22T10:44:58.000Z","updated":"2022-04-22T11:27:31.812Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"C++笔记（二）","slug":"cpp-note-2","date":"2022-04-20T09:47:51.000Z","updated":"2022-04-23T03:43:51.429Z","comments":true,"path":"2022/04/20/cpp-note-2/","link":"","permalink":"http://example.com/2022/04/20/cpp-note-2/","excerpt":"const限定符const对象const对象一旦创建后其值就不可改变，因此必须初始化； 123const int i = get_size(); //正确：运行时初始化，get_size()为有返回值的函数const int j = 42; //正确：编译时初始化const int k; //错误：k是一个未经初始化的常量 默认状态下，const对象仅在文件内有效，因为编译器将在编译过程中会把用到该变量的地方都替换成对应的值，每个用了const对象的文件都必须含有对它的定义而非声明；如：在test1中 12const int i = 1; //定义全局常量i，初始化为1int j = 2; //定义全局变量j，初始化为2 test2中","text":"const限定符const对象const对象一旦创建后其值就不可改变，因此必须初始化； 123const int i = get_size(); //正确：运行时初始化，get_size()为有返回值的函数const int j = 42; //正确：编译时初始化const int k; //错误：k是一个未经初始化的常量 默认状态下，const对象仅在文件内有效，因为编译器将在编译过程中会把用到该变量的地方都替换成对应的值，每个用了const对象的文件都必须含有对它的定义而非声明；如：在test1中 12const int i = 1; //定义全局常量i，初始化为1int j = 2; //定义全局变量j，初始化为2 test2中 1234567#include &lt;iostream&gt;using namespace std;int main() &#123; extern int i; cout &lt;&lt; i &lt;&lt; endl; return 0;&#125; test3中 1234567#include &lt;iostream&gt;using namespace std;int main() &#123; extern int j; cout &lt;&lt; j &lt;&lt; endl; return 0;&#125; 其中test2会报错error LNK2001: 无法解析的外部符号 “int i”；而test3中能够得到输出2。对于一种const变量，它的初始值不是一个常量表达式，如果想只在一个文件中定义这类const对象，而且在其他多个文件中声明并使用它，方法如下： 1234//file_1.cpp中extern const int bufSize = fcn();//file_1.h中extern const int bufSize; //与file_1.cpp中定义的bufSize是同一个 对常量的引用(reference to const)“对常量的引用”可以简称为“常量引用”，因为引用不是一个对象，所以实际上不存在常量引用 对常量进行引用时，引用也必须为常量 12345const int ci = 1034;const int &amp;r1 = ci; //正确：引用及其对应的对象都是常量r1 = 42; //错误：r1是对常量的引用，不可改变其值int &amp;r2 = ci; //错误：试图让一个非常量引用指向一个常量对象 常量引用的两个例外（待补充） 初始化常量引用时允许用任意表达式作为初值，只要其结果能够转换成常量引用的类型即可 12345int i = 42;const int &amp;r1 = i; //允许将const int&amp;绑定到一个普通int对象上const int &amp;r2 = 42; //正确const int &amp;r3 = r1 * 2; //正确int &amp;r4 = r4 * 2; //错误：r4是一个普通的非常量引用 原因：在使用常量引用时，系编译器生成了一个与该常量引用同类型的临时量(temporary)对象，再将常量引用绑定在这个临时量对象上。 常量引用绑定的对象可以是非const对象 12345int i =42;int &amp;r1 = i; //引用ri绑定对象iconst int &amp;r2 = i; //r2也绑定对象i，当时不允许通过r2修改i的值r1 = 0; //r1并非常量，i的值修改为0r2 = 0; //错误：r2是一个常量引用，不可通过r2修改i的值 指向常量的指针(pointer to const)指向常量的指针不能用于改变其所指对象的值；要想存放常量对象的地址，只能使用指向常量的指针。 指向常量的指针的两个例外（待补充） 允许一个指向常量的指针指向一个非常量对象，指向常量的指针没有规定其所指对象必须是一个常量 1234const double pi = 3.14; double *ptr = &amp;pi; //错误：ptr是一个普通指针const double *cptr = &amp;pi; //正确：cptr可以指向一个双精度常量*cptr = 42; //错误：不能给*cptr赋值 原因同“对常量的引用” ps：所谓指向常量的指针或常量引用，不过是指针或引用“自以为是”罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象的值。 const指针引用不是对象，而指针是对象，因此允许把指针本身定义为常量，即常量指针(const pointer)。常量指针必须初始化，而且一旦初始化后，它的值（存放在指针中的地址）就不能再改变了。把*放在const关键字之前，这样书写说明不变的是指针而非指针指向的那个值。 12345678910#include &lt;iostream&gt;using namespace std;int main() &#123; int errNumb = 0; int* const curErr = &amp;errNumb; //curErr是一个常量指针 const double pi = 3.14159; const double* const pip1 = &amp;pi; //pip是一个指向常量的常量指针 double* const pip2 = &amp;pi; //错误：pip2并不是一个指向常量的指针，不能“const double*”类型的值不能用于初始化“double* const”类型的实体 return 0;&#125; 指针本身是常量，不代表不能通过指针修改其所指对象的值，能否这样做取决于所指对象的类型，即可以通过常量指针修改非常量对象的值。 想要弄清这些声明的含义，最有效的方法是从右向左阅读 练习2.27 1const int &amp;const r2 = 0; //错误：引用不是对象，没有常量引用，只有对常量的引用 虽然有的编译器会自动忽略掉&amp;后的const，但切记不要这样做。 练习2.28","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++笔记（一）","slug":"cpp-note-1","date":"2022-04-18T04:07:01.000Z","updated":"2022-04-23T03:43:32.030Z","comments":true,"path":"2022/04/18/cpp-note-1/","link":"","permalink":"http://example.com/2022/04/18/cpp-note-1/","excerpt":"不同初始化方式的区别12345678910#include &lt;iostream&gt;using namespace std;int main() &#123; long double ld = 3.1415926536; int a&#123; ld &#125;, b = &#123; ld &#125;; //错误：会提示error C2397: 从“long double”转换到“int”需要收缩转换 int c(ld), d = ld;//能够完成编译，且确实丢失了部分值，c和d输出均为3 cout &lt;&lt; a &lt;&lt; &quot;\\t&quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; c &lt;&lt; &quot;\\t&quot; &lt;&lt; d &lt;&lt; endl; return 0;&#125; 对于局部变量来说，初始化很重要；在编写某个类的时候，尽量申明当该类的某个对象未被显式初始化时，生成一个合适的默认值。 声明和定义C++支持分离式编译(separate compilation) 声明(declaration)：使得某个名字为程序所知，即这个变量已经在别处定义了，我现在拿来用。（声明一个其他地方定义过的全局变量） 定义(definition)：创建与名字关联的实体。","text":"不同初始化方式的区别12345678910#include &lt;iostream&gt;using namespace std;int main() &#123; long double ld = 3.1415926536; int a&#123; ld &#125;, b = &#123; ld &#125;; //错误：会提示error C2397: 从“long double”转换到“int”需要收缩转换 int c(ld), d = ld;//能够完成编译，且确实丢失了部分值，c和d输出均为3 cout &lt;&lt; a &lt;&lt; &quot;\\t&quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; c &lt;&lt; &quot;\\t&quot; &lt;&lt; d &lt;&lt; endl; return 0;&#125; 对于局部变量来说，初始化很重要；在编写某个类的时候，尽量申明当该类的某个对象未被显式初始化时，生成一个合适的默认值。 声明和定义C++支持分离式编译(separate compilation) 声明(declaration)：使得某个名字为程序所知，即这个变量已经在别处定义了，我现在拿来用。（声明一个其他地方定义过的全局变量） 定义(definition)：创建与名字关联的实体。 123extern int i; //声明i而非定义i，但如果显式初始化后则会抵消了extern的作用int j; //定义jextern double pi = 3.1416; //定义pi，且初始化为3.1416 在函数内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。 ps: C++是一种静态类型（statically typed）语言，其含义是在编译阶段执行类型检查（type checking）。如果编译器发现数据类型不支持要执行的运算，则会报错且不会生成任何可执行的程序。程序越复杂，静态类型检查越有助于发现问题。这要求我们在使用某个变量之前必须声明其类型。 标识符(identifier)变量命名规范： 标识符要体现实际含义； 变量名一般用小写字母，如index； 用户自定义的类名一般以大写字母开头，如Sales_item； 如果标识符由多个单词组成，则单词间要有明显区分，如student_loan或studentLoan； 建议：当第一次使用变量时再定义它，即随用随定义 有助于找到变量的定义； 可以赋予一个合理的初始值； 防止在程序一开始初始化一堆未用到的变量，从而拖慢运行速度； 作用域(scope)123456789#include &lt;iostream&gt;using namespace std;int i = 420, sum = 0;int main() &#123; for (int i = 0; i != 10; i++) //for()中的i作用域仅在()之中 sum += i; cout &lt;&lt; i &lt;&lt; &quot;\\t&quot; &lt;&lt; sum &lt;&lt; endl; //得到的输出为420 45 return 0;&#125; 12345678910#include &lt;iostream&gt;using namespace std;int i = 420, sum = 0;int main() &#123; int i = 100; //覆盖了全局变量i for (int i = 0; i != 10; i++) //for()中的i作用域仅在()之中 sum += i; cout &lt;&lt; ::i &lt;&lt; &quot;\\t&quot; &lt;&lt; i &lt;&lt; &quot;\\t&quot; &lt;&lt; sum &lt;&lt; endl; //得到的输出为420 100 45 return 0;&#125; 引用(reference)引用并非对象，而是为一个已经存在的对象所起的别名，不需要独立的内存空间； 引用初始化后，无法再令该引用重新绑定到另一个对象，因此引用必须初始化； 因为引用并非一个对象，所以不能定义引用的引用； 引用的类型必须与引用绑定的对象严格匹配。 12345678910111213#include &lt;iostream&gt;using namespace std;int main() &#123; int ival = 1024; int &amp;refVal0 = ival; //正确 int &amp;refVal1 = refVal; //正确：实际上是以与引用绑定的对象再定义了另一个引用 int &amp;refVal2; //错误：没有初始化引用 int &amp;refVal3 = &amp;refVal1; //错误：不能定义引用的引用 double dval = 3.14; int &amp;refVal4 = dval; //错误：类型不匹配 refVal = 0; return 0;&#125; 指针(pointer)指针本身就是一个对象，需要独立的内存空间; 指针初始化后，可以通过赋值来改变指针的值或指针指向的对象； 因为指针是一个对象，所以可以定义指针的指针； 指针的类型必须与指针的对象严格匹配。 指针的值（即地址）属于下列4中状态之一： 指向一个对象 指向紧邻对象所占空间的下一个位置 空指针，没有指向任何对象 无效指针，上述情况之外的其他值 建议： 初始化所有指针； 尽量定义了对象之后再定义指向它的指针； 如果实在不清楚指针应该指向何处，就先初始化为nullptr或者0； 1234int ival1 = 0, ival2 = 1;int *pi = &amp;ival1;pi = &amp;ival2; //pi的值被改变，现在pi指向了ival，或者说pi的值变成了存放ival的地址*pi = 0; //ival的值被改变，指针pi并没有改变 赋值改变的永远是&#x3D;左侧的对象！！！ void* 指针是一种特殊的指针类型，可以存放任意对象的地址。它可以用于和其他指针比较、作为函数的输入输出、赋值给另一个void* 指针。但是，不能对它所指向的对象进行操作，因为我们并不知道这个对象到底是什么类型。 概括来讲，void* 的视角来看，内存空间仅仅只是内存空间，没办法访问内存空间中所存的对象。 练习2.18 123456789101112131415#include &lt;iostream&gt;using namespace std;int main() &#123; int ival1 = 1, ival2 = 1, ival3 = 4; int* p1 = &amp;ival1, * p2 = &amp;ival2; //改变指针的值 cout &lt;&lt; p1 &lt;&lt; &quot;\\t&quot; &lt;&lt; ival1 &lt;&lt; &quot;\\t&quot; &lt;&lt; ival3 &lt;&lt; endl; p1 = &amp;ival3; cout &lt;&lt; p1 &lt;&lt; &quot;\\t&quot; &lt;&lt; ival1 &lt;&lt; &quot;\\t&quot; &lt;&lt; ival3 &lt;&lt; endl; //改变指针指向对象的值 cout &lt;&lt; p2 &lt;&lt; &quot;\\t&quot; &lt;&lt; *p2 &lt;&lt; &quot;\\t&quot; &lt;&lt; ival2 &lt;&lt; endl; *p2 = 100; cout &lt;&lt; p2 &lt;&lt; &quot;\\t&quot; &lt;&lt; *p2 &lt;&lt; &quot;\\t&quot; &lt;&lt; ival2 &lt;&lt; endl; return 0;&#125; 练习2.23 设给定指针为p 123int ival = 0;if(p) ival = 1;else ival = 2; //这个if...else...可以判断出p是否有一个合法的值（即合法地址）","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"学习FPGA（四）","slug":"FPGA-4","date":"2022-04-17T02:57:24.000Z","updated":"2022-04-22T11:30:03.998Z","comments":true,"path":"2022/04/17/FPGA-4/","link":"","permalink":"http://example.com/2022/04/17/FPGA-4/","excerpt":"实现FPGA驱动数码管动态显示知识点： 数码管动态扫描实现。 In system sources and probes editor (ISSP)调试工具的使用。 工程代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//实现FPGA驱动数码管动态显示module digital_display(Clk, Rst_n, En, disp_data, sel, seg); input Clk; //50M，一个周期为20ns input Rst_n; input En; input [31:0] disp_data; //输入要求显示的内容 output reg [7:0] sel; //数码管位选（当前要显示的数码管） output reg [6:0] seg; //数码管段选（当前要显示的内容） //divider module reg [14:0] divider_cnt; //产生1ms的时钟，每0.5ms时钟信号需要翻转一次，0.5ms/20ns=25_000=16&#x27;b0110_0001_1010_1000，故需要15位计数器 reg Clk_1K; always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) divider_cnt &lt;= 15&#x27;d0; else if(~En) divider_cnt &lt;= 15&#x27;d0; else if(divider_cnt== 15&#x27;d24_999) divider_cnt &lt;= 15&#x27;d0; else divider_cnt &lt;= divider_cnt + 1&#x27;b1; end always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) Clk_1K &lt;= 1&#x27;b0; else if(~En) Clk_1K &lt;= 1&#x27;b0; else if(divider_cnt== 15&#x27;d24_999) Clk_1K &lt;= ~Clk_1K; else Clk_1K &lt;= Clk_1K; end //shift8 module reg [7:0] sel_r; always@(posedge Clk_1K or negedge Rst_n) begin //注意，分频器的输出信号作为D触发器的时钟信号，在大型设计中是不被允许的，此处设计为数码管驱动模块，影响不大，允许存在这样的毛刺 if(~Rst_n) sel_r &lt;= 8&#x27;b0000_0001; else if(sel_r == 8&#x27;b1000_0000) sel_r &lt;= 8&#x27;b0000_0001; else sel_r &lt;= &#123;sel_r[6:0],1&#x27;b0&#125;; //此句也可改为 sel_r &lt;= sel_r &lt;&lt; 1; end //MUX8 (combitional) reg [3:0] data_tmp; always@(*) begin case(sel_r) 8&#x27;b0000_0001: data_tmp = disp_data[3:0]; 8&#x27;b0000_0010: data_tmp = disp_data[7:4]; 8&#x27;b0000_0100: data_tmp = disp_data[11:8]; 8&#x27;b0000_1000: data_tmp = disp_data[15:12]; 8&#x27;b0001_0000: data_tmp = disp_data[19:16]; 8&#x27;b0010_0000: data_tmp = disp_data[23:20]; 8&#x27;b0100_0000: data_tmp = disp_data[27:24]; 8&#x27;b1000_0000: data_tmp = disp_data[31:28]; default: data_tmp = 4&#x27;b0000; endcase end //MUX2 (combitional) always@(*) begin if(~En) sel = 8&#x27;b0000_0000; else sel = sel_r; end //LUT (combitional) //注意：数码管灯段在输入为0时亮起，输入为1时熄灭； //h段为最高位，a段为最低位； always@(*) begin case(data_tmp) 4&#x27;b0000: seg = 7&#x27;b100_0000; //0 4&#x27;b0001: seg = 7&#x27;b111_1001; //1 4&#x27;b0010: seg = 7&#x27;b010_0100; //2 4&#x27;b0011: seg = 7&#x27;b011_0000; //3 4&#x27;b0100: seg = 7&#x27;b001_1001; //4 4&#x27;b0101: seg = 7&#x27;b001_0010; //5 4&#x27;b0110: seg = 7&#x27;b000_0010; //6 4&#x27;b0111: seg = 7&#x27;b111_1000; //7 4&#x27;b1000: seg = 7&#x27;b000_0000; //8 4&#x27;b1001: seg = 7&#x27;b001_0000; //9 4&#x27;b1010: seg = 7&#x27;b000_1000; //a 4&#x27;b1011: seg = 7&#x27;b000_0011; //b 4&#x27;b1100: seg = 7&#x27;b100_0110; //c 4&#x27;b1101: seg = 7&#x27;b010_0001; //d 4&#x27;b1110: seg = 7&#x27;b000_0110; //e 4&#x27;b1111: seg = 7&#x27;b000_1110; //f default: seg = 7&#x27;b111_1111; //全灭 endcase endendmodule TestBench1234567891011121314151617181920212223242526272829303132333435363738394041`timescale 1 ns/ 1 ps`define clk_period 20module digital_display_vlg_tst(); reg Clk; reg En; reg Rst_n; reg [31:0] disp_data; wire [6:0] seg; wire [7:0] sel; digital_display u1 ( .Clk(Clk), .En(En), .Rst_n(Rst_n), .disp_data(disp_data), .seg(seg), .sel(sel) ); initial begin Clk = 1&#x27;b1; forever #(`clk_period/2) Clk = ~Clk; end initial begin Rst_n = 1&#x27;b0; En = 1&#x27;b1; disp_data = 32&#x27;h12345678; #(`clk_period*20); Rst_n = 1&#x27;b1; #(`clk_period*20); #20_000_000; disp_data = 32&#x27;h87654321; #20_000_000; disp_data = 32&#x27;h89abcdef; #20_000_000; $stop; end endmodule","text":"实现FPGA驱动数码管动态显示知识点： 数码管动态扫描实现。 In system sources and probes editor (ISSP)调试工具的使用。 工程代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//实现FPGA驱动数码管动态显示module digital_display(Clk, Rst_n, En, disp_data, sel, seg); input Clk; //50M，一个周期为20ns input Rst_n; input En; input [31:0] disp_data; //输入要求显示的内容 output reg [7:0] sel; //数码管位选（当前要显示的数码管） output reg [6:0] seg; //数码管段选（当前要显示的内容） //divider module reg [14:0] divider_cnt; //产生1ms的时钟，每0.5ms时钟信号需要翻转一次，0.5ms/20ns=25_000=16&#x27;b0110_0001_1010_1000，故需要15位计数器 reg Clk_1K; always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) divider_cnt &lt;= 15&#x27;d0; else if(~En) divider_cnt &lt;= 15&#x27;d0; else if(divider_cnt== 15&#x27;d24_999) divider_cnt &lt;= 15&#x27;d0; else divider_cnt &lt;= divider_cnt + 1&#x27;b1; end always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) Clk_1K &lt;= 1&#x27;b0; else if(~En) Clk_1K &lt;= 1&#x27;b0; else if(divider_cnt== 15&#x27;d24_999) Clk_1K &lt;= ~Clk_1K; else Clk_1K &lt;= Clk_1K; end //shift8 module reg [7:0] sel_r; always@(posedge Clk_1K or negedge Rst_n) begin //注意，分频器的输出信号作为D触发器的时钟信号，在大型设计中是不被允许的，此处设计为数码管驱动模块，影响不大，允许存在这样的毛刺 if(~Rst_n) sel_r &lt;= 8&#x27;b0000_0001; else if(sel_r == 8&#x27;b1000_0000) sel_r &lt;= 8&#x27;b0000_0001; else sel_r &lt;= &#123;sel_r[6:0],1&#x27;b0&#125;; //此句也可改为 sel_r &lt;= sel_r &lt;&lt; 1; end //MUX8 (combitional) reg [3:0] data_tmp; always@(*) begin case(sel_r) 8&#x27;b0000_0001: data_tmp = disp_data[3:0]; 8&#x27;b0000_0010: data_tmp = disp_data[7:4]; 8&#x27;b0000_0100: data_tmp = disp_data[11:8]; 8&#x27;b0000_1000: data_tmp = disp_data[15:12]; 8&#x27;b0001_0000: data_tmp = disp_data[19:16]; 8&#x27;b0010_0000: data_tmp = disp_data[23:20]; 8&#x27;b0100_0000: data_tmp = disp_data[27:24]; 8&#x27;b1000_0000: data_tmp = disp_data[31:28]; default: data_tmp = 4&#x27;b0000; endcase end //MUX2 (combitional) always@(*) begin if(~En) sel = 8&#x27;b0000_0000; else sel = sel_r; end //LUT (combitional) //注意：数码管灯段在输入为0时亮起，输入为1时熄灭； //h段为最高位，a段为最低位； always@(*) begin case(data_tmp) 4&#x27;b0000: seg = 7&#x27;b100_0000; //0 4&#x27;b0001: seg = 7&#x27;b111_1001; //1 4&#x27;b0010: seg = 7&#x27;b010_0100; //2 4&#x27;b0011: seg = 7&#x27;b011_0000; //3 4&#x27;b0100: seg = 7&#x27;b001_1001; //4 4&#x27;b0101: seg = 7&#x27;b001_0010; //5 4&#x27;b0110: seg = 7&#x27;b000_0010; //6 4&#x27;b0111: seg = 7&#x27;b111_1000; //7 4&#x27;b1000: seg = 7&#x27;b000_0000; //8 4&#x27;b1001: seg = 7&#x27;b001_0000; //9 4&#x27;b1010: seg = 7&#x27;b000_1000; //a 4&#x27;b1011: seg = 7&#x27;b000_0011; //b 4&#x27;b1100: seg = 7&#x27;b100_0110; //c 4&#x27;b1101: seg = 7&#x27;b010_0001; //d 4&#x27;b1110: seg = 7&#x27;b000_0110; //e 4&#x27;b1111: seg = 7&#x27;b000_1110; //f default: seg = 7&#x27;b111_1111; //全灭 endcase endendmodule TestBench1234567891011121314151617181920212223242526272829303132333435363738394041`timescale 1 ns/ 1 ps`define clk_period 20module digital_display_vlg_tst(); reg Clk; reg En; reg Rst_n; reg [31:0] disp_data; wire [6:0] seg; wire [7:0] sel; digital_display u1 ( .Clk(Clk), .En(En), .Rst_n(Rst_n), .disp_data(disp_data), .seg(seg), .sel(sel) ); initial begin Clk = 1&#x27;b1; forever #(`clk_period/2) Clk = ~Clk; end initial begin Rst_n = 1&#x27;b0; En = 1&#x27;b1; disp_data = 32&#x27;h12345678; #(`clk_period*20); Rst_n = 1&#x27;b1; #(`clk_period*20); #20_000_000; disp_data = 32&#x27;h87654321; #20_000_000; disp_data = 32&#x27;h89abcdef; #20_000_000; $stop; end endmodule ISSP","categories":[],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"http://example.com/tags/FPGA/"},{"name":"Verilog","slug":"Verilog","permalink":"http://example.com/tags/Verilog/"}]},{"title":"学习FPGA（三）","slug":"FPGA-3","date":"2022-04-15T07:39:43.000Z","updated":"2022-04-23T01:31:39.576Z","comments":true,"path":"2022/04/15/FPGA-3/","link":"","permalink":"http://example.com/2022/04/15/FPGA-3/","excerpt":"按键消抖主模块三段式状态机代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137//目的：设计一个按键消抖，滤波时间为20ms//晶振为50M，即一个时间周期为20ns//需要滤波1_000_000个时间周期`define filter_time 20&#x27;d1_000_000module key_filter(Clk, Rst_n, Key_in, Key_flag, Key_state); input Clk; //时钟输入 input Rst_n; //复位输入 input Key_in; //按键输入，按下时为0，断开时为1 output reg Key_flag; //按键输入变化后出现稳定状态时，显示为1（保持一个时钟周期），其余时候为0 output reg Key_state; //按键状态，按下时显示为0， 断开时为1 //set state(one-hot code) localparam IDLE = 4&#x27;b0001, FILTER0 = 4&#x27;b0010, DOWN = 4&#x27;b0100, FILTER1 = 4&#x27;b1000; reg [3:0] state, next; //edge check reg Key_tmp0, Key_tmp1; wire Key_posedge, Key_negedge; always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) begin Key_tmp0 &lt;= 1&#x27;b0; Key_tmp1 &lt;= 1&#x27;b0; end else begin Key_tmp0 &lt;= Key_in; //当Key_tmp0 = 1 且 Key_tmp1 = 0时即为一个上升沿 Key_tmp1 &lt;= Key_tmp0; //当Key_tmp0 = 0 且 Key_tmp1 = 1时即为一个下降沿 end end assign Key_posedge = ~Key_tmp1 &amp; Key_tmp0; assign Key_negedge = Key_tmp1 &amp; ~Key_tmp0; //filter counter reg [19:0] cnt; reg cnt_full; //计数器计满信号 reg en_cnt; //计数器使能信号 always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) begin cnt &lt;= &#x27;d0; cnt_full &lt;= 1&#x27;b0; end else if(en_cnt) begin if(cnt == (`filter_time - 1)) begin cnt &lt;= &#x27;d0; cnt_full &lt;= 1&#x27;b1; end else begin cnt &lt;= cnt + 1&#x27;b1; cnt_full &lt;= 1&#x27;b0; end end else begin cnt &lt;= &#x27;d0; cnt_full &lt;= 1&#x27;b0; end end //state transition(combinational) always@(*) begin case(state) IDLE: begin if(Key_negedge) next = FILTER0; else next = IDLE; end FILTER0: begin if(cnt_full) next = DOWN; else if(Key_posedge) next = IDLE; else next = FILTER0; end DOWN: begin if(Key_posedge) next = FILTER1; else next = DOWN; end FILTER1: begin if(cnt_full) next = IDLE; else if(Key_negedge) next = DOWN; else next = FILTER1; end default: next = IDLE; endcase end //state flip-flops(sequential) always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) state &lt;= IDLE; else state &lt;= next; end //output always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) Key_state &lt;= 1&#x27;b0; else case(next) IDLE: begin en_cnt &lt;= 1&#x27;b0; //IDLE状态下计数器不计数 Key_state &lt;= 1&#x27;b1; //此时Key未被按下 Key_flag &lt;= 1&#x27;b0; end FILTER0: begin en_cnt &lt;= 1&#x27;b1; //FILTER0状态下计数器开始计数 Key_state &lt;= 1&#x27;b1; //此时Key仍处于未被按下状态 Key_flag &lt;= 1&#x27;b0; end DOWN: begin en_cnt &lt;= 1&#x27;b0; //DOWN状态下计数器不计数 Key_state &lt;= 1&#x27;b0; //此时Key已被按下 Key_flag &lt;= cnt_full;//探测到Key被按下 end FILTER1: begin en_cnt &lt;= 1&#x27;b1; //FILTER0状态下计数器开始计数 Key_state &lt;= 1&#x27;b0; //此时Key仍处于被按下状态 Key_flag &lt;= 1&#x27;b0; end default: begin en_cnt &lt;= 1&#x27;b0; Key_state &lt;= 1&#x27;b1; Key_flag &lt;= 1&#x27;b0; end endcase end //assign Key_flag = Key_negedge; //组合逻辑输出方式来输出Key_flagendmodule Testbench12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091`timescale 1 ns/ 1 ns`define clk_period 20module key_filter_vlg_tst(); // test vector input registers reg Clk; reg Key_in; reg Rst_n; // wires wire Key_flag; wire Key_state; key_filter i1 ( // port map - connection between master ports and signals/registers .Clk(Clk), .Key_flag(Key_flag), .Key_in(Key_in), .Key_state(Key_state), .Rst_n(Rst_n) ); initial begin Clk = 1&#x27;b1; forever #(`clk_period/2) Clk = ~Clk; end initial begin Rst_n = 1&#x27;b0; Key_in = 1&#x27;b1; #(`clk_period*10) Rst_n = 1&#x27;b1; #(`clk_period*10 + 1); //按下一次 Key_in = 1&#x27;b0;#10000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#5_400_000; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#200; Key_in = 1&#x27;b0;#20_000_100; #10000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#20_000_100; #10_000_000; //second time Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#200; Key_in = 1&#x27;b0;#20_000_100; #10000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#20_000_100; #10000; //third time Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#200; Key_in = 1&#x27;b0;#20_000_100; #10000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#20_000_100; #10000; $stop; endendmodule 仿真模型","text":"按键消抖主模块三段式状态机代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137//目的：设计一个按键消抖，滤波时间为20ms//晶振为50M，即一个时间周期为20ns//需要滤波1_000_000个时间周期`define filter_time 20&#x27;d1_000_000module key_filter(Clk, Rst_n, Key_in, Key_flag, Key_state); input Clk; //时钟输入 input Rst_n; //复位输入 input Key_in; //按键输入，按下时为0，断开时为1 output reg Key_flag; //按键输入变化后出现稳定状态时，显示为1（保持一个时钟周期），其余时候为0 output reg Key_state; //按键状态，按下时显示为0， 断开时为1 //set state(one-hot code) localparam IDLE = 4&#x27;b0001, FILTER0 = 4&#x27;b0010, DOWN = 4&#x27;b0100, FILTER1 = 4&#x27;b1000; reg [3:0] state, next; //edge check reg Key_tmp0, Key_tmp1; wire Key_posedge, Key_negedge; always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) begin Key_tmp0 &lt;= 1&#x27;b0; Key_tmp1 &lt;= 1&#x27;b0; end else begin Key_tmp0 &lt;= Key_in; //当Key_tmp0 = 1 且 Key_tmp1 = 0时即为一个上升沿 Key_tmp1 &lt;= Key_tmp0; //当Key_tmp0 = 0 且 Key_tmp1 = 1时即为一个下降沿 end end assign Key_posedge = ~Key_tmp1 &amp; Key_tmp0; assign Key_negedge = Key_tmp1 &amp; ~Key_tmp0; //filter counter reg [19:0] cnt; reg cnt_full; //计数器计满信号 reg en_cnt; //计数器使能信号 always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) begin cnt &lt;= &#x27;d0; cnt_full &lt;= 1&#x27;b0; end else if(en_cnt) begin if(cnt == (`filter_time - 1)) begin cnt &lt;= &#x27;d0; cnt_full &lt;= 1&#x27;b1; end else begin cnt &lt;= cnt + 1&#x27;b1; cnt_full &lt;= 1&#x27;b0; end end else begin cnt &lt;= &#x27;d0; cnt_full &lt;= 1&#x27;b0; end end //state transition(combinational) always@(*) begin case(state) IDLE: begin if(Key_negedge) next = FILTER0; else next = IDLE; end FILTER0: begin if(cnt_full) next = DOWN; else if(Key_posedge) next = IDLE; else next = FILTER0; end DOWN: begin if(Key_posedge) next = FILTER1; else next = DOWN; end FILTER1: begin if(cnt_full) next = IDLE; else if(Key_negedge) next = DOWN; else next = FILTER1; end default: next = IDLE; endcase end //state flip-flops(sequential) always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) state &lt;= IDLE; else state &lt;= next; end //output always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) Key_state &lt;= 1&#x27;b0; else case(next) IDLE: begin en_cnt &lt;= 1&#x27;b0; //IDLE状态下计数器不计数 Key_state &lt;= 1&#x27;b1; //此时Key未被按下 Key_flag &lt;= 1&#x27;b0; end FILTER0: begin en_cnt &lt;= 1&#x27;b1; //FILTER0状态下计数器开始计数 Key_state &lt;= 1&#x27;b1; //此时Key仍处于未被按下状态 Key_flag &lt;= 1&#x27;b0; end DOWN: begin en_cnt &lt;= 1&#x27;b0; //DOWN状态下计数器不计数 Key_state &lt;= 1&#x27;b0; //此时Key已被按下 Key_flag &lt;= cnt_full;//探测到Key被按下 end FILTER1: begin en_cnt &lt;= 1&#x27;b1; //FILTER0状态下计数器开始计数 Key_state &lt;= 1&#x27;b0; //此时Key仍处于被按下状态 Key_flag &lt;= 1&#x27;b0; end default: begin en_cnt &lt;= 1&#x27;b0; Key_state &lt;= 1&#x27;b1; Key_flag &lt;= 1&#x27;b0; end endcase end //assign Key_flag = Key_negedge; //组合逻辑输出方式来输出Key_flagendmodule Testbench12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091`timescale 1 ns/ 1 ns`define clk_period 20module key_filter_vlg_tst(); // test vector input registers reg Clk; reg Key_in; reg Rst_n; // wires wire Key_flag; wire Key_state; key_filter i1 ( // port map - connection between master ports and signals/registers .Clk(Clk), .Key_flag(Key_flag), .Key_in(Key_in), .Key_state(Key_state), .Rst_n(Rst_n) ); initial begin Clk = 1&#x27;b1; forever #(`clk_period/2) Clk = ~Clk; end initial begin Rst_n = 1&#x27;b0; Key_in = 1&#x27;b1; #(`clk_period*10) Rst_n = 1&#x27;b1; #(`clk_period*10 + 1); //按下一次 Key_in = 1&#x27;b0;#10000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#5_400_000; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#200; Key_in = 1&#x27;b0;#20_000_100; #10000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#20_000_100; #10_000_000; //second time Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#200; Key_in = 1&#x27;b0;#20_000_100; #10000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#20_000_100; #10000; //third time Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#200; Key_in = 1&#x27;b0;#20_000_100; #10000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1000; Key_in = 1&#x27;b1;#2000; Key_in = 1&#x27;b0;#1400; Key_in = 1&#x27;b1;#2600; Key_in = 1&#x27;b0;#1300; Key_in = 1&#x27;b1;#20_000_100; #10000; $stop; endendmodule 仿真模型随机数$random默认是32位的随机数，根据自己的需要来取余计算例如：需要0 ~ 65535的随机数，则可 12reg [15:0] myrand;initial myrand = &#123;$random&#125;%65536; 其中，myrand就是所需的随机数。 task定义一个task如下所示 123456789101112131415161718reg [15:0] myrand;task press_key; begin repeat(50) begin myrand = &#123;$random&#125;%65536; #myrand key_in = ~key_in; end key_in = 0; #50_000_000; repeat(50) begin myrand = &#123;$random&#125;%65536; #myrand key_in = ~key_in; end key_in = 0; #50_000_000; endendtask 然后就可以直接在testbench中使用 1press_key; 仿真模型新建一个key_module文件 123456789101112131415161718192021222324252627282930313233`timescale 1 ns/1 psmodule key_module(key); output reg key; reg [15:0] myrand; initial begin key = 1&#x27;b1; press_key; #10000; press_key; #10000; press_key; $stop; end task press_key; begin repeat(50) begin myrand = &#123;$random&#125;%65536; #myrand key = ~key; end key = 0; #50_000_000; repeat(50) begin myrand = &#123;$random&#125;%65536; #myrand key = ~key; end key = 1; #50_000_000; end endtaskendmodule 使用时需将该文件添加到test bench中，test bench主文件为 12345678910111213141516171819202122232425262728293031323334`timescale 1 ns/ 1 ns`define clk_period 20module key_filter_vlg_tst(); // test vector input registers reg Clk; wire Key_in; reg Rst_n; // wires wire Key_flag; wire Key_state; key_filter i1 ( // port map - connection between master ports and signals/registers .Clk(Clk), .Key_flag(Key_flag), .Key_in(Key_in), .Key_state(Key_state), .Rst_n(Rst_n) ); initial begin Clk = 1&#x27;b1; forever #(`clk_period/2) Clk = ~Clk; end initial begin Rst_n = 1&#x27;b0; #(`clk_period*10) Rst_n = 1&#x27;b1; #(`clk_period*10 + 1) ; end key_module u1(.key(Key_in)); endmodule","categories":[],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"http://example.com/tags/FPGA/"},{"name":"Verilog","slug":"Verilog","permalink":"http://example.com/tags/Verilog/"}]},{"title":"学习FPGA（二）","slug":"FPGA-2","date":"2022-04-14T01:38:13.000Z","updated":"2022-04-22T11:29:44.087Z","comments":true,"path":"2022/04/14/FPGA-2/","link":"","permalink":"http://example.com/2022/04/14/FPGA-2/","excerpt":"有限状态机状态的表示常用编码方法有二进制码、格雷码（Gray code）、独热码（one-hot code）。 二进制码即用二进制计数 优点：属于压缩状态编码，状态机所需的状态向量位数较少； 缺点：1、译码复杂；2、相邻状态变换时，会有多位发生改变，电噪声大、转换速度较慢、易出错；（实际电路中多位改变很难做到完全同时发生）； 格雷码（Gray code）","text":"有限状态机状态的表示常用编码方法有二进制码、格雷码（Gray code）、独热码（one-hot code）。 二进制码即用二进制计数 优点：属于压缩状态编码，状态机所需的状态向量位数较少； 缺点：1、译码复杂；2、相邻状态变换时，会有多位发生改变，电噪声大、转换速度较慢、易出错；（实际电路中多位改变很难做到完全同时发生）； 格雷码（Gray code）在一组数的编码中，任意两个相邻的代码只有一位二进制数不同，且最大数与最小数之间也仅有一位数不同构造方法：1位格雷码有两个码字(n+1)位格雷码中的前2n个码字等于n位格雷码的码字，按顺序书写，加前缀0(n+1)位格雷码中的后2n个码字等于n位格雷码的码字，按逆序书写，加前缀1n+1位格雷码的集合 &#x3D; n位格雷码集合(顺序)加前缀0 + n位格雷码集合(逆序)加前缀1如：二进制码：000-001-010-011-100-101-110-111 相应的格雷码：000-001-011-010-110-111-101 优点：1、属于压缩状态编码，状态机所需的状态向量位数较少；2、相邻状态变换时，仅有一位发生改变，电噪声小、转换速度较快； 缺点：1、译码复杂；2、是一种变权码，每一位码没有固定的大小，难以直接比较大小和算术运算； 独热码（one-hot code）有多少个状态就有多少个比特，其中有且只有一个比特为1，其余为0用独热码表示三个状态可以写为：001，010，100 优点：译码简单； 缺点：速度较慢，占用触发器资源较多，面积较大； 编写一个检测”Hello”序列的状态机设置状态时，常用localparam或者parameter。其中parameter可用作在顶层模块中例化底层模块时传递参数的接口；而localparam的作用域仅仅限于当前module，不能作为参数传递的接口。 状态机分为一段时状态机、两段式状态机、三段式状态机， 作者第一次写出的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374module state_machine (Clk, Rst_n, data, led); //Hello状态机 input Clk; //基准时钟信号50M input Rst_n; //输入异步复位信号 input [7:0] data; //输入数据 output reg led; //当前状态输入 //set state reg [2:0] state, next; localparam CHECK_H = &#x27;d0, CHECK_e = &#x27;d1, CHECK_la = &#x27;d2, CHECK_lb = &#x27;d3, CHECK_o = &#x27;d4; //state transition (combinational logic) always@(*) begin case(state) CHECK_H: begin if(data == &quot;H&quot;) next = CHECK_e; else next = CHECK_H; end CHECK_e: begin if(data == &quot;e&quot;) next = CHECK_la; else if(data == &quot;H&quot;) next = CHECK_e; else next = CHECK_H; end CHECK_la: begin if(data == &quot;l&quot;) next = CHECK_lb; else if(data == &quot;H&quot;) next = CHECK_e; else next = CHECK_H; end CHECK_lb: begin if(data == &quot;l&quot;) next = CHECK_o; else if(data == &quot;H&quot;) next = CHECK_e; else next = CHECK_H; end CHECK_o: begin if(data == &quot;o&quot;) next = CHECK_H; else if(data == &quot;H&quot;) next = CHECK_e; else next = CHECK_H; end default: next = CHECK_H;//默认状态下reset endcase end //state flip-flops (sequential logic) always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) state &lt;= CHECK_H; else state &lt;= next; end //output always@(posedge Clk or negedge Rst_n) begin if(~Rst_n) led &lt;= 1&#x27;b1; //通常led低电平有效，高电平无效 else case(state) CHECK_o: led &lt;= 1&#x27;b0; default: led &lt;= 1&#x27;b1; endcase endendmodule","categories":[],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"http://example.com/tags/FPGA/"},{"name":"Verilog","slug":"Verilog","permalink":"http://example.com/tags/Verilog/"}]},{"title":"学习FPGA（一）","slug":"FPGA-1","date":"2022-04-13T08:50:46.000Z","updated":"2022-04-22T11:37:40.104Z","comments":true,"path":"2022/04/13/FPGA-1/","link":"","permalink":"http://example.com/2022/04/13/FPGA-1/","excerpt":"刚好今天尝试使用hexo框架搭建了个人博客，索性记录一下自己学习FPGA的过程，方便日后查看和复习。 BCD计数器设计与验证目的是通过将三个BCD计数器级联来实现1000的计数单个BCD计数器的Verilog代码如下： 12345678910111213141516171819202122232425module bcd_counter(Clk, Cin, Rst_n, Cout, Q); input Clk;//时间基准信号 input Cin;//计数器进位输入 input Rst_n;//计数器复位输入 output reg Cout;//计数器进位输出 output reg [3:0] Q;//计数器计数输出 //产生输出进位信号 always@(posedge Clk or negedge Rst_n) begin if(Rst_n==1&#x27;b0) Cout = 1&#x27;b0; else if(Q==4&#x27;d9 &amp;&amp; Cin==1&#x27;b1) Cout = 1&#x27;b1; //此处的进位设置并不合理，级联后会发生错误 else Cout = 1&#x27;b0; end //执行计数过程 always@(posedge Clk or negedge Rst_n) begin if(Rst_n==1&#x27;b0) Q &lt;= 4&#x27;b0; else if(Cin==1&#x27;b1) begin if(Q==4&#x27;d9)Q &lt;= 4&#x27;b0; else Q &lt;= Q + 1&#x27;b1; end else Q &lt;= Q; endendmodule 使用modelsim分析时，先从sim中把子模块的输入输出信号全部添加到波形窗口中然后在波形窗口中选中所有信号（Ctrl+a），再按下快捷键Ctrl+g，完成按模块分组 将”&#x2F;&#x2F;产生输出进位信号”部分修改为： 12345always@(*) begin if(Rst_n==1&#x27;b0) Cout = 1&#x27;b0; else if(Q==4&#x27;d9 &amp;&amp; Cin==1&#x27;b1) Cout = 1&#x27;b1; else Cout = 1&#x27;b0;end","text":"刚好今天尝试使用hexo框架搭建了个人博客，索性记录一下自己学习FPGA的过程，方便日后查看和复习。 BCD计数器设计与验证目的是通过将三个BCD计数器级联来实现1000的计数单个BCD计数器的Verilog代码如下： 12345678910111213141516171819202122232425module bcd_counter(Clk, Cin, Rst_n, Cout, Q); input Clk;//时间基准信号 input Cin;//计数器进位输入 input Rst_n;//计数器复位输入 output reg Cout;//计数器进位输出 output reg [3:0] Q;//计数器计数输出 //产生输出进位信号 always@(posedge Clk or negedge Rst_n) begin if(Rst_n==1&#x27;b0) Cout = 1&#x27;b0; else if(Q==4&#x27;d9 &amp;&amp; Cin==1&#x27;b1) Cout = 1&#x27;b1; //此处的进位设置并不合理，级联后会发生错误 else Cout = 1&#x27;b0; end //执行计数过程 always@(posedge Clk or negedge Rst_n) begin if(Rst_n==1&#x27;b0) Q &lt;= 4&#x27;b0; else if(Cin==1&#x27;b1) begin if(Q==4&#x27;d9)Q &lt;= 4&#x27;b0; else Q &lt;= Q + 1&#x27;b1; end else Q &lt;= Q; endendmodule 使用modelsim分析时，先从sim中把子模块的输入输出信号全部添加到波形窗口中然后在波形窗口中选中所有信号（Ctrl+a），再按下快捷键Ctrl+g，完成按模块分组 将”&#x2F;&#x2F;产生输出进位信号”部分修改为： 12345always@(*) begin if(Rst_n==1&#x27;b0) Cout = 1&#x27;b0; else if(Q==4&#x27;d9 &amp;&amp; Cin==1&#x27;b1) Cout = 1&#x27;b1; else Cout = 1&#x27;b0;end 此即行为级建模实现的组合逻辑，但仿真的结果出现了奇怪的毛刺，这是rtl级仿真不该出现的 于是再将其改为： 1assign Cout = (Q==4&#x27;d9 &amp;&amp; Cin==1&#x27;b1); 此即数据流建模实现的组合逻辑。需要注意的是，此时应当将Cout的类型变更为wire型，否则会发生编译错误。 他们占用的逻辑资源也出现了不同","categories":[],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"http://example.com/tags/FPGA/"},{"name":"Verilog","slug":"Verilog","permalink":"http://example.com/tags/Verilog/"}]},{"title":"My first blog","slug":"My-first-blog","date":"2022-04-13T04:27:06.000Z","updated":"2022-04-15T09:51:39.383Z","comments":true,"path":"2022/04/13/My-first-blog/","link":"","permalink":"http://example.com/2022/04/13/My-first-blog/","excerpt":"【转载】如何解决无法访问Github在 C:\\Windows\\System32\\drivers\\etc\\hosts 文件中末尾添加两行 12140.82.113.4 github.com140.82.113.4 www.github.com 其中ip地址可在 https://github.com.ipaddress.com/www.github.com 中查询 若完成上述操作后仍无法访问，可以再添加两行 1269.171.224.40 github.global.ssl.fastly.net185.199.111.153 assets-cdn.github.com 其中ip地址可以在 http://tool.chinaz.com/dns 中输入网址查询，选取TTL值较低的ip地址即可","text":"【转载】如何解决无法访问Github在 C:\\Windows\\System32\\drivers\\etc\\hosts 文件中末尾添加两行 12140.82.113.4 github.com140.82.113.4 www.github.com 其中ip地址可在 https://github.com.ipaddress.com/www.github.com 中查询 若完成上述操作后仍无法访问，可以再添加两行 1269.171.224.40 github.global.ssl.fastly.net185.199.111.153 assets-cdn.github.com 其中ip地址可以在 http://tool.chinaz.com/dns 中输入网址查询，选取TTL值较低的ip地址即可 在修改hosts文件时，通常先将其复制到其他路径得到一个副本，将副本修改保存后替换原文件。（建议修改前备份一个hosts文件） 转载自 https://www.cnblogs.com/yanch01/p/GitHub-access.html","categories":[],"tags":[{"name":"test","slug":"test","permalink":"http://example.com/tags/test/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-04-13T04:19:46.145Z","updated":"2022-04-13T14:39:11.924Z","comments":true,"path":"2022/04/13/hello-world/","link":"","permalink":"http://example.com/2022/04/13/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"FPGA","slug":"FPGA","permalink":"http://example.com/tags/FPGA/"},{"name":"Verilog","slug":"Verilog","permalink":"http://example.com/tags/Verilog/"},{"name":"test","slug":"test","permalink":"http://example.com/tags/test/"}]}